[{"path":"index.html","id":"환영합니다","chapter":"환영합니다","heading":"환영합니다","text":" website 2nd edition “Advanced R”, book Chapman & Hall’s R Series. book designed primarily R users want improve programming skills understanding language. also useful programmers coming R languages, help understand R works way .’re looking 1st edition, can find http://adv-r..co.nz/.","code":""},{"path":"index.html","id":"license","chapter":"환영합니다","heading":"License","text":"work, whole, licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.code contained book simultaneously available MIT license; means free use packages, long cite source.","code":""},{"path":"index.html","id":"other-books","chapter":"환영합니다","heading":"Other books","text":"may also interested :“Advanced R Solutions” \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.“Advanced R Solutions” \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.“R Data Science” introduces R\ntool data science, focussing consistent\nset packages known tidyverse.“R Data Science” introduces R\ntool data science, focussing consistent\nset packages known tidyverse.“R Packages” teaches \nmake R’s fantastic package system.“R Packages” teaches \nmake R’s fantastic package system.","code":""},{"path":"functions.html","id":"functions","chapter":"1 함수","heading":"1 함수","text":"","code":""},{"path":"functions.html","id":"introduction","chapter":"1 함수","heading":"1.1 Introduction","text":"\n’re reading book, ’ve probably already created many R functions know use reduce duplication code. chapter, ’ll learn turn informal, working knowledge rigorous, theoretical understanding. ’ll see interesting tricks techniques along way, keep mind ’ll learn important understanding advanced topics discussed later book.","code":""},{"path":"functions.html","id":"quiz","chapter":"1 함수","heading":"Quiz","text":"Answer following questions see can safely skip chapter. can find answers Section 1.9.three components function?three components function?following code return?\n\nx <- 10\nf1 <- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()following code return?usually write code?\n\n`+`(1, `*`(2, 3))usually write code?make call easier read?\n\nmean(, TRUE, x = c(1:10, NA))make call easier read?following code throw error executed? ?\n\nf2 <- function(, b) {\n  * 10\n}\nf2(10, stop(\"error!\"))following code throw error executed? ?infix function? write ? ’s replacement\nfunction? write ?infix function? write ? ’s replacement\nfunction? write ?ensure cleanup action occurs regardless function\nexits?ensure cleanup action occurs regardless function\nexits?","code":"\nx <- 10\nf1 <- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()\n`+`(1, `*`(2, 3))\nmean(, TRUE, x = c(1:10, NA))\nf2 <- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))"},{"path":"functions.html","id":"outline","chapter":"1 함수","heading":"Outline","text":"Section 1.2 describes basics creating \nfunction, three main components function, exception\nmany function rules: primitive functions (implemented C, \nR).Section 1.2 describes basics creating \nfunction, three main components function, exception\nmany function rules: primitive functions (implemented C, \nR).Section 1.3 discusses strengths weaknesses\nthree forms function composition commonly used R code.Section 1.3 discusses strengths weaknesses\nthree forms function composition commonly used R code.Section 1.4 shows R finds value associated\ngiven name, .e. rules lexical scoping.Section 1.4 shows R finds value associated\ngiven name, .e. rules lexical scoping.Section 1.5 devoted important property \nfunction arguments: evaluated used first time.Section 1.5 devoted important property \nfunction arguments: evaluated used first time.Section 1.6 discusses special ... argument, \nallows pass extra arguments another function.Section 1.6 discusses special ... argument, \nallows pass extra arguments another function.Section 1.7 discusses two primary ways \nfunction can exit, define exit handler, code run \nexit, regardless triggers .Section 1.7 discusses two primary ways \nfunction can exit, define exit handler, code run \nexit, regardless triggers .Section 1.8 shows various ways R\ndisguises ordinary function calls, can use standard prefix\nform better understand ’s going .Section 1.8 shows various ways R\ndisguises ordinary function calls, can use standard prefix\nform better understand ’s going .","code":""},{"path":"functions.html","id":"function-fundamentals","chapter":"1 함수","heading":"1.2 Function fundamentals","text":"understand functions R need internalise two important ideas:Functions can broken three components: arguments, body, environment.exceptions every rule, case, small selection “primitive” base functions implemented purely C.Functions objects, just vectors objects.","code":""},{"path":"functions.html","id":"fun-components","chapter":"1 함수","heading":"1.2.1 Function components","text":"\n\n\n\n\n\n\nfunction three parts:formals(), list arguments control call function.formals(), list arguments control call function.body(), code inside function.body(), code inside function.environment(), data structure determines function finds\nvalues associated names.environment(), data structure determines function finds\nvalues associated names.formals body specified explicitly create function, environment specified implicitly, based defined function. function environment always exists, printed function isn’t defined global environment.’ll draw functions following diagram. black dot left environment. two blocks right function arguments.Like objects R, functions can also possess number additional attributes(). One attribute used base R srcref, short source reference. points source code used create function. srcref used printing , unlike body(), contains code comments formatting.","code":"\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n#> $x\n#> \n#> \n#> $y\n\nbody(f02)\n#> {\n#>     x + y\n#> }\n\nenvironment(f02)\n#> <environment: R_GlobalEnv>\nattr(f02, \"srcref\")\n#> function(x, y) {\n#>   # A comment\n#>   x + y\n#> }"},{"path":"functions.html","id":"primitive-functions","chapter":"1 함수","heading":"1.2.2 Primitive functions","text":"\n\none exception rule function three components. Primitive functions, like sum() [, call C code directly.either type builtin type special.functions exist primarily C, R, formals(), body(), environment() NULL:Primitive functions found base package. certain performance advantages, benefit comes price: harder write. reason, R-core generally avoids creating unless option.","code":"\nsum\n#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n#> .Primitive(\"[\")\ntypeof(sum)\n#> [1] \"builtin\"\ntypeof(`[`)\n#> [1] \"special\"\nformals(sum)\n#> NULL\nbody(sum)\n#> NULL\nenvironment(sum)\n#> NULL"},{"path":"functions.html","id":"first-class-functions","chapter":"1 함수","heading":"1.2.3 First-class functions","text":"\n’s important understand R functions objects right, language property often called “first-class functions.” Unlike many languages, special syntax defining naming function: simply create function object (function) bind name <-:almost always create function bind name, binding step compulsory. choose give function name, get anonymous function. useful ’s worth effort figure name:final option put functions list:R, ’ll often see functions called closures. name reflects fact R functions capture, enclose, environments, ’ll learn Section 2.4.2.","code":"\nf01 <- function(x) {\n  sin(1 / x ^ 2)\n}\nlapply(mtcars, function(x) length(unique(x)))\nFilter(function(x) !is.numeric(x), mtcars)\nintegrate(function(x) sin(x) ^ 2, 0, pi)\nfuns <- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n#> [1] 20"},{"path":"functions.html","id":"invoking-a-function","chapter":"1 함수","heading":"1.2.4 Invoking a function","text":"normally call function placing arguments, wrapped parentheses, name: mean(1:10, na.rm = TRUE). 인수들이 데이터 구조 안에 있으면 어떻게 할까?.call() 을 대신 사용하면 된다: 두 개의 인수를 취하는데, 호출하는 함수와 함수 인수들을 포함한 리스트이다.’ll come back idea Section ??.","code":"\nargs <- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n#> [1] 5.5"},{"path":"functions.html","id":"exercises","chapter":"1 함수","heading":"1.2.5 Exercises","text":"Given name, like \"mean\", match.fun() lets find function.\nGiven function, can find name? doesn’t make sense R?Given name, like \"mean\", match.fun() lets find function.\nGiven function, can find name? doesn’t make sense R?’s possible (although typically useful) call anonymous function.\ntwo approaches correct? ?\n\nfunction(x) 3()\n#> function(x) 3()\n(function(x) 3)()\n#> [1] 3It’s possible (although typically useful) call anonymous function.\ntwo approaches correct? ?good rule thumb anonymous function fit one line\nshouldn’t need use {}. Review code. \nused anonymous function instead named function? \nused named function instead anonymous function?good rule thumb anonymous function fit one line\nshouldn’t need use {}. Review code. \nused anonymous function instead named function? \nused named function instead anonymous function?function allows tell object function? function\nallows tell function primitive function?function allows tell object function? function\nallows tell function primitive function?code makes list functions base package.\n\nobjs <- mget(ls(\"package:base\", = TRUE), inherits = TRUE)\nfuns <- Filter(.function, objs)\nUse answer following questions:\nbase function arguments?\nmany base functions arguments? ’s special \nfunctions?\nadapt code find primitive functions?\ncode makes list functions base package.Use answer following questions:base function arguments?base function arguments?many base functions arguments? ’s special \nfunctions?many base functions arguments? ’s special \nfunctions?adapt code find primitive functions?adapt code find primitive functions?three important components function?three important components function?printing function show environment created ?printing function show environment created ?","code":"\nfunction(x) 3()\n#> function(x) 3()\n(function(x) 3)()\n#> [1] 3\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)"},{"path":"functions.html","id":"function-composition","chapter":"1 함수","heading":"1.3 Function composition","text":"\n\n\nBase R provides two ways compose multiple function calls. example, imagine want compute population standard deviation using sqrt() mean() building blocks:either nest function calls:save intermediate results variables:magrittr package1 provides third option: binary operator %>%, called pipe pronounced “.”x %>% f() equivalent f(x); x %>% f(y) equivalent f(x, y). pipe allows focus high-level composition functions rather low-level flow data; focus ’s done (verbs), rather ’s modified (nouns). style common Haskell F#, main inspiration magrittr, default style stack based programming languages like Forth Factor.three options strengths weaknesses:Nesting, f(g(x)), concise, well suited short sequences. \nlonger sequences hard read read inside \nright left. result, arguments can get spread long distances\ncreating Dagwood\nsandwich problem.Nesting, f(g(x)), concise, well suited short sequences. \nlonger sequences hard read read inside \nright left. result, arguments can get spread long distances\ncreating Dagwood\nsandwich problem.Intermediate objects, y <- f(x); g(y), requires name intermediate\nobjects. strength objects important, weakness \nvalues truly intermediate.Intermediate objects, y <- f(x); g(y), requires name intermediate\nobjects. strength objects important, weakness \nvalues truly intermediate.Piping, x %>% f() %>% g(), allows read code straightforward\nleft--right fashion doesn’t require name intermediate objects.\ncan use linear sequences transformations single\nobject. also requires additional third party package assumes \nreader understands piping.Piping, x %>% f() %>% g(), allows read code straightforward\nleft--right fashion doesn’t require name intermediate objects.\ncan use linear sequences transformations single\nobject. also requires additional third party package assumes \nreader understands piping.code use combination three styles. Piping common data analysis code, much analysis consists sequence transformations object (like data frame plot). tend use piping infrequently packages; bad idea, ’s often less natural fit.","code":"\nsquare <- function(x) x^2\ndeviation <- function(x) x - mean(x)\nx <- runif(100)\n\nsqrt(mean(square(deviation(x))))\n#> [1] 0.274\nout <- deviation(x)\nout <- square(out)\nout <- mean(out)\nout <- sqrt(out)\nout\n#> [1] 0.274\nlibrary(magrittr)\n\nx %>%\n  deviation() %>%\n  square() %>%\n  mean() %>%\n  sqrt()\n#> [1] 0.274"},{"path":"functions.html","id":"lexical-scoping","chapter":"1 함수","heading":"1.4 Lexical scoping","text":"Chapter ??, discussed assignment, act binding name value. ’ll discuss scoping, act finding value associated name.basic rules scoping quite intuitive, ’ve probably already internalised , even never explicitly studied . example, following code return, 10 20?2In section, ’ll learn formal rules scoping well subtle details. deeper understanding scoping help use advanced functional programming tools, eventually, even write tools translate R code languages.R uses lexical scoping3: looks values names based function defined, called. “Lexical” English adjective means relating words vocabulary. ’s technical CS term tells us scoping rules use parse-time, rather run-time structure.R’s lexical scoping follows four primary rules:Name maskingFunctions versus variablesA fresh startDynamic lookup","code":"\nx <- 10\ng01 <- function() {\n  x <- 20\n  x\n}\n\ng01()"},{"path":"functions.html","id":"name-masking","chapter":"1 함수","heading":"1.4.1 Name masking","text":"basic principle lexical scoping names defined inside function mask names defined outside function. illustrated following example.name isn’t defined inside function, R looks one level .rules apply function defined inside another function. First, R looks inside current function. , looks function defined (, way global environment). Finally, looks loaded packages.Run following code head, confirm result running code.4The rules also apply functions created functions, call manufactured functions, topic Chapter 4.","code":"\nx <- 10\ny <- 20\ng02 <- function() {\n  x <- 1\n  y <- 2\n  c(x, y)\n}\ng02()\n#> [1] 1 2\nx <- 2\ng03 <- function() {\n  y <- 1\n  c(x, y)\n}\ng03()\n#> [1] 2 1\n\n# And this doesn't change the previous value of y\ny\n#> [1] 20\nx <- 1\ng04 <- function() {\n  y <- 2\n  i <- function() {\n    z <- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()"},{"path":"functions.html","id":"functions-versus-variables","chapter":"1 함수","heading":"1.4.2 Functions versus variables","text":"R, functions ordinary objects. means scoping rules described also apply functions:However, function non-function share name (must, course, reside different environments), applying rules gets little complicated. use name function call, R ignores non-function objects looking value. example, code , g09 takes two different values:record, using name different things confusing best avoided!","code":"\ng07 <- function(x) x + 1\ng08 <- function() {\n  g07 <- function(x) x + 100\n  g07(10)\n}\ng08()\n#> [1] 110\ng09 <- function(x) x + 100\ng10 <- function() {\n  g09 <- 10\n  g09(g09)\n}\ng10()\n#> [1] 110"},{"path":"functions.html","id":"fresh-start","chapter":"1 함수","heading":"1.4.3 A fresh start","text":"happens values invocations function? Consider example . happen first time run function? happen second time?5 (haven’t seen exists() , returns TRUE ’s variable name returns FALSE .)might surprised g11() always returns value. happens every time function called new environment created host execution. means function way tell happened last time run; invocation completely independent. ’ll see ways get around Section 4.2.4.","code":"\ng11 <- function() {\n  if (!exists(\"a\")) {\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\n\ng11()\ng11()"},{"path":"functions.html","id":"dynamic-lookup","chapter":"1 함수","heading":"1.4.4 Dynamic lookup","text":"Lexical scoping determines , look values. R looks values function run, function created. Together, two properties tell us output function can differ depending objects outside function’s environment:behaviour can quite annoying. make spelling mistake code, won’t get error message create function. depending variables defined global environment, might even get error message run function.detect problem, use codetools::findGlobals(). function lists external dependencies (unbound symbols) within function:solve problem, can manually change function’s environment emptyenv(), environment contains nothing:problem solution reveal seemingly undesirable behaviour exists: R relies lexical scoping find everything, obvious, like mean(), less obvious, like + even {. gives R’s scoping rules rather beautiful simplicity.","code":"\ng12 <- function() x + 1\nx <- 15\ng12()\n#> [1] 16\n\nx <- 20\ng12()\n#> [1] 21\ncodetools::findGlobals(g12)\n#> [1] \"+\" \"x\"\nenvironment(g12) <- emptyenv()\ng12()\n#> Error in x + 1: could not find function \"+\""},{"path":"functions.html","id":"exercises-1","chapter":"1 함수","heading":"1.4.5 Exercises","text":"following code return? ? Describe three\nc’s interpreted.\n\nc <- 10\nc(c = c)following code return? ? Describe three\nc’s interpreted.four principles govern R looks values?four principles govern R looks values?following function return? Make prediction \nrunning code .\n\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)following function return? Make prediction \nrunning code .","code":"\nc <- 10\nc(c = c)\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)"},{"path":"functions.html","id":"lazy-evaluation","chapter":"1 함수","heading":"1.5 Lazy evaluation","text":"\n\nR, function arguments lazily evaluated: ’re evaluated accessed. example, code doesn’t generate error x never used:important feature allows things like include potentially expensive computations function arguments evaluated needed.","code":"\nh01 <- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n#> [1] 10"},{"path":"functions.html","id":"promises","chapter":"1 함수","heading":"1.5.1 Promises","text":"\nLazy evaluation powered data structure called promise, (less commonly) thunk. ’s one features makes R interesting programming language (’ll return promises Section ??).promise three components:expression, like x + y, gives rise delayed computation.expression, like x + y, gives rise delayed computation.environment expression evaluated, .e. \nenvironment function called. makes sure \nfollowing function returns 11, 101:\n\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\n\nh02(y)\n#> [1] 11\nalso means assignment inside call function,\nvariable bound outside function, inside .\n\nh02(y <- 1000)\n#> [1] 1001\ny\n#> [1] 1000An environment expression evaluated, .e. \nenvironment function called. makes sure \nfollowing function returns 11, 101:also means assignment inside call function,\nvariable bound outside function, inside .value, computed cached first time promise \naccessed expression evaluated specified environment.\nensures promise evaluated , \nsee “Calculating…” printed following example.\n\ndouble <- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 <- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#> Calculating...\n#> [1] 40 40A value, computed cached first time promise \naccessed expression evaluated specified environment.\nensures promise evaluated , \nsee “Calculating…” printed following example.manipulate promises R code. Promises like quantum state: attempt inspect R code force immediate evaluation, making promise disappear. Later, Section ??, ’ll learn quosures, convert promises R object can easily inspect expression environment.","code":"\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\n\nh02(y)\n#> [1] 11\nh02(y <- 1000)\n#> [1] 1001\ny\n#> [1] 1000\ndouble <- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 <- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#> Calculating...\n#> [1] 40 40"},{"path":"functions.html","id":"default-arguments","chapter":"1 함수","heading":"1.5.2 Default arguments","text":"Thanks lazy evaluation, default values can defined terms arguments, even terms variables defined later function:Many base R functions use technique, don’t recommend . makes code harder understand: predict returned, need know exact order default arguments evaluated.evaluation environment slightly different default user supplied arguments, default arguments evaluated inside function. means seemingly identical calls can yield different results. ’s easiest see extreme example:","code":"\nh04 <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 10\n  b <- 100\n  \n  c(x, y, z)\n}\n\nh04()\n#> [1]   1   2 110\nh05 <- function(x = ls()) {\n  a <- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n#> [1] \"a\" \"x\"\n\n# ls() evaluated in global environment:\nh05(ls())\n#> [1] \"h05\""},{"path":"functions.html","id":"missing-arguments","chapter":"1 함수","heading":"1.5.3 Missing arguments","text":"\ndetermine argument’s value comes user default, can use missing():missing() best used sparingly, however. Take sample(), example. many arguments required?looks like x size required, size supplied, sample() uses missing() provide default. rewrite sample, ’d use explicit NULL indicate size required can supplied:binary pattern created %||% infix function, uses left side ’s NULL right side otherwise, can simplify sample():\nlazy evaluation, don’t need worry unnecessary computation: right side %||% evaluated left side NULL.","code":"\nh06 <- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n#> List of 2\n#>  $ : logi TRUE\n#>  $ : num 10\nstr(h06(10))\n#> List of 2\n#>  $ : logi FALSE\n#>  $ : num 10\nargs(sample)\n#> function (x, size, replace = FALSE, prob = NULL) \n#> NULL\nsample <- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  if (is.null(size)) {\n    size <- length(x)\n  }\n  \n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}\n`%||%` <- function(lhs, rhs) {\n  if (!is.null(lhs)) {\n    lhs\n  } else {\n    rhs\n  }\n}\n\nsample <- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  size <- size %||% length(x)\n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}"},{"path":"functions.html","id":"exercises-2","chapter":"1 함수","heading":"1.5.4 Exercises","text":"important property && makes x_ok() work?\n\nx_ok <- function(x) {\n  !.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE\ndifferent code? behaviour undesirable ?\n\nx_ok <- function(x) {\n  !.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE FALSE FALSEWhat important property && makes x_ok() work?different code? behaviour undesirable ?function return? ? principle illustrate?\n\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()function return? ? principle illustrate?function return? ? principle illustrate?\n\ny <- 10\nf1 <- function(x = {y <- 1; 2}, y = 0) {\n  c(x, y)\n}\nf1()\nyWhat function return? ? principle illustrate?hist(), default value xlim range(breaks), default\nvalue breaks \"Sturges\", \n\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nExplain hist() works get correct xlim value.hist(), default value xlim range(breaks), default\nvalue breaks \"Sturges\", andExplain hist() works get correct xlim value.Explain function works. confusing?\n\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#> [1] \"2021-10-18 00:50:05 UTC\"Explain function works. confusing?many arguments required calling library()?many arguments required calling library()?","code":"\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE FALSE FALSE\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()\ny <- 10\nf1 <- function(x = {y <- 1; 2}, y = 0) {\n  c(x, y)\n}\nf1()\ny\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#> [1] \"2021-10-18 00:50:05 UTC\""},{"path":"functions.html","id":"fun-dot-dot-dot","chapter":"1 함수","heading":"1.6 ... (dot-dot-dot)","text":"\n\nFunctions can special argument ... (pronounced dot-dot-dot). , function can take number additional arguments. programming languages, type argument often called varargs (short variable arguments), function uses said variadic.can also use ... pass additional arguments another function.Using special form, ..N, ’s possible (rarely useful) refer elements ... position:useful list(...), evaluates arguments stores list:(See also rlang::list2() support splicing silently ignore trailing commas, rlang::enquos() capture unevaluated arguments, topic [quasiquotation].)two primary uses ..., ’ll come back later book:function takes function argument, want way \npass additional arguments function. example, lapply()\nuses ... pass na.rm mean():\n\nx <- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#> List 2\n#>  $ : num 2\n#>  $ : num 5\n’ll come back technique Section 3.2.3.function takes function argument, want way \npass additional arguments function. example, lapply()\nuses ... pass na.rm mean():’ll come back technique Section 3.2.3.function S3 generic, need way allow methods \ntake arbitrary extra arguments. example, take print() function.\ndifferent options printing depending type \nobject, ’s way pre-specify every possible argument ...\nallows individual methods different arguments:\n\nprint(factor(letters), max.levels = 4)\n\nprint(y ~ x, showEnv = TRUE)\n’ll come back use ... Section ??.function S3 generic, need way allow methods \ntake arbitrary extra arguments. example, take print() function.\ndifferent options printing depending type \nobject, ’s way pre-specify every possible argument ...\nallows individual methods different arguments:’ll come back use ... Section ??.Using ... comes two downsides:use pass arguments another function, \ncarefully explain user arguments go. makes \nhard understand can functions like lapply() \nplot().use pass arguments another function, \ncarefully explain user arguments go. makes \nhard understand can functions like lapply() \nplot().misspelled argument raise error. makes easy \ntypos go unnoticed:\n\nsum(1, 2, NA, na_rm = TRUE)\n#> [1] NAA misspelled argument raise error. makes easy \ntypos go unnoticed:","code":"\ni01 <- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 <- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n#> List of 2\n#>  $ y: num 2\n#>  $ z: num 3\ni03 <- function(...) {\n  list(first = ..1, third = ..3)\n}\nstr(i03(1, 2, 3))\n#> List of 2\n#>  $ first: num 1\n#>  $ third: num 3\ni04 <- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n#> List of 2\n#>  $ a: num 1\n#>  $ b: num 2\nx <- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#> List of 2\n#>  $ : num 2\n#>  $ : num 5\nprint(factor(letters), max.levels = 4)\n\nprint(y ~ x, showEnv = TRUE)\nsum(1, 2, NA, na_rm = TRUE)\n#> [1] NA"},{"path":"functions.html","id":"exercises-3","chapter":"1 함수","heading":"1.6.1 Exercises","text":"Explain following results:\n\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1Explain following results:Explain find documentation named arguments \nfollowing function call:\n\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\nExplain find documentation named arguments \nfollowing function call:plot(1:10, col = \"red\") colour points, axes\nlabels? Read source code plot.default() find .plot(1:10, col = \"red\") colour points, axes\nlabels? Read source code plot.default() find .","code":"\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")"},{"path":"functions.html","id":"exiting-a-function","chapter":"1 함수","heading":"1.7 Exiting a function","text":"functions exit one two ways6: either return value, indicating success, throw error, indicating failure. section describes return values (implicit versus explicit; visible versus invisible), briefly discusses errors, introduces exit handlers, allow run code function exits.","code":""},{"path":"functions.html","id":"implicit-versus-explicit-returns","chapter":"1 함수","heading":"1.7.1 Implicit versus explicit returns","text":"\ntwo ways function can return value:Implicitly, last evaluated expression return value:\n\nj01 <- function(x) {\n  (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#> [1] 0\nj01(15)\n#> [1] 10Implicitly, last evaluated expression return value:Explicitly, calling return():\n\nj02 <- function(x) {\n  (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}Explicitly, calling return():","code":"\nj01 <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#> [1] 0\nj01(15)\n#> [1] 10\nj02 <- function(x) {\n  if (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}"},{"path":"functions.html","id":"invisible","chapter":"1 함수","heading":"1.7.2 Invisible values","text":"\nfunctions return visibly: calling function interactive context prints result.However, can prevent automatic printing applying invisible() last value:verify value indeed exist, can explicitly print wrap parentheses:Alternatively, can use withVisible() return value visibility flag:common function returns invisibly <-:makes possible chain assignments:general, function called primarily side effect (like <-, print(), plot()) return invisible value (typically value first argument).","code":"\nj03 <- function() 1\nj03()\n#> [1] 1\nj04 <- function() invisible(1)\nj04()\nprint(j04())\n#> [1] 1\n\n(j04())\n#> [1] 1\nstr(withVisible(j04()))\n#> List of 2\n#>  $ value  : num 1\n#>  $ visible: logi FALSE\na <- 2\n(a <- 2)\n#> [1] 2\na <- b <- c <- d <- 2"},{"path":"functions.html","id":"errors","chapter":"1 함수","heading":"1.7.3 Errors","text":"function complete assigned task, throw error stop(), immediately terminates execution function.error indicates something gone wrong, forces user deal problem. languages (like C, Go, Rust) rely special return values indicate problems, R always throw error. ’ll learn errors, handle , Chapter ??.","code":"\nj05 <- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n#> Error in j05(): I'm an error"},{"path":"functions.html","id":"on-exit","chapter":"1 함수","heading":"1.7.4 Exit handlers","text":"Sometimes function needs make temporary changes global state. cleanup changes can painful (happens ’s error?). ensure changes undone global state restored matter function exits, use .exit() set exit handler. following simple example shows exit handler run regardless whether function exits normally error.Always set add = TRUE using .exit(). don’t, call .exit() overwrite previous exit handler. Even registering single handler, ’s good practice set add = TRUE won’t get unpleasant surprises later add exit handlers..exit() useful allows place clean-code directly next code requires clean-:Coupled lazy evaluation, creates useful pattern running block code altered environment:use force() isn’t strictly necessary simply referring code force evaluation. However, using force() makes clear deliberately forcing execution. ’ll learn uses force() Chapter 4.withr package7 provides collection functions setting temporary state.R 3.4 earlier, .exit() expressions always run order creation:can make cleanup little tricky actions need happen specific order; typically want recent added expression run first. R 3.5 later, can control setting = FALSE:","code":"\nj06 <- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE)\n  \n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n\nj06(TRUE)\n#> Hello\n#> Goodbye!\n#> [1] 10\n\nj06(FALSE)\n#> Hello\n#> Error in j06(FALSE): Error\n#> Goodbye!\ncleanup <- function(dir, code) {\n  old_dir <- setwd(dir)\n  on.exit(setwd(old_dir), add = TRUE)\n  \n  old_opt <- options(stringsAsFactors = FALSE)\n  on.exit(options(old_opt), add = TRUE)\n}\nwith_dir <- function(dir, code) {\n  old <- setwd(dir)\n  on.exit(setwd(old), add = TRUE)\n\n  force(code)\n}\n\ngetwd()\n#> [1] \"/home/sgkim/adv-r\"\nwith_dir(\"~\", getwd())\n#> [1] \"/home/sgkim\"\nj08 <- function() {\n  on.exit(message(\"a\"), add = TRUE)\n  on.exit(message(\"b\"), add = TRUE)\n}\nj08()\n#> a\n#> b\nj09 <- function() {\n  on.exit(message(\"a\"), add = TRUE, after = FALSE)\n  on.exit(message(\"b\"), add = TRUE, after = FALSE)\n}\nj09()\n#> b\n#> a"},{"path":"functions.html","id":"exercises-4","chapter":"1 함수","heading":"1.7.5 Exercises","text":"load() return? don’t normally see values?load() return? don’t normally see values?write.table() return? useful?write.table() return? useful?chdir parameter source() compare with_dir()? \nmight prefer one ?chdir parameter source() compare with_dir()? \nmight prefer one ?Write function opens graphics device, runs supplied code, \ncloses graphics device (always, regardless whether \nplotting code works).Write function opens graphics device, runs supplied code, \ncloses graphics device (always, regardless whether \nplotting code works).can use .exit() implement simple version capture.output().\n\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  .exit(file.remove(temp), add = TRUE, = TRUE)\n\n  sink(temp)\n  .exit(sink(), add = TRUE, = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"\", \"b\", \"c\", sep = \"\\n\"))\n#> [1] \"\" \"b\" \"c\"\nCompare capture.output() capture.output2(). functions\ndiffer? features removed make key ideas easier see?\nrewritten key ideas ’re easier understand?can use .exit() implement simple version capture.output().Compare capture.output() capture.output2(). functions\ndiffer? features removed make key ideas easier see?\nrewritten key ideas ’re easier understand?","code":"\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n#> [1] \"a\" \"b\" \"c\""},{"path":"functions.html","id":"function-forms","chapter":"1 함수","heading":"1.8 Function forms","text":"understand computations R, two slogans helpful:Everything exists object.Everything happens function call.— John ChambersWhile everything happens R result function call, calls look . Function calls come four varieties:prefix: function name comes arguments, like\nfoofy(, b, c). constitute majority function calls R.prefix: function name comes arguments, like\nfoofy(, b, c). constitute majority function calls R.infix: function name comes arguments, like\nx + y. Infix forms used many mathematical operators, \nuser-defined functions begin end %.infix: function name comes arguments, like\nx + y. Infix forms used many mathematical operators, \nuser-defined functions begin end %.replacement: functions replace values assignment, like\nnames(df) <- c(\"\", \"b\", \"c\"). actually look like prefix functions.replacement: functions replace values assignment, like\nnames(df) <- c(\"\", \"b\", \"c\"). actually look like prefix functions.special: functions like [[, , . don’t \nconsistent structure, play important roles R’s syntax.special: functions like [[, , . don’t \nconsistent structure, play important roles R’s syntax.four forms, actually need one call can written prefix form. ’ll demonstrate property, ’ll learn forms turn.","code":""},{"path":"functions.html","id":"prefix-transform","chapter":"1 함수","heading":"1.8.1 Rewriting to prefix form","text":"\n\ninteresting property R every infix, replacement, special form can rewritten prefix form. useful helps better understand structure language, gives real name every function, allows modify functions fun profit.following example shows three pairs equivalent calls, rewriting infix form, replacement form, special form prefix form.Suprisingly, R, can called like regular function! true basically every operation R, means knowing function name non-prefix function allows override behaviour. example, ’re ever feeling particularly evil, run following code friend away computer. introduce fun bug: 10% time, add 1 numeric calculation inside parentheses.course, overriding built-functions like bad idea, , ’ll learn Section ??, ’s possible apply selected code blocks. provides clean elegant approach writing domain specific languages translators languages.useful application comes using functional programming tools. example, use lapply() add 3 every element list first defining function add():can also get result simply relying existing + function:’ll explore idea detail Section 3.","code":"\nx + y\n`+`(x, y)\n\nnames(df) <- c(\"x\", \"y\", \"z\")\n`names<-`(df, c(\"x\", \"y\", \"z\"))\n\nfor(i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n`(` <- function(e1) {\n  if (is.numeric(e1) && runif(1) < 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n#>  [1] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n#> [39] 4 3 4 3 3 3 3 4 3 3 3 3\nrm(\"(\")\nadd <- function(x, y) x + y\nlapply(list(1:3, 4:5), add, 3)\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8\nlapply(list(1:3, 4:5), `+`, 3)\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8"},{"path":"functions.html","id":"prefix-form","chapter":"1 함수","heading":"1.8.2 Prefix form","text":"\nprefix form common form R code, indeed majority programming languages. Prefix calls R little special can specify arguments three ways:position, like help(mean).Using partial matching, like help(top = mean).name, like help(topic = mean).illustrated following chunk, arguments matched exact name, unique prefixes, finally position.general, use positional matching first one two arguments; commonly used, readers know . Avoid using positional matching less commonly used arguments, never use partial matching. Unfortunately can’t disable partial matching, can turn warning warnPartialMatchArgs option:\n","code":"\nk01 <- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(1, 2, 3))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\nstr(k01(2, 3, abcdef = 1))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# But this doesn't work because abbreviation is ambiguous\nstr(k01(1, 3, b = 1))\n#> Error in k01(1, 3, b = 1): argument 3 matches multiple formal arguments\noptions(warnPartialMatchArgs = TRUE)\nx <- k01(a = 1, 2, 3)\n#> Warning in k01(a = 1, 2, 3): partial argument match of 'a' to 'abcdef'"},{"path":"functions.html","id":"infix-functions","chapter":"1 함수","heading":"1.8.3 Infix functions","text":"\n\nInfix functions get name fact function name comes inbetween arguments, hence two arguments. R comes number built-infix operators: :, ::, :::, $, @, ^, *, /, +, -, >, >=, <, <=, ==, !=, !, &, &&, |, ||, ~, <-, <<-. can also create infix functions start end %. Base R uses pattern define %%, %*%, %/%, %%, %o%, %x%.Defining infix function simple. create two argument function bind name starts ends %:names infix functions flexible regular R functions: can contain sequence characters except %. need escape special characters string used define function, call :R’s default precedence rules mean infix operators composed left right:two special infix functions can called single argument: + -.","code":"\n`%+%` <- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n#> [1] \"new string\"\n`% %` <- function(a, b) paste(a, b)\n`%/\\\\%` <- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n#> [1] \"a b\"\n\"a\" %/\\% \"b\"\n#> [1] \"a b\"\n`%-%` <- function(a, b) paste0(\"(\", a, \" %-% \", b, \")\")\n\"a\" %-% \"b\" %-% \"c\"\n#> [1] \"((a %-% b) %-% c)\"\n-1\n#> [1] -1\n+10\n#> [1] 10"},{"path":"functions.html","id":"replacement-functions","chapter":"1 함수","heading":"1.8.4 Replacement functions","text":"\n\nReplacement functions act like modify arguments place, special name xxx<-. must arguments named x value, must return modified object. example, following function modifies second element vector:Replacement functions used placing function call left side <-:say act like modify arguments place, , explained Section ??, actually create modified copy. can see using tracemem():replacement function needs additional arguments, place x value, call replacement function additional arguments left:write modify(x, 1) <- 10, behind scenes R turns :Combining replacement functions requires complex translation. example:translated :(Yes, really create local variable named *tmp*, removed afterwards.)","code":"\n`second<-` <- function(x, value) {\n  x[2] <- value\n  x\n}\nx <- 1:10\nsecond(x) <- 5L\nx\n#>  [1]  1  5  3  4  5  6  7  8  9 10\nx <- 1:10\ntracemem(x)\n#> <0x7ffae71bd880>\n\nsecond(x) <- 6L\n#> tracemem[0x7ffae71bd880 -> 0x7ffae61b5480]: \n#> tracemem[0x7ffae61b5480 -> 0x7ffae73f0408]: second<- \n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\nmodify(x, 1) <- 10\nx\n#>  [1] 10  5  3  4  5  6  7  8  9 10\nx <- `modify<-`(x, 1, 10)\nx <- c(a = 1, b = 2, c = 3)\nnames(x)\n#> [1] \"a\" \"b\" \"c\"\n\nnames(x)[2] <- \"two\"\nnames(x)\n#> [1] \"a\"   \"two\" \"c\"\n`*tmp*` <- x\nx <- `names<-`(`*tmp*`, `[<-`(names(`*tmp*`), 2, \"two\"))\nrm(`*tmp*`)"},{"path":"functions.html","id":"special-forms","chapter":"1 함수","heading":"1.8.5 Special forms","text":"\nFinally, bunch language features usually written special ways, also prefix forms. include parentheses:(x) (`(`(x)){x} (`{`(x)).subsetting operators:x[] (`[`(x, ))x[[]] (`[[`(x, ))tools control flow:(cond) true (``(cond, true))(cond) true else false (``(cond, true, false))(var seq) action (``(var, seq, action))(cond) action (``(cond, action))repeat expr (`repeat`(expr))next (`next`())break (`break`())Finally, complex function function:function(arg1, arg2) {body} (`function`(alist(arg1, arg2), body, env))Knowing name function underlies special form useful getting documentation: ?( syntax error; ?`(` give documentation parentheses.special forms implemented primitive functions (.e. C); means printing functions informative:","code":"\n`for`\n#> .Primitive(\"for\")"},{"path":"functions.html","id":"exercises-5","chapter":"1 함수","heading":"1.8.6 Exercises","text":"Rewrite following code snippets prefix form:\n\n1 + 2 + 3\n\n1 + (2 + 3)\n\n(length(x) <= 5) x[[5]] else x[[n]]Rewrite following code snippets prefix form:Clarify following list odd function calls:\n\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)Clarify following list odd function calls:Explain following code fails:\n\nmodify(get(\"x\"), 1) <- 10\n#> Error: target assignment expands non-language objectExplain following code fails:Create replacement function modifies random location vector.Create replacement function modifies random location vector.Write version + pastes inputs together \ncharacter vectors behaves usual otherwise. words, make \ncode work:\n\n1 + 2\n#> [1] 3\n\n\"\" + \"b\"\n#> [1] \"ab\"Write version + pastes inputs together \ncharacter vectors behaves usual otherwise. words, make \ncode work:Create list replacement functions found base package.\nones primitive functions? (Hint: use apropos().)Create list replacement functions found base package.\nones primitive functions? (Hint: use apropos().)valid names user-created infix functions?valid names user-created infix functions?Create infix xor() operator.Create infix xor() operator.Create infix versions set functions intersect(), union(), \nsetdiff(). might call %n%, %u%, %/% match\nconventions mathematics.Create infix versions set functions intersect(), union(), \nsetdiff(). might call %n%, %u%, %/% match\nconventions mathematics.","code":"\n1 + 2 + 3\n\n1 + (2 + 3)\n\nif (length(x) <= 5) x[[5]] else x[[n]]\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\nmodify(get(\"x\"), 1) <- 10\n#> Error: target of assignment expands to non-language object\n1 + 2\n#> [1] 3\n\n\"a\" + \"b\"\n#> [1] \"ab\""},{"path":"functions.html","id":"function-answers","chapter":"1 함수","heading":"1.9 Quiz answers","text":"three components function body, arguments, environment.three components function body, arguments, environment.f1(1)() returns 11.f1(1)() returns 11.’d normally write infix style: 1 + (2 * 3).’d normally write infix style: 1 + (2 * 3).Rewriting call mean(c(1:10, NA), na.rm = TRUE) easier \nunderstand.Rewriting call mean(c(1:10, NA), na.rm = TRUE) easier \nunderstand., throw error second argument never used\n’s never evaluated., throw error second argument never used\n’s never evaluated.See Sections 1.8.3 1.8.4.See Sections 1.8.3 1.8.4.use .exit(); see Section 1.7.4 details.use .exit(); see Section 1.7.4 details.","code":""},{"path":"environments.html","id":"environments","chapter":"2 Environments","heading":"2 Environments","text":"","code":""},{"path":"environments.html","id":"introduction-1","chapter":"2 Environments","heading":"2.1 Introduction","text":"environment data structure powers scoping. chapter dives deep environments, describing structure depth, using improve understanding four scoping rules described Section 1.4.\nUnderstanding environments necessary day--day use R. important understand power many important R features like lexical scoping, namespaces, R6 classes, interact evaluation give powerful tools making domain specific languages, like dplyr ggplot2.","code":""},{"path":"environments.html","id":"quiz-1","chapter":"2 Environments","heading":"Quiz","text":"can answer following questions correctly, already know important topics chapter. can find answers end chapter Section 2.7.List least three ways environment differs list.List least three ways environment differs list.parent global environment? \nenvironment doesn’t parent?parent global environment? \nenvironment doesn’t parent?enclosing environment function? \nimportant?enclosing environment function? \nimportant?determine environment function called?determine environment function called?<- <<- different?<- <<- different?","code":""},{"path":"environments.html","id":"outline-1","chapter":"2 Environments","heading":"Outline","text":"Section 2.2 introduces basic properties\nenvironment shows create .Section 2.2 introduces basic properties\nenvironment shows create .Section 2.3 provides function template\ncomputing environments, illustrating idea useful\nfunction.Section 2.3 provides function template\ncomputing environments, illustrating idea useful\nfunction.Section 2.4 describes environments used special\npurposes: packages, within functions, namespaces, \nfunction execution.Section 2.4 describes environments used special\npurposes: packages, within functions, namespaces, \nfunction execution.Section 2.5 explains last important environment: \ncaller environment. requires learn call stack,\ndescribes function called. ’ll seen call stack\n’ve ever called traceback() aid debugging.Section 2.5 explains last important environment: \ncaller environment. requires learn call stack,\ndescribes function called. ’ll seen call stack\n’ve ever called traceback() aid debugging.Section 2.6 briefly discusses three places \nenvironments useful data structures solving problems.Section 2.6 briefly discusses three places \nenvironments useful data structures solving problems.","code":""},{"path":"environments.html","id":"prerequisites","chapter":"2 Environments","heading":"Prerequisites","text":"chapter use rlang functions working environments, allows us focus essence environments, rather incidental details.env_ functions rlang designed work pipe: take environment first argument, many also return environment. won’t use pipe chapter interest keeping code simple possible, consider code.","code":"\nlibrary(rlang)"},{"path":"environments.html","id":"env-basics","chapter":"2 Environments","heading":"2.2 Environment basics","text":"Generally, environment similar named list, four important exceptions:Every name must unique.Every name must unique.names environment ordered.names environment ordered.environment parent.environment parent.Environments copied modified.Environments copied modified.Let’s explore ideas code pictures.","code":""},{"path":"environments.html","id":"basics","chapter":"2 Environments","heading":"2.2.1 Basics","text":"\n\n\ncreate environment, use rlang::env(). works like list(), taking set name-value pairs:Use new.env() create new environment. Ignore hash size parameters; needed. simultaneously create define values; use $<-, shown .job environment associate, bind, set names set values. can think environment bag names, implied order (.e. doesn’t make sense ask first element environment). reason, ’ll draw environment :discussed Section ??, environments reference semantics: unlike R objects, modify , modify place, don’t create copy. One important implication environments can contain .Printing environment just displays memory address, terribly useful:Instead, ’ll use env_print() gives us little information:can use env_names() get character vector giving current bindingsIn R 3.2.0 greater, use names() list bindings environment. code needs work R 3.1.0 earlier, use ls(), note ’ll need set .names = TRUE show bindings.","code":"\ne1 <- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\ne1$d <- e1\ne1\n#> <environment: 0x5557dd3a00f0>\nenv_print(e1)\n#> <environment: 0x5557dd3a00f0>\n#> parent: <environment: global>\n#> bindings:\n#>  * a: <lgl>\n#>  * b: <chr>\n#>  * c: <dbl>\n#>  * d: <env>\nenv_names(e1)\n#> [1] \"a\" \"b\" \"c\" \"d\""},{"path":"environments.html","id":"important-environments","chapter":"2 Environments","heading":"2.2.2 Important environments","text":"\n’ll talk detail special environments 2.4, now need mention two. current environment, current_env() environment code currently executing. ’re experimenting interactively, ’s usually global environment, global_env(). global environment sometimes called “workspace,” ’s interactive (.e. outside function) computation takes place.compare environments, need use identical() ==. == vectorised operator, environments vectors.Access global environment globalenv() current environment environment(). global environment printed R_GlobalEnv .GlobalEnv.","code":"\nidentical(global_env(), current_env())\n#> [1] TRUE\n\nglobal_env() == current_env()\n#> Error in global_env() == current_env(): comparison (1) is possible only for atomic and list types"},{"path":"environments.html","id":"parents","chapter":"2 Environments","heading":"2.2.3 Parents","text":"\nEvery environment parent, another environment. diagrams, parent shown small pale blue circle arrow points another environment. parent ’s used implement lexical scoping: name found environment, R look parent (). can set parent environment supplying unnamed argument env(). don’t supply , defaults current environment. code , e2a parent e2b.save space, typically won’t draw ancestors; just remember whenever see pale blue circle, ’s parent environment somewhere.can find parent environment env_parent():one environment doesn’t parent: empty environment. draw empty environment hollow parent environment, space allows ’ll label R_EmptyEnv, name R uses.ancestors every environment eventually terminate empty environment. can see ancestors env_parents():default, env_parents() stops gets global environment. useful ancestors global environment include every attached package, can see override default behaviour . ’ll come back environments Section 2.4.1.Use parent.env() find parent environment. base function returns ancestors.","code":"\ne2a <- env(d = 4, e = 5)\ne2b <- env(e2a, a = 1, b = 2, c = 3)\nenv_parent(e2b)\n#> <environment: 0x5557dba29770>\nenv_parent(e2a)\n#> <environment: R_GlobalEnv>\ne2c <- env(empty_env(), d = 4, e = 5)\ne2d <- env(e2c, a = 1, b = 2, c = 3)\nenv_parents(e2b)\n#> [[1]]   <env: 0x5557dba29770>\n#> [[2]] $ <env: global>\nenv_parents(e2d)\n#> [[1]]   <env: 0x5557dc7dd3f8>\n#> [[2]] $ <env: empty>\nenv_parents(e2b, last = empty_env())\n#>  [[1]]   <env: 0x5557dba29770>\n#>  [[2]] $ <env: global>\n#>  [[3]] $ <env: package:rlang>\n#>  [[4]] $ <env: package:stats>\n#>  [[5]] $ <env: package:graphics>\n#>  [[6]] $ <env: package:grDevices>\n#>  [[7]] $ <env: package:utils>\n#>  [[8]] $ <env: package:datasets>\n#>  [[9]] $ <env: package:methods>\n#> [[10]] $ <env: Autoloads>\n#> [[11]] $ <env: package:base>\n#> [[12]] $ <env: empty>"},{"path":"environments.html","id":"super-assignment--","chapter":"2 Environments","heading":"2.2.4 Super assignment, <<-","text":"\nancestors environment important relationship <<-. Regular assignment, <-, always creates variable current environment. Super assignment, <<-, never creates variable current environment, instead modifies existing variable found parent environment.<<- doesn’t find existing variable, create one global environment. usually undesirable, global variables introduce non-obvious dependencies functions. <<- often used conjunction function factory, described Section 4.2.4.","code":"\nx <- 0\nf <- function() {\n  x <<- 1\n}\nf()\nx\n#> [1] 1"},{"path":"environments.html","id":"getting-and-setting","chapter":"2 Environments","heading":"2.2.5 Getting and setting","text":"\ncan get set elements environment $ [[ way list:can’t use [[ numeric indices, can’t use [:$ [[ return NULL binding doesn’t exist. Use env_get() want error:want use default value binding doesn’t exist, can use default argument.two ways add bindings environment:env_poke()8 takes name (string) value:\n\nenv_poke(e3, \"\", 100)\ne3$\n#> [1] 100env_poke()8 takes name (string) value:env_bind() allows bind multiple values:\n\nenv_bind(e3, = 10, b = 20)\nenv_names(e3)\n#> [1] \"x\" \"y\" \"z\" \"\" \"b\"env_bind() allows bind multiple values:can determine environment binding env_has():Unlike lists, setting element NULL remove , sometimes want name refers NULL. Instead, use env_unbind():Unbinding name doesn’t delete object. ’s job garbage collector, automatically removes objects names binding . process described detail Section ??.\nSee get(), assign(), exists(), rm(). designed interactively use current environment, working environments little clunky. Also beware inherits argument: defaults TRUE meaning base equivalents inspect supplied environment ancestors.","code":"\ne3 <- env(x = 1, y = 2)\ne3$x\n#> [1] 1\ne3$z <- 3\ne3[[\"z\"]]\n#> [1] 3\ne3[[1]]\n#> Error in e3[[1]]: wrong arguments for subsetting an environment\n\ne3[c(\"x\", \"y\")]\n#> Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\ne3$xyz\n#> NULL\n\nenv_get(e3, \"xyz\")\n#> Error in env_get(e3, \"xyz\"): argument \"default\" is missing, with no default\nenv_get(e3, \"xyz\", default = NA)\n#> [1] NA\nenv_poke(e3, \"a\", 100)\ne3$a\n#> [1] 100\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n#> [1] \"x\" \"y\" \"z\" \"a\" \"b\"\nenv_has(e3, \"a\")\n#>    a \n#> TRUE\ne3$a <- NULL\nenv_has(e3, \"a\")\n#>    a \n#> TRUE\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n#>     a \n#> FALSE"},{"path":"environments.html","id":"advanced-bindings","chapter":"2 Environments","heading":"2.2.6 Advanced bindings","text":"\n\n\n\ntwo exotic variants env_bind():env_bind_lazy() creates delayed bindings, evaluated \nfirst time accessed. Behind scenes, delayed bindings create\npromises, behave way function arguments.\n\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       1\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>   0.001   0.000   0.000\nprimary use delayed bindings autoload(), \nallows R packages provide datasets behave like loaded \nmemory, even though ’re loaded disk needed.env_bind_lazy() creates delayed bindings, evaluated \nfirst time accessed. Behind scenes, delayed bindings create\npromises, behave way function arguments.primary use delayed bindings autoload(), \nallows R packages provide datasets behave like loaded \nmemory, even though ’re loaded disk needed.env_bind_active() creates active bindings re-computed every\ntime ’re accessed:\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#> [1] 0.0808\nz1\n#> [1] 0.834\nActive bindings used implement R6’s active fields, ’ll learn\nSection ??.env_bind_active() creates active bindings re-computed every\ntime ’re accessed:Active bindings used implement R6’s active fields, ’ll learn\nSection ??.See ?delayedAssign() ?makeActiveBinding().","code":"\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       1\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>   0.001   0.000   0.000\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#> [1] 0.0808\nz1\n#> [1] 0.834"},{"path":"environments.html","id":"exercises-6","chapter":"2 Environments","heading":"2.2.7 Exercises","text":"List three ways environment differs list.List three ways environment differs list.Create environment illustrated picture.\nCreate environment illustrated picture.Create pair environments illustrated picture.\nCreate pair environments illustrated picture.Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e \nenvironment.Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e \nenvironment.Create version env_poke() bind new names, never\nre-bind old names. programming languages , known\nsingle assignment languages.Create version env_poke() bind new names, never\nre-bind old names. programming languages , known\nsingle assignment languages.function ? differ <<- \nmight prefer ?\n\nrebind <- function(name, value, env = caller_env()) {\n  (identical(env, empty_env())) {\n    stop(\"find `\", name, \"`\", call. = FALSE)\n  } else (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"\", 10)\n#> Error: find ``\n<- 5\nrebind(\"\", 10)\n\n#> [1] 10What function ? differ <<- \nmight prefer ?","code":"\nrebind <- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"a\", 10)\n#> Error: Can't find `a`\na <- 5\nrebind(\"a\", 10)\na\n#> [1] 10"},{"path":"environments.html","id":"env-recursion","chapter":"2 Environments","heading":"2.3 Recursing over environments","text":"want operate every ancestor environment, ’s often convenient write recursive function. section shows , applying new knowledge environments write function given name, finds environment () name defined, using R’s regular scoping rules.definition () straightforward. two arguments: name look (string), environment start search. (’ll learn caller_env() good default Section 2.5.)three cases:base case: ’ve reached empty environment haven’t found \nbinding. can’t go , throw error.base case: ’ve reached empty environment haven’t found \nbinding. can’t go , throw error.successful case: name exists environment, return \nenvironment.successful case: name exists environment, return \nenvironment.recursive case: name found environment, try \nparent.recursive case: name found environment, try \nparent.three cases illustrated three examples:might help see picture. Imagine two environments, following code diagram:(\"\", e4b) find e4b.(\"\", e4b) find e4b.(\"b\", e4b) doesn’t find b e4b, looks parent, e4a,\nfinds .(\"b\", e4b) doesn’t find b e4b, looks parent, e4a,\nfinds .(\"c\", e4b) looks e4b, e4a, hits empty environment\nthrows error.(\"c\", e4b) looks e4b, e4a, hits empty environment\nthrows error.’s natural work environments recursively, () provides useful template. Removing specifics () shows structure clearly:","code":"\nwhere <- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\nwhere(\"yyy\")\n#> Error: Can't find yyy\n\nx <- 5\nwhere(\"x\")\n#> <environment: R_GlobalEnv>\n\nwhere(\"mean\")\n#> <environment: base>\ne4a <- env(empty_env(), a = 1, b = 2)\ne4b <- env(e4a, x = 10, a = 11)\nf <- function(..., env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # base case\n  } else if (success) {\n    # success case\n  } else {\n    # recursive case\n    f(..., env = env_parent(env))\n  }\n}"},{"path":"environments.html","id":"iteration-versus-recursion","chapter":"2 Environments","heading":"Iteration versus recursion","text":"’s possible use loop instead recursion. think ’s harder understand recursive version, include might find easier see ’s happening haven’t written many recursive functions.","code":"\nf2 <- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env <- env_parent(env)\n  }\n\n  # base case\n}"},{"path":"environments.html","id":"exercises-7","chapter":"2 Environments","heading":"2.3.1 Exercises","text":"Modify () return environments contain binding \nname. Carefully think type object function \nneed return.Modify () return environments contain binding \nname. Carefully think type object function \nneed return.Write function called fget() finds function objects. \ntwo arguments, name env, obey regular\nscoping rules functions: ’s object matching name\n’s function, look parent. added challenge, also\nadd inherits argument controls whether function recurses \nparents looks one environment.Write function called fget() finds function objects. \ntwo arguments, name env, obey regular\nscoping rules functions: ’s object matching name\n’s function, look parent. added challenge, also\nadd inherits argument controls whether function recurses \nparents looks one environment.","code":""},{"path":"environments.html","id":"special-environments","chapter":"2 Environments","heading":"2.4 Special environments","text":"environments created (e.g. env()) instead created R. section, ’ll learn important environments, starting package environments. ’ll learn function environment bound function created, (usually) ephemeral execution environment created every time function called. Finally, ’ll see package function environments interact support namespaces, ensure package always behaves way, regardless packages user loaded.","code":""},{"path":"environments.html","id":"search-path","chapter":"2 Environments","heading":"2.4.1 Package environments and the search path","text":"\n\npackage attached library() require() becomes one parents global environment. immediate parent global environment last package attached9, parent package second last package attached, …follow parents back, see order every package attached. known search path objects environments can found top-level interactive workspace. can see names environments base::search(), environments rlang::search_envs():last two environments search path always :Autoloads environment uses delayed bindings save memory \nloading package objects (like big datasets) needed.Autoloads environment uses delayed bindings save memory \nloading package objects (like big datasets) needed.base environment, package:base sometimes just base, \nenvironment base package. special able\nbootstrap loading packages. can access directly\nbase_env().base environment, package:base sometimes just base, \nenvironment base package. special able\nbootstrap loading packages. can access directly\nbase_env().Note attach another package library(), parent environment global environment changes:","code":"\nsearch()\n#>  [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n#>  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n#>  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n#> [10] \"package:base\"\n\nsearch_envs()\n#>  [[1]] $ <env: global>\n#>  [[2]] $ <env: package:rlang>\n#>  [[3]] $ <env: package:stats>\n#>  [[4]] $ <env: package:graphics>\n#>  [[5]] $ <env: package:grDevices>\n#>  [[6]] $ <env: package:utils>\n#>  [[7]] $ <env: package:datasets>\n#>  [[8]] $ <env: package:methods>\n#>  [[9]] $ <env: Autoloads>\n#> [[10]] $ <env: package:base>"},{"path":"environments.html","id":"function-environments","chapter":"2 Environments","heading":"2.4.2 The function environment","text":"\nfunction binds current environment created. called function environment, used lexical scoping. Across computer languages, functions capture (enclose) environments called closures, term often used interchangeably function R’s documentation.can get function environment fn_env():Use environment(f) access environment function f.diagrams, ’ll draw function rectangle rounded end binds environment.case, f() binds environment binds name f function. ’s always case: following example g bound new environment e, g() binds global environment. distinction binding bound subtle important; difference find g versus g finds variables.","code":"\ny <- 1\nf <- function(x) x + y\nfn_env(f)\n#> <environment: R_GlobalEnv>\ne <- env()\ne$g <- function() 1"},{"path":"environments.html","id":"namespaces","chapter":"2 Environments","heading":"2.4.3 Namespaces","text":"diagram , saw parent environment package varies based packages loaded. seems worrying: doesn’t mean package find different functions packages loaded different order? goal namespaces make sure happen, every package works way regardless packages attached user.example, take sd():sd() defined terms var(), might worry result sd() affected function called var() either global environment, one attached packages. R avoids problem taking advantage function versus binding environment described . Every function package associated pair environments: package environment, learned earlier, namespace environment.package environment external interface package. ’s \n, R user, find function attached package ::. \nparent determined search path, .e. order packages \nattached.package environment external interface package. ’s \n, R user, find function attached package ::. \nparent determined search path, .e. order packages \nattached.namespace environment internal interface package. \npackage environment controls find function; namespace\ncontrols function finds variables.namespace environment internal interface package. \npackage environment controls find function; namespace\ncontrols function finds variables.Every binding package environment also found namespace environment; ensures every function can use every function package. bindings occur namespace environment. known internal non-exported objects, make possible hide internal implementation details user.Every namespace environment set ancestors:namespace imports environment contains bindings \nfunctions used package. imports environment controlled \npackage developer NAMESPACE file.namespace imports environment contains bindings \nfunctions used package. imports environment controlled \npackage developer NAMESPACE file.Explicitly importing every base function tiresome, parent\nimports environment base namespace. base namespace\ncontains bindings base environment, different\nparent.Explicitly importing every base function tiresome, parent\nimports environment base namespace. base namespace\ncontains bindings base environment, different\nparent.parent base namespace global environment. means \nbinding isn’t defined imports environment package look\nusual way. usually bad idea (makes code\ndepend loaded packages), R CMD check automatically warns \ncode. needed primarily historical reasons, particularly due\nS3 method dispatch works.parent base namespace global environment. means \nbinding isn’t defined imports environment package look\nusual way. usually bad idea (makes code\ndepend loaded packages), R CMD check automatically warns \ncode. needed primarily historical reasons, particularly due\nS3 method dispatch works.Putting diagrams together get:sd() looks value var always finds sequence environments determined package developer, package user. ensures package code always works way regardless packages attached user.’s direct link package namespace environments; link defined function environments.","code":"\nsd\n#> function (x, na.rm = FALSE) \n#> sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#>     na.rm = na.rm))\n#> <bytecode: 0x5557d9a9a2e8>\n#> <environment: namespace:stats>"},{"path":"environments.html","id":"execution-environments","chapter":"2 Environments","heading":"2.4.4 Execution environments","text":"\nlast important topic need cover execution environment. following function return first time ’s run? second?Think moment read .function returns value every time fresh start principle, described Section 1.4.3. time function called, new environment created host execution. called execution environment, parent function environment. Let’s illustrate process simpler function. Figure 2.1 illustrates graphical conventions: draw execution environments indirect parent; parent environment found via function environment.\nFigure 2.1: execution environment simple function call. Note parent execution environment function environment.\nexecution environment usually ephemeral; function completed, environment garbage collected. several ways make stay around longer. first explicitly return :Another way capture return object binding environment, like function. following example illustrates idea function factory, plus(). use factory create function called plus_one().’s lot going diagram enclosing environment plus_one() execution environment plus().happens call plus_one()? execution environment captured execution environment plus() parent:’ll learn function factories Section 4.2.","code":"\ng <- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\ng(10)\n#> Defining a\n#> [1] 1\ng(10)\n#> Defining a\n#> [1] 1\nh <- function(x) {\n  # 1.\n  a <- 2 # 2.\n  x + a\n}\ny <- h(1) # 3.\nh2 <- function(x) {\n  a <- x * 2\n  current_env()\n}\n\ne <- h2(x = 10)\nenv_print(e)\n#> <environment: 0x5557ddeaa338>\n#> parent: <environment: global>\n#> bindings:\n#>  * a: <dbl>\n#>  * x: <dbl>\nfn_env(h2)\n#> <environment: R_GlobalEnv>\nplus <- function(x) {\n  function(y) x + y\n}\n\nplus_one <- plus(1)\nplus_one\n#> function(y) x + y\n#> <environment: 0x5557dcaf7218>\nplus_one(2)\n#> [1] 3"},{"path":"environments.html","id":"exercises-8","chapter":"2 Environments","heading":"2.4.5 Exercises","text":"search_envs() different env_parents(global_env())?search_envs() different env_parents(global_env())?Draw diagram shows enclosing environments function:\n\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)Draw diagram shows enclosing environments function:Write enhanced version str() provides information\nfunctions. Show function found environment\ndefined .Write enhanced version str() provides information\nfunctions. Show function found environment\ndefined .","code":"\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)"},{"path":"environments.html","id":"call-stack","chapter":"2 Environments","heading":"2.5 Call stacks","text":"\n\none last environment need explain, caller environment, accessed rlang::caller_env(). provides environment function called, hence varies based function called, function created. saw useful default whenever write function takes environment argument.parent.frame() equivalent caller_env(); just note returns environment, frame.fully understand caller environment need discuss two related concepts: call stack, made frames. Executing function creates two types context. ’ve learned one already: execution environment child function environment, determined function created. ’s another type context created function called: called call stack.","code":""},{"path":"environments.html","id":"simple-stack","chapter":"2 Environments","heading":"2.5.1 Simple call stacks","text":"Let’s illustrate simple sequence calls: f() calls g() calls h().way commonly see call stack R looking traceback() error occurred:Instead stop() + traceback() understand call stack, ’re going use lobstr::cst() print call stack tree:shows us cst() called h(), called g(), called f(). Note order opposite traceback(). call stacks get complicated, think ’s easier understand sequence calls start beginning, rather end (.e. f() calls g(); rather g() called f()).","code":"\nf <- function(x) {\n  g(x = 2)\n}\ng <- function(x) {\n  h(x = 3)\n}\nh <- function(x) {\n  stop()\n}\nf(x = 1)\n#> Error:\ntraceback()\n#> 4: stop()\n#> 3: h(x = 3) \n#> 2: g(x = 2)\n#> 1: f(x = 1)\nh <- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n#> █\n#> └─f(x = 1)\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()"},{"path":"environments.html","id":"lazy-call-stack","chapter":"2 Environments","heading":"2.5.2 Lazy evaluation","text":"call stack simple: get hint ’s tree-like structure involved, everything happens single branch. typical call stack arguments eagerly evaluated.Let’s create complicated example involves lazy evaluation. ’ll create sequence functions, (), b(), c(), pass along argument x.x lazily evaluated tree gets two branches. first branch () calls b(), b() calls c(). second branch starts c() evaluates argument x. argument evaluated new branch environment evaluated global environment, environment c().","code":"\na <- function(x) b(x)\nb <- function(x) c(x)\nc <- function(x) x\n\na(f())\n#> █\n#> ├─a(f())\n#> │ └─b(x)\n#> │   └─c(x)\n#> └─f()\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()"},{"path":"environments.html","id":"frames","chapter":"2 Environments","heading":"2.5.3 Frames","text":"\nelement call stack frame10, also known evaluation context. frame extremely important internal data structure, R code can access small part data structure tampering break R. frame three key components:expression (labelled expr) giving function call. \ntraceback() prints .expression (labelled expr) giving function call. \ntraceback() prints .environment (labelled env), typically execution\nenvironment function. two main exceptions: environment \nglobal frame global environment, calling eval() also\ngenerates frames, environment can anything.environment (labelled env), typically execution\nenvironment function. two main exceptions: environment \nglobal frame global environment, calling eval() also\ngenerates frames, environment can anything.parent, previous call call stack (shown grey arrow).parent, previous call call stack (shown grey arrow).Figure 2.2 illustrates stack call f(x = 1) shown Section 2.5.1.\nFigure 2.2: graphical depiction simple call stack\n(focus calling environments, omitted bindings global environment f, g, h respective function objects.)frame also holds exit handlers created .exit(), restarts handlers condition system, context return() function completes. important internal details accessible R code.","code":""},{"path":"environments.html","id":"dynamic-scope","chapter":"2 Environments","heading":"2.5.4 Dynamic scope","text":"Looking variables calling stack rather enclosing environment called dynamic scoping. languages implement dynamic scoping (Emacs Lisp notable exception.) dynamic scoping makes much harder reason function operates: need know defined, also need know context called. Dynamic scoping primarily useful developing functions aid interactive data analysis, one topics discussed Chapter ??.","code":""},{"path":"environments.html","id":"exercises-9","chapter":"2 Environments","heading":"2.5.5 Exercises","text":"Write function lists variables defined environment\ncalled. return results ls().","code":""},{"path":"environments.html","id":"explicit-envs","chapter":"2 Environments","heading":"2.6 As data structures","text":"\nwell powering scoping, environments also useful data structures right reference semantics. three common problems can help solve:Avoiding copies large data. Since environments reference\nsemantics, ’ll never accidentally create copy. bare environments\npainful work , instead recommend using R6 objects, \nbuilt top environments. Learn Chapter ??.Avoiding copies large data. Since environments reference\nsemantics, ’ll never accidentally create copy. bare environments\npainful work , instead recommend using R6 objects, \nbuilt top environments. Learn Chapter ??.Managing state within package. Explicit environments useful \npackages allow maintain state across function calls.\nNormally, objects package locked, can’t modify \ndirectly. Instead, can something like :\n\nmy_env <- new.env(parent = emptyenv())\nmy_env$<- 1\n\nget_a <- function() {\n  my_env$\n}\nset_a <- function(value) {\n  old <- my_env$\n  my_env$<- value\n  invisible(old)\n}\nReturning old value setter functions good pattern \nmakes easier reset previous value conjunction \n.exit() (Section 1.7.4).Managing state within package. Explicit environments useful \npackages allow maintain state across function calls.\nNormally, objects package locked, can’t modify \ndirectly. Instead, can something like :Returning old value setter functions good pattern \nmakes easier reset previous value conjunction \n.exit() (Section 1.7.4).hashmap. hashmap data structure takes constant, O(1),\ntime find object based name. Environments provide \nbehaviour default, can used simulate hashmap. See \nhash package11 complete development idea.hashmap. hashmap data structure takes constant, O(1),\ntime find object based name. Environments provide \nbehaviour default, can used simulate hashmap. See \nhash package11 complete development idea.","code":"\nmy_env <- new.env(parent = emptyenv())\nmy_env$a <- 1\n\nget_a <- function() {\n  my_env$a\n}\nset_a <- function(value) {\n  old <- my_env$a\n  my_env$a <- value\n  invisible(old)\n}"},{"path":"environments.html","id":"env-answers","chapter":"2 Environments","heading":"2.7 Quiz answers","text":"four ways: every object environment must name;\norder doesn’t matter; environments parents; environments \nreference semantics.four ways: every object environment must name;\norder doesn’t matter; environments parents; environments \nreference semantics.parent global environment last package \nloaded. environment doesn’t parent empty\nenvironment.parent global environment last package \nloaded. environment doesn’t parent empty\nenvironment.enclosing environment function environment \ncreated. determines function looks variables.enclosing environment function environment \ncreated. determines function looks variables.Use caller_env() parent.frame().Use caller_env() parent.frame().<- always creates binding current environment; <<-\nrebinds existing name parent current environment.<- always creates binding current environment; <<-\nrebinds existing name parent current environment.","code":""},{"path":"fp.html","id":"fp","chapter":"Introduction","heading":"Introduction","text":"R, heart, functional language. means certain technical properties, importantly lends style problem solving centred functions. ’ll give brief overview technical definition functional language, book primarily focus functional style programming, think extremely good fit types problem commonly encounter data analysis.Recently, functional techniques experienced surge interest can produce efficient elegant solutions many modern problems. functional style tends create functions can easily analysed isolation (.e. using local information), hence often much easier automatically optimise parallelise. traditional weaknesses functional languages, poorer performance sometimes unpredictable memory usage, much reduced recent years. Functional programming complementary object-oriented programming, dominant programming paradigm last several decades.","code":""},{"path":"fp.html","id":"functional-programming-languages","chapter":"Introduction","heading":"Functional programming languages","text":"Every programming language functions, makes programming language functional? many definitions precisely makes language functional, two common threads.Firstly, functional languages first-class functions, functions behave like data structure. R, means can many things function can vector: can assign variables, store lists, pass arguments functions, create inside functions, even return result function.Secondly, many functional languages require functions pure. function pure satisfies two properties:output depends inputs, .e. call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.output depends inputs, .e. call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.Pure functions much easier reason , obviously significant downsides: imagine data analysis couldn’t generate random numbers read files disk.Strictly speaking, R isn’t functional programming language doesn’t require write pure functions. However, can certainly adopt functional style parts code: don’t write pure functions, often . experience, partitioning code functions either extremely pure extremely impure tends lead code easier understand extends new situations.","code":""},{"path":"fp.html","id":"functional-style","chapter":"Introduction","heading":"Functional style","text":"’s hard describe exactly functional style , generally think means decomposing big problem smaller pieces, solving piece function combination functions. using functional style, strive decompose components problem isolated functions operate independently. function taken simple straightforward understand; complexity handled composing functions various ways.following three chapters discuss three key functional techniques help decompose problems smaller pieces:Chapter 3 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n’ll use time data analysis.Chapter 3 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n’ll use time data analysis.Chapter 4 introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter 4 introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter 5 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Chapter 5 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Collectively, types function called higher-order functions fill two--two table:","code":""},{"path":"functionals.html","id":"functionals","chapter":"3 Functionals","heading":"3 Functionals","text":"","code":""},{"path":"functionals.html","id":"introduction-2","chapter":"3 Functionals","heading":"3.1 Introduction","text":"become significantly reliable, code must become transparent.\nparticular, nested conditions loops must viewed great\nsuspicion. Complicated control flows confuse programmers. Messy code often\nhides bugs.— Bjarne StroustrupA functional function takes function input returns vector output. ’s simple functional: calls function provided input 1000 random uniform numbers.chances ’ve already used functional. might used -loop replacements like base R’s lapply(), apply(), tapply(); purrr’s map(); maybe ’ve used mathematical functional like integrate() optim().\ncommon use functionals alternative loops. loops bad rap R many people believe slow12, real downside loops ’re flexible: loop conveys ’re iterating, done results. Just ’s better use repeat, ’s better use (Section ??), ’s better use functional . functional tailored specific task, recognise functional immediately know ’s used.’re experienced loop user, switching functionals typically pattern matching exercise. look loop find functional matches basic form. one doesn’t exist, don’t try torture existing functional fit form need. Instead, just leave loop! (’ve repeated loop two times, maybe think writing functional).","code":"\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n#> [1] 0.506\nrandomise(mean)\n#> [1] 0.501\nrandomise(sum)\n#> [1] 489"},{"path":"functionals.html","id":"outline-2","chapter":"3 Functionals","heading":"Outline","text":"Section 3.2 introduces first functional: purrr::map().Section 3.2 introduces first functional: purrr::map().Section 3.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 3.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 3.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 3.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 3.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 3.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 3.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 3.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 3.7 reviews functionals base R \nmembers map, reduce, predicate families.Section 3.7 reviews functionals base R \nmembers map, reduce, predicate families.","code":""},{"path":"functionals.html","id":"prerequisites-1","chapter":"3 Functionals","heading":"Prerequisites","text":"chapter focus functionals provided purrr package.13 functions consistent interface makes easier understand key ideas base equivalents, grown organically many years. ’ll compare contrast base R functions go, wrap chapter discussion base functionals don’t purrr equivalents.","code":"\nlibrary(purrr)"},{"path":"functionals.html","id":"map","chapter":"3 Functionals","heading":"3.2 My first functional: map()","text":"fundamental functional purrr::map()14. takes vector function, calls function element vector, returns results list. words, map(1:3, f) equivalent list(f(1), f(2), f(3))., graphically:might wonder function called map(). depicting physical features land sea 🗺? fact, meaning comes mathematics map refers “operation associates element given set one elements second set.” makes sense map() defines mapping one vector another. (“Map” also nice property short, useful fundamental building block.)implementation map() quite simple. allocate list length input, fill list loop. heart implementation handful lines code:real purrr::map() function differences: written C eke every last iota performance, preserves names, supports shortcuts ’ll learn Section 3.2.2.base equivalent map() lapply(). difference lapply() support helpers ’ll learn , ’re using map() purrr, can skip additional dependency use lapply() directly.","code":"\ntriple <- function(x) x * 3\nmap(1:3, triple)\n#> [[1]]\n#> [1] 3\n#> \n#> [[2]]\n#> [1] 6\n#> \n#> [[3]]\n#> [1] 9\nsimple_map <- function(x, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"map-atomic","chapter":"3 Functionals","heading":"3.2.1 Producing atomic vectors","text":"map() returns list, makes general map family can put anything list. inconvenient return list simpler data structure , four specific variants: map_lgl(), map_int(), map_dbl(), map_chr(). returns atomic vector specified type:purrr uses convention suffixes, like _dbl(), refer output. map_*() functions can take type vector input. examples rely two facts: mtcars data frame, data frames lists containing vectors length. obvious draw data frame orientation vector:map functions always return output vector length input, implies call .f must return single value. , ’ll get error:similar error ’ll get .f returns wrong type result:either case, ’s often useful switch back map(), map() can accept type output. allows see problematic output, figure .Base R two apply functions can return atomic vectors: sapply() vapply(). recommend avoid sapply() tries simplify result, can return list, vector, matrix. makes difficult program , avoided non-interactive settings. vapply() safer allows provide template, FUN.VALUE, describes output shape. don’t want use purrr, recommend always use vapply() functions, sapply(). primary downside vapply() verbosity: example, equivalent map_dbl(x, mean, na.rm = TRUE) vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1)).","code":"\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n#>      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#> \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#>       am     gear     carb \n#> \"double\" \"double\" \"double\"\n\n# map_lgl() always returns a logical vector\nmap_lgl(mtcars, is.double)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#> TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() always returns a integer vector\nn_unique <- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n#>     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#>  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 \n#>    carb \n#>   2.812\npair <- function(x) c(x, x)\nmap_dbl(1:2, pair)\n#> Error: Result 1 must be a single double, not an integer vector of length 2\nmap_dbl(1:2, as.character)\n#> Error: Can't coerce element 1 from a character to a double\nmap(1:2, pair)\n#> [[1]]\n#> [1] 1 1\n#> \n#> [[2]]\n#> [1] 2 2\nmap(1:2, as.character)\n#> [[1]]\n#> [1] \"1\"\n#> \n#> [[2]]\n#> [1] \"2\""},{"path":"functionals.html","id":"purrr-shortcuts","chapter":"3 Functionals","heading":"3.2.2 Anonymous functions and shortcuts","text":"\nInstead using map() existing function, can create inline anonymous function (mentioned Section 1.2.3):Anonymous functions useful, syntax verbose. purrr supports special shortcut:works purrr functions translate formulas, created ~ (pronounced “twiddle”), functions. can see ’s happening behind scenes calling as_mapper():function arguments look little quirky allow refer . one argument functions, .x .y two argument functions, ..1, ..2, ..3, etc, functions arbitrary number arguments. . remains backward compatibility don’t recommend using ’s easily confused . used magrittr’s pipe.shortcut particularly useful generating random data:Reserve syntax short simple functions. good rule thumb function spans lines uses {}, ’s time give name.map functions also shortcuts extracting elements vector, powered purrr::pluck(). can use character vector select elements name, integer vector select position, list select name position. useful working deeply nested lists, often arise working JSON.base R functions, like lapply(), can provide name function string. isn’t tremendously useful lapply(x, \"f\") almost always equivalent lapply(x, f) typing.","code":"\nmap_dbl(mtcars, function(x) length(unique(x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nmap_dbl(mtcars, ~ length(unique(.x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nas_mapper(~ length(unique(.x)))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(unique(.x))\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\nx <- map(1:3, ~ runif(2))\nstr(x)\n#> List of 3\n#>  $ : num [1:2] 0.281 0.53\n#>  $ : num [1:2] 0.433 0.917\n#>  $ : num [1:2] 0.0275 0.8249\nx <- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n#> [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n#> [1] -1 -2 -3\n\n# Or by both\nmap_dbl(x, list(\"y\", 1))\n#> [1] 2 5 9\n\n# You'll get an error if a component doesn't exist:\nmap_chr(x, \"z\")\n#> Error: Result 3 must be a single string, not NULL of length 0\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n#> [1] \"a\" \"b\" NA"},{"path":"functionals.html","id":"passing-arguments","chapter":"3 Functionals","heading":"3.2.3 Passing arguments with ...","text":"’s often convenient pass along additional arguments function ’re calling. example, might want pass na.rm = TRUE along mean(). One way anonymous function:map functions pass ... along, ’s simpler form available:easiest understand picture: arguments come f call map() inserted data individual calls f():’s important note arguments decomposed; said another way, map() vectorised first argument. argument f vector, passed along :(’ll learn map variants vectorised multiple arguments Sections 3.4.2 3.4.5.)Note ’s subtle difference placing extra arguments inside anonymous function compared passing map(). Putting anonymous function means evaluated every time f() executed, just call map(). easiest see make additional argument random:","code":"\nx <- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n#> [1] 3.0 5.5\nmap_dbl(x, mean, na.rm = TRUE)\n#> [1] 3.0 5.5\nplus <- function(x, y) x + y\n\nx <- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n#> [1] 0.0625 0.0625 0.0625 0.0625\nmap_dbl(x, ~ plus(.x, runif(1)))\n#> [1] 0.903 0.132 0.629 0.945"},{"path":"functionals.html","id":"argument-names","chapter":"3 Functionals","heading":"3.2.4 Argument names","text":"diagrams, ’ve omitted argument names focus overall structure. recommend writing full names code, makes easier read. map(x, mean, 0.1) perfectly valid code, call mean(x[[1]], 0.1) relies reader remembering second argument mean() trim. avoid unnecessary burden brain reader15, kind write map(x, mean, trim = 0.1).reason arguments map() little odd: instead x f, .x .f. ’s easiest see problem leads names using simple_map() defined . simple_map() arguments x f ’ll problems whenever function calling arguments x f:error little bewildering remember call simple_map() equivalent simple_map(x = mtcars, f = mean, bootstrap_summary) named matching beats positional matching.purrr functions reduce likelihood clash using .f .x instead common f x. course technique isn’t perfect (function calling might still use .f .x), avoids 99% issues. remaining 1% time, use anonymous function.Base functions pass along ... use variety naming conventions prevent undesired argument matching:apply family mostly uses capital letters (e.g. X FUN).apply family mostly uses capital letters (e.g. X FUN).transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection ??. makes undesired matches extremely\nunlikely.transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection ??. makes undesired matches extremely\nunlikely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.","code":"\nboostrap_summary <- function(x, f) {\n  f(sample(x, replace = TRUE))\n}\n\nsimple_map(mtcars, boostrap_summary, f = mean)\n#> Error in mean.default(x[[i]], ...): 'trim' must be numeric of length one"},{"path":"functionals.html","id":"change-argument","chapter":"3 Functionals","heading":"3.2.5 Varying another argument","text":"far first argument map() always become first argument function. happens first argument constant, want vary different argument? get result picture?turns ’s way directly, two tricks can use instead. illustrate , imagine vector contains unusual values, want explore effect different amounts trimming computing mean. case, first argument mean() constant, want vary second argument, trim.simplest technique use anonymous function rearrange \nargument order:\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nstill little confusing ’m using x .x.\ncan make little clearer abandoning ~ helper:\n\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502The simplest technique use anonymous function rearrange \nargument order:still little confusing ’m using x .x.\ncan make little clearer abandoning ~ helper:Sometimes, want () clever, can take advantage R’s\nflexible argument matching rules (described Section\n1.8.2). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :\n\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502\ndon’t recommend technique relies reader’s familiarity argument order .f, R’s\nargument matching rules.Sometimes, want () clever, can take advantage R’s\nflexible argument matching rules (described Section\n1.8.2). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :don’t recommend technique relies reader’s familiarity argument order .f, R’s\nargument matching rules.’ll see one alternative Section 3.4.5.","code":"\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502"},{"path":"functionals.html","id":"exercises-10","chapter":"3 Functionals","heading":"3.2.6 Exercises","text":"Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?Use appropriate map() function :\nCompute standard deviation every column numeric data frame.\nCompute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)\nCompute number levels every factor data frame.\nUse appropriate map() function :Compute standard deviation every column numeric data frame.Compute standard deviation every column numeric data frame.Compute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)Compute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)Compute number levels every factor data frame.Compute number levels every factor data frame.following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.\n\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?\n\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error .f(.x[[]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?Use map() fit linear models mtcars dataset using formulas\nstored list:\n\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ (1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ (1 / disp) + wt\n)Use map() fit linear models mtcars dataset using formulas\nstored list:Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)\n\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)","code":"\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error in .f(.x[[i]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))"},{"path":"functionals.html","id":"purrr-style","chapter":"3 Functionals","heading":"3.3 Purrr style","text":"go explore map variants, let’s take quick look tend use multiple purrr functions solve moderately realistic problem: fitting model subgroup extracting coefficient model. toy example, ’m going break mtcars data set groups defined number cylinders, using base split function:creates list three data frames: cars 4, 6, 8 cylinders respectively.Now imagine want fit linear model, extract second coefficient (.e. slope). following code shows might purrr:(haven’t seen %>%, pipe, , ’s described Section 1.3.)think code easy read line encapsulates single step, can easily distinguish functional , purrr helpers allow us concisely describe step.attack problem base R? certainly replace purrr function equivalent base function:isn’t really base R since ’re using pipe. tackle purely base think ’d use intermediate variable, step:, course, use loop:’s interesting note move purrr base apply functions loops tend iteration. purrr iterate 3 times (map(), map(), map_dbl()), apply functions iterate twice (lapply(), vapply()), loop iterate . prefer , simpler, steps think makes code easier understand later modify.","code":"\nby_cyl <- split(mtcars, mtcars$cyl)\nby_cyl %>% \n  map(~ lm(mpg ~ wt, data = .x)) %>% \n  map(coef) %>% \n  map_dbl(2)\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nby_cyl %>% \n  lapply(function(data) lm(mpg ~ wt, data = data)) %>% \n  lapply(coef) %>% \n  vapply(function(x) x[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nmodels <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))\nvapply(models, function(x) coef(x)[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nslopes <- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model <- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] <- coef(model)[[2]]\n}\nslopes\n#> [1] -5.65 -2.78 -2.19"},{"path":"functionals.html","id":"map-variants","chapter":"3 Functionals","heading":"3.4 Map variants","text":"23 primary variants map(). far, ’ve learned five (map(), map_lgl(), map_int(), map_dbl() map_chr()). means ’ve got 18 (!!) learn. sounds like lot, fortunately design purrr means need learn five new ideas:Output type input modify()Iterate two inputs map2().Iterate index using imap()Return nothing walk().Iterate number inputs pmap().map family functions orthogonal input outputs, meaning can organise family matrix, inputs rows outputs columns. ’ve mastered idea row, can combine column; ’ve mastered idea column, can combine row. relationship summarised following table:","code":""},{"path":"functionals.html","id":"modify","chapter":"3 Functionals","heading":"3.4.1 Same type of output as input: modify()","text":"Imagine wanted double every column data frame. might first try using map(), map() always returns list:want keep output data frame, can use modify(), always returns type output input:Despite name, modify() doesn’t modify place, returns modified copy, wanted permanently modify df, ’d need assign :usual, basic implementation modify() simple, fact ’s even simpler map() don’t need create new output vector; can just progressively replace input. (real code little complex handle edge cases gracefully.)Section 3.6.2 ’ll learn useful variant modify(), called modify_if(). allows (e.g.) double numeric columns data frame modify_if(df, .numeric, ~ .x * 2).","code":"\ndf <- data.frame(\n  x = 1:3,\n  y = 6:4\n)\n\nmap(df, ~ .x * 2)\n#> $x\n#> [1] 2 4 6\n#> \n#> $y\n#> [1] 12 10  8\nmodify(df, ~ .x * 2)\n#>   x  y\n#> 1 2 12\n#> 2 4 10\n#> 3 6  8\ndf <- modify(df, ~ .x * 2)\nsimple_modify <- function(x, f, ...) {\n  for (i in seq_along(x)) {\n    x[[i]] <- f(x[[i]], ...)\n  }\n  x\n}"},{"path":"functionals.html","id":"map2","chapter":"3 Functionals","heading":"3.4.2 Two inputs: map2() and friends","text":"map() vectorised single argument, .x. means varies .x calling .f, arguments passed along unchanged, thus making poorly suited problems. example, find weighted mean list observations list weights? Imagine following data:can use map_dbl() compute unweighted means:passing ws additional argument doesn’t work arguments .f transformed:need new tool: map2(), vectorised two arguments. means .x .y varied call .f:arguments map2() slightly different arguments map() two vectors come function, rather one. Additional arguments still go afterwards:basic implementation map2() simple, quite similar map(). Instead iterating one vector, iterate two parallel:One big differences map2() simple function map2() recycles inputs make sure ’re length:words, map2(x, y, f) automatically behave like map(x, f, y) needed. helpful writing functions; scripts ’d generally just use simpler form directly.closest base equivalent map2() Map(), discussed Section 3.4.5.","code":"\nxs <- map(1:8, ~ runif(10))\nxs[[1]][[1]] <- NA\nws <- map(1:8, ~ rpois(10, 5) + 1)\nmap_dbl(xs, mean)\n#> [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443\nmap_dbl(xs, weighted.mean, w = ws)\n#> Error in weighted.mean.default(.x[[i]], ...): 'x' and 'w' must have the same length\nmap2_dbl(xs, ws, weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nmap2_dbl(xs, ws, weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nsimple_map2 <- function(x, y, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], y[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"no-outputs-walk-and-friends","chapter":"3 Functionals","heading":"3.4.3 No outputs: walk() and friends","text":"functions called value return, makes sense capture store value map() function. functions called primarily side-effects (e.g. cat(), write.csv(), ggsave()) doesn’t make sense capture results. Take simple example displays welcome message using cat(). cat() returns NULL, map() works (sense generates desired welcomes), also returns list(NULL, NULL).avoid problem assigning results map() variable never use, muddy intent code. Instead, purrr provides walk family functions ignore return values .f instead return .x invisibly16.visual depiction walk attempts capture important difference map(): outputs ephemeral, input returned invisibly.One useful walk() variants walk2() common side-effect saving something disk, saving something disk always pair values: object path want save .example, imagine list data frames (’ve created using split()), ’d like save one separate CSV file. ’s easy walk2():walk2() equivalent write.csv(cyls[[1]], paths[[1]]), write.csv(cyls[[2]], paths[[2]]), write.csv(cyls[[3]], paths[[3]]).base equivalent walk(); either wrap result lapply() invisible() save variable never used.","code":"\nwelcome <- function(x) {\n  cat(\"Welcome \", x, \"!\\n\", sep = \"\")\n}\nnames <- c(\"Hadley\", \"Jenny\")\n\n# As well as generate the welcomes, it also shows \n# the return value of cat()\nmap(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> NULL\nwalk(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\ntemp <- tempfile()\ndir.create(temp)\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\ndir(temp)\n#> [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\""},{"path":"functionals.html","id":"iterating-over-values-and-indices","chapter":"3 Functionals","heading":"3.4.4 Iterating over values and indices","text":"three basic ways loop vector loop:Loop elements: (x xs)Loop numeric indices: (seq_along(xs))Loop names: (nm names(xs))first form analogous map() family. second third forms equivalent imap() family allows iterate values indices vector parallel.imap() like map2() sense .f gets called two arguments, derived vector. imap(x, f) equivalent map2(x, names(x), f) x names, map2(x, seq_along(x), f) .imap() often useful constructing labels:vector unnamed, second argument index:imap() useful helper want work values vector along positions.","code":"\nimap_chr(iris, ~ paste0(\"The first value of \", .y, \" is \", .x[[1]]))\n#>                             Sepal.Length \n#> \"The first value of Sepal.Length is 5.1\" \n#>                              Sepal.Width \n#>  \"The first value of Sepal.Width is 3.5\" \n#>                             Petal.Length \n#> \"The first value of Petal.Length is 1.4\" \n#>                              Petal.Width \n#>  \"The first value of Petal.Width is 0.2\" \n#>                                  Species \n#>   \"The first value of Species is setosa\"\nx <- map(1:6, ~ sample(1000, 10))\nimap_chr(x, ~ paste0(\"The highest value of \", .y, \" is \", max(.x)))\n#> [1] \"The highest value of 1 is 975\" \"The highest value of 2 is 915\"\n#> [3] \"The highest value of 3 is 982\" \"The highest value of 4 is 955\"\n#> [5] \"The highest value of 5 is 971\" \"The highest value of 6 is 696\""},{"path":"functionals.html","id":"pmap","chapter":"3 Functionals","heading":"3.4.5 Any number of inputs: pmap() and friends","text":"Since map() map2(), might expect map3(), map4(), map5(), … stop? Instead generalising map2() arbitrary number arguments, purrr takes slightly different tack pmap(): supply single list, contains number arguments. cases, list equal-length vectors, .e. something similar data frame. diagrams, ’ll emphasise relationship drawing input similar data frame.’s simple equivalence map2() pmap(): map2(x, y, f) pmap(list(x, y), f). pmap() equivalent map2_dbl(xs, ws, weighted.mean) used :, varying arguments come .f (although now must wrapped list), constant arguments come afterwards.big difference pmap() map functions pmap() gives much finer control argument matching can name components list. Returning example Section 3.2.5, wanted vary trim argument x, instead use pmap():think ’s good practice name components list make clear function called.’s often convenient call pmap() data frame. handy way create data frame tibble::tribble(), allows describe data frame row--row (rather column--column, usual): thinking parameters function data frame powerful pattern. following example shows might draw random uniform numbers varying parameters:\n, column names critical: ’ve carefully chosen match arguments runif(), pmap(params, runif) equivalent runif(n = 1L, min = 0, max = 1), runif(n = 2, min = 10, max = 100), runif(n = 3L, min = 100, max = 1000). (data frame hand, names don’t match, use dplyr::rename() similar.)two base equivalents pmap() family: Map() mapply(). significant drawbacks:Map() vectorises arguments supply arguments \nvary.Map() vectorises arguments supply arguments \nvary.mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().","code":"\npmap_dbl(list(xs, ws), weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\npmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\n\npmap_dbl(list(trim = trims), mean, x = x)\n#> [1] -6.6740  0.0210  0.0235  0.0151\nparams <- tibble::tribble(\n  ~ n, ~ min, ~ max,\n   1L,     0,     1,\n   2L,    10,   100,\n   3L,   100,  1000\n)\n\npmap(params, runif)\n#> [[1]]\n#> [1] 0.332\n#> \n#> [[2]]\n#> [1] 53.5 47.6\n#> \n#> [[3]]\n#> [1] 231 715 515"},{"path":"functionals.html","id":"exercises-11","chapter":"3 Functionals","heading":"3.4.6 Exercises","text":"Explain results modify(mtcars, 1).Explain results modify(mtcars, 1).Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?Explain following code transforms data frame using functions\nstored list.\n\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nCompare contrast map2() approach map() approach:\n\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))Explain following code transforms data frame using functions\nstored list.Compare contrast map2() approach map() approach:write.csv() return, .e. happens use \nmap2() instead walk2()?write.csv() return, .e. happens use \nmap2() instead walk2()?","code":"\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))"},{"path":"functionals.html","id":"reduce","chapter":"3 Functionals","heading":"3.5 Reduce family","text":"map family, next important family functions reduce family. family much smaller, two main variants, used less commonly, ’s powerful idea, gives us opportunity discuss useful algebra, powers map-reduce framework frequently used processing large datasets.","code":""},{"path":"functionals.html","id":"basics-1","chapter":"3 Functionals","heading":"3.5.1 Basics","text":"reduce() takes vector length n produces vector length 1 calling function pair values time: reduce(1:4, f) equivalent f(f(f(1, 2), 3), 4).reduce() useful way generalise function works two inputs (binary function) work number inputs. Imagine list numeric vectors, want find values occur every element. First generate sample data:solve challenge need use intersect() repeatedly:reduce() automates solution us, can write:apply idea wanted list elements appear least one entry. switch intersect() union():Like map family, can also pass additional arguments. intersect() union() don’t take extra arguments can’t demonstrate , principle straightforward drew picture.usual, essence reduce() can reduced simple wrapper around loop:base equivalent Reduce(). Note argument order different: function comes first, followed vector, way supply additional arguments.","code":"\nl <- map(1:4, ~ sample(1:10, 15, replace = T))\nstr(l)\n#> List of 4\n#>  $ : int [1:15] 7 1 8 8 3 8 2 4 7 10 ...\n#>  $ : int [1:15] 3 1 10 2 5 2 9 8 5 4 ...\n#>  $ : int [1:15] 6 10 9 5 6 7 8 6 10 8 ...\n#>  $ : int [1:15] 9 8 6 4 4 5 2 9 9 6 ...\nout <- l[[1]]\nout <- intersect(out, l[[2]])\nout <- intersect(out, l[[3]])\nout <- intersect(out, l[[4]])\nout\n#> [1] 8 4\nreduce(l, intersect)\n#> [1] 8 4\nreduce(l, union)\n#>  [1]  7  1  8  3  2  4 10  5  9  6\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}"},{"path":"functionals.html","id":"accumulate","chapter":"3 Functionals","heading":"3.5.2 Accumulate","text":"first reduce() variant, accumulate(), useful understanding reduce works, instead returning just final result, returns intermediate results well:Another useful way understand reduce think sum(): sum(x) equivalent x[[1]] + x[[2]] + x[[3]] + ..., .e. reduce(x, `+`). accumulate(x, `+`) cumulative sum:","code":"\naccumulate(l, intersect)\n#> [[1]]\n#>  [1]  7  1  8  8  3  8  2  4  7 10 10  3  7 10 10\n#> \n#> [[2]]\n#> [1]  1  8  3  2  4 10\n#> \n#> [[3]]\n#> [1]  8  4 10\n#> \n#> [[4]]\n#> [1] 8 4\nx <- c(4, 3, 10)\nreduce(x, `+`)\n#> [1] 17\n\naccumulate(x, `+`)\n#> [1]  4  7 17"},{"path":"functionals.html","id":"output-types","chapter":"3 Functionals","heading":"3.5.3 Output types","text":"example using +, reduce() return x short, .e. length 1 0? Without additional arguments, reduce() just returns input x length 1:means reduce() way check input valid:’s length 0? get error suggests need use .init argument:.init ? figure , need see happens .init supplied:call reduce(1, `+`, init) result 1 + init. Now know result just 1, suggests .init 0:also ensures reduce() checks length 1 inputs valid function ’re calling:want get algebraic , 0 called identity real numbers operation addition: add 0 number, get number back. R applies principle determine summary function zero length input return:’re using reduce() function, always supply .init. Think carefully function return pass vector length 0 1, make sure test implementation.","code":"\nreduce(1, `+`)\n#> [1] 1\nreduce(\"a\", `+`)\n#> [1] \"a\"\nreduce(integer(), `+`)\n#> Error: `.x` is empty, and no `.init` supplied\nreduce(integer(), `+`, .init = 0)\n#> [1] 0\nreduce(\"a\", `+`, .init = 0)\n#> Error in .x + .y: non-numeric argument to binary operator\nsum(integer())  # x + 0 = x\n#> [1] 0\nprod(integer()) # x * 1 = x\n#> [1] 1\nmin(integer())  # min(x, Inf) = x\n#> [1] Inf\nmax(integer())  # max(x, -Inf) = x\n#> [1] -Inf"},{"path":"functionals.html","id":"multiple-inputs","chapter":"3 Functionals","heading":"3.5.4 Multiple inputs","text":"occasionally need pass two arguments function ’re reducing. example, might list data frames want join together, variables use join vary element element. specialised scenario, don’t want spend much time , want know reduce2() exists.length second argument varies based whether .init supplied: four elements x, f called three times. supply init, f called four times.","code":""},{"path":"functionals.html","id":"map-reduce","chapter":"3 Functionals","heading":"3.5.5 Map-reduce","text":"might heard map-reduce, idea powers technology like Hadoop. Now can see simple powerful underlying idea : map-reduce map combined reduce. difference large data data spread multiple computers. computer performs map data , sends result back coordinator reduces individual results back single result.simple example, imagine computing mean large vector, large split multiple computers. ask computer calculate sum length, return coordinator computes overall mean dividing total sum total length.","code":""},{"path":"functionals.html","id":"predicate-functionals","chapter":"3 Functionals","heading":"3.6 Predicate functionals","text":"\npredicate function returns single TRUE FALSE, like .character(), .null(), (), say predicate matches vector returns TRUE.","code":""},{"path":"functionals.html","id":"basics-2","chapter":"3 Functionals","heading":"3.6.1 Basics","text":"predicate functional applies predicate element vector. purrr provides seven useful functions come three groups:(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.\nsimilar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.similar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.following example shows might use functionals data frame:","code":"\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\ndetect(df, is.factor)\n#> NULL\ndetect_index(df, is.factor)\n#> [1] 0\n\nstr(keep(df, is.factor))\n#> 'data.frame':    3 obs. of  0 variables\nstr(discard(df, is.factor))\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ x: int  1 2 3\n#>  $ y: chr  \"a\" \"b\" \"c\""},{"path":"functionals.html","id":"predicate-map","chapter":"3 Functionals","heading":"3.6.2 Map variants","text":"map() modify() come variants also take predicate functions, transforming elements .x .p TRUE.","code":"\ndf <- data.frame(\n  num1 = c(0, 10, 20),\n  num2 = c(5, 6, 7),\n  chr1 = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\n\nstr(map_if(df, is.numeric, mean))\n#> List of 3\n#>  $ num1: num 10\n#>  $ num2: num 6\n#>  $ chr1: chr [1:3] \"a\" \"b\" \"c\"\nstr(modify_if(df, is.numeric, mean))\n#> 'data.frame':    3 obs. of  3 variables:\n#>  $ num1: num  10 10 10\n#>  $ num2: num  6 6 6\n#>  $ chr1: chr  \"a\" \"b\" \"c\"\nstr(map(keep(df, is.numeric), mean))\n#> List of 2\n#>  $ num1: num 10\n#>  $ num2: num 6"},{"path":"functionals.html","id":"exercises-12","chapter":"3 Functionals","heading":"3.6.3 Exercises","text":"isn’t .na() predicate function? base R function closest\npredicate version .na()?isn’t .na() predicate function? base R function closest\npredicate version .na()?simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .\n\nsimple_reduce <- function(x, f) {\n  <- x[[1]]\n  (seq(2, length(x))) {\n    <- f(, x[[]])\n  }\n  \n}simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?\n\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?","code":"\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}"},{"path":"functionals.html","id":"base-functionals","chapter":"3 Functionals","heading":"3.7 Base functionals","text":"finish chapter, provide survey important base functionals members map, reduce, predicate families, hence equivalent purrr. say ’re important, mathematical statistical flavour, generally less useful data analysis.","code":""},{"path":"functionals.html","id":"matrices-and-arrays","chapter":"3 Functionals","heading":"3.7.1 Matrices and arrays","text":"map() friends specialised work one-dimensional vectors. base::apply() specialised work two-dimensional higher vectors, .e. matrices arrays. can think apply() operation summarises matrix array collapsing row column single value. four arguments:X, matrix array summarise.X, matrix array summarise.MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)FUN, summary function.FUN, summary function.... arguments passed FUN.... arguments passed FUN.typical example apply() looks like thisYou can specify multiple dimensions MARGIN, useful high-dimensional arrays:two caveats using apply():Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().apply() also idempotent sense summary\nfunction identity operator, output always \ninput.\n\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUEapply() also idempotent sense summary\nfunction identity operator, output always \ninput.Never use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.\n\ndf <- data.frame(x = 1:3, y = c(\"\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n#>  x  y \n#> NA NANever use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.","code":"\na2d <- matrix(1:20, nrow = 5)\napply(a2d, 1, mean)\n#> [1]  8.5  9.5 10.5 11.5 12.5\napply(a2d, 2, mean)\n#> [1]  3  8 13 18\na3d <- array(1:24, c(2, 3, 4))\napply(a3d, 1, mean)\n#> [1] 12 13\napply(a3d, c(1, 2), mean)\n#>      [,1] [,2] [,3]\n#> [1,]   10   12   14\n#> [2,]   11   13   15\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUE\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n#>  x  y \n#> NA NA"},{"path":"functionals.html","id":"mathematical-concerns","chapter":"3 Functionals","heading":"3.7.2 Mathematical concerns","text":"Functionals common mathematics. limit, maximum, roots (set points f(x) = 0), definite integral functionals: given function, return single number (vector numbers). first glance, functions don’t seem fit theme eliminating loops, dig deeper ’ll find implemented using algorithm involves iteration.Base R provides useful set:integrate() finds area curve defined f()uniroot() finds f() hits zerooptimise() finds location lowest (highest) value f()following example shows functionals might used simple function, sin():","code":"\nintegrate(sin, 0, pi)\n#> 2 with absolute error < 2.2e-14\nstr(uniroot(sin, pi * c(1 / 2, 3 / 2)))\n#> List of 5\n#>  $ root      : num 3.14\n#>  $ f.root    : num 1.22e-16\n#>  $ iter      : int 2\n#>  $ init.it   : int NA\n#>  $ estim.prec: num 6.1e-05\nstr(optimise(sin, c(0, 2 * pi)))\n#> List of 2\n#>  $ minimum  : num 4.71\n#>  $ objective: num -1\nstr(optimise(sin, c(0, pi), maximum = TRUE))\n#> List of 2\n#>  $ maximum  : num 1.57\n#>  $ objective: num 1"},{"path":"functionals.html","id":"exercises-13","chapter":"3 Functionals","heading":"3.7.3 Exercises","text":"apply() arrange output? Read documentation perform\nexperiments.apply() arrange output? Read documentation perform\nexperiments.eapply() rapply() ? purrr equivalents?eapply() rapply() ? purrr equivalents?Challenge: read \nfixed point algorithm.\nComplete exercises using R.Challenge: read \nfixed point algorithm.\nComplete exercises using R.","code":""},{"path":"function-factories.html","id":"function-factories","chapter":"4 Function factories","heading":"4 Function factories","text":"","code":""},{"path":"function-factories.html","id":"introduction-3","chapter":"4 Function factories","heading":"4.1 Introduction","text":"function factory function makes functions. ’s simple example: use function factory (power1()) make two child functions (square() cube()):Don’t worry doesn’t make sense yet, end chapter!\n\n’ll call square() cube() manufactured functions, just term ease communication humans: R’s perspective different functions created way.already learned individual components make function factories possible:Section 1.2.3, learned R’s first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section 1.2.3, learned R’s first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section 2.4.2, learned function\ncaptures (encloses) environment created.Section 2.4.2, learned function\ncaptures (encloses) environment created.Section 2.4.4, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.Section 2.4.4, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.chapter, ’ll learn non-obvious combination three features leads function factory. ’ll also see examples usage visualisation statistics.three main functional programming tools (functionals, function factories, function operators), function factories least used. Generally, don’t tend reduce overall code complexity instead partition complexity easily digested chunks. Function factories also important building block useful function operators, ’ll learn Chapter 5.","code":"\npower1 <- function(exp) {\n  function(x) {\n    x ^ exp\n  }\n}\n\nsquare <- power1(2)\ncube <- power1(3)\nsquare(3)\n#> [1] 9\ncube(3)\n#> [1] 27"},{"path":"function-factories.html","id":"outline-3","chapter":"4 Function factories","heading":"Outline","text":"Section 4.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ’ll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 4.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ’ll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 4.3 illustrates use function factories \nexamples ggplot2. ’ll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 4.3 illustrates use function factories \nexamples ggplot2. ’ll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 4.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 4.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 4.5 shows can combine function\nfactories functionals rapidly generate family functions data.Section 4.5 shows can combine function\nfactories functionals rapidly generate family functions data.","code":""},{"path":"function-factories.html","id":"prerequisites-2","chapter":"4 Function factories","heading":"Prerequisites","text":"Make sure ’re familiar contents Sections 1.2.3 (first-class functions), 2.4.2 (function environment), 2.4.4 (execution environments) mentioned .Function factories need base R. ’ll use little rlang peek inside easily, ’ll use ggplot2 scales explore use function factories visualisation.","code":"\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(scales)"},{"path":"function-factories.html","id":"factory-fundamentals","chapter":"4 Function factories","heading":"4.2 Factory fundamentals","text":"key idea makes function factories work can expressed concisely:enclosing environment manufactured function execution\nenvironment function factory.takes words express big ideas, takes lot work really understand means. section help put pieces together interactive exploration diagrams.","code":""},{"path":"function-factories.html","id":"environments-1","chapter":"4 Function factories","heading":"4.2.1 Environments","text":"Let’s start taking look square() cube():’s obvious x comes , R find value associated exp? Simply printing manufactured functions revealing bodies identical; contents enclosing environment important factors. can get little insight using rlang::env_print(). shows us two different environments (originally execution environment power1()). environments parent, enclosing environment power1(), global environment.env_print() shows us environments binding exp, want see value17. can first getting environment function, extracting values:makes manufactured functions behave differently one another: names enclosing environment bound different values.","code":"\nsquare\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <environment: 0x55d1f510b598>\n\ncube\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x55d1f5235450>\n#> <environment: 0x55d1f51541c0>\nenv_print(square)\n#> <environment: 0x55d1f510b598>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\n\nenv_print(cube)\n#> <environment: 0x55d1f51541c0>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\nfn_env(square)$exp\n#> [1] 2\n\nfn_env(cube)$exp\n#> [1] 3"},{"path":"function-factories.html","id":"diagram-conventions","chapter":"4 Function factories","heading":"4.2.2 Diagram conventions","text":"can also show relationships diagram:’s lot going diagram details aren’t important. can simplify considerably using two conventions:free floating symbol lives global environment.free floating symbol lives global environment.environment without explicit parent inherits global\nenvironment.environment without explicit parent inherits global\nenvironment.view, focuses environments, doesn’t show direct link cube() square(). ’s link body function, identical , shown diagram.finish , let’s look execution environment square(10). square() executes x ^ exp finds x execution environment exp enclosing environment.","code":"\nsquare(10)\n#> [1] 100"},{"path":"function-factories.html","id":"forcing-evaluation","chapter":"4 Function factories","heading":"4.2.3 Forcing evaluation","text":"’s subtle bug power1() caused lazy evaluation. see problem need introduce indirection:square(2) return? hope returns 4:Unfortunately doesn’t x evaluated lazily square() run, power1() run. general, problem arise whenever binding changes calling factory function calling manufactured function. likely happen rarely, , lead real head-scratcher bug.can fix problem forcing evaluation force():Whenever create function factory, make sure every argument evaluated, using force() necessary argument used manufactured function.","code":"\nx <- 2\nsquare <- power1(x)\nx <- 3\nsquare(2)\n#> [1] 8\npower2 <- function(exp) {\n  force(exp)\n  function(x) {\n    x ^ exp\n  }\n}\n\nx <- 2\nsquare <- power2(x)\nx <- 3\nsquare(2)\n#> [1] 4"},{"path":"function-factories.html","id":"stateful-funs","chapter":"4 Function factories","heading":"4.2.4 Stateful functions","text":"함수 공장을 사용하면 함수 호출들에 대해 state 를 유지할수 있는데, 1.4.3 섹션에 기술된 fresh start 원칙때문에 일반적으로 쉬운 일은 아니다.two things make possible:enclosing environment manufactured function unique constant.enclosing environment manufactured function unique constant.R special assignment operator, <<-, modifies bindings \nenclosing environment.R special assignment operator, <<-, modifies bindings \nenclosing environment.일반 할당 연산자, <-, 는 항상 현재 환경에서 바인딩을 만든다. super assignment operator, <<- 은 부모 환경에 존재하는 이름을 새로 바인드 한다.following example shows can combine ideas create function records many times called:manufactured function run <<- + 1 modify enclosing environment. manufactured functions independent enclosing environments, independent counts:Stateful functions best used moderation. soon function starts managing state multiple variables, ’s better switch R6, topic Chapter ??.","code":"\nnew_counter <- function() {\n  i <- 0\n  \n  function() {\n    i <<- i + 1\n    i\n  }\n}\n\ncounter_one <- new_counter()\ncounter_two <- new_counter()\ncounter_one()\n#> [1] 1\ncounter_one()\n#> [1] 2\ncounter_two()\n#> [1] 1"},{"path":"function-factories.html","id":"factory-pitfalls","chapter":"4 Function factories","heading":"4.2.5 Garbage collection","text":"functions, can rely garbage collector clean large temporary objects created inside function. However, manufactured functions hold execution environment, ’ll need explicitly unbind large temporary objects rm(). Compare sizes g1() g2() example :","code":"\nf1 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  function() m\n}\n\ng1 <- f1(1e6)\nlobstr::obj_size(g1)\n#> 8,013,104 B\n\nf2 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  rm(x)\n  function() m\n}\n\ng2 <- f2(1e6)\nlobstr::obj_size(g2)\n#> 12,944 B"},{"path":"function-factories.html","id":"exercises-14","chapter":"4 Function factories","heading":"4.2.6 Exercises","text":"definition force() simple:\n\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x55d1f1342d40>\n#> <environment: namespace:base>\nbetter force(x) instead just x?definition force() simple:better force(x) instead just x?Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Create function pick() takes index, , argument \nreturns function argument x subsets x .\n\npick(1)(x)\n# equivalent \nx[[1]]\n\nlapply(mtcars, pick(5))\n# equivalent \nlapply(mtcars, function(x) x[[5]])Create function pick() takes index, , argument \nreturns function argument x subsets x .Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:\n\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(.equal(m1(x), 0))\nstopifnot(.equal(m2(x), var(x) * 99 / 100))Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:happens don’t use closure? Make predictions, verify \ncode .\n\n<- 0\nnew_counter2 <- function() {\n  <<- + 1\n  \n}happens don’t use closure? Make predictions, verify \ncode .happens use <- instead <<-? Make predictions, verify\ncode .\n\nnew_counter3 <- function() {\n  <- 0\n  function() {\n    <- + 1\n    \n  }\n}happens use <- instead <<-? Make predictions, verify\ncode .","code":"\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x55d1f1342d40>\n#> <environment: namespace:base>\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\ni <- 0\nnew_counter2 <- function() {\n  i <<- i + 1\n  i\n}\nnew_counter3 <- function() {\n  i <- 0\n  function() {\n    i <- i + 1\n    i\n  }\n}"},{"path":"function-factories.html","id":"graph-fact","chapter":"4 Function factories","heading":"4.3 Graphical factories","text":"’ll begin exploration useful function factories examples ggplot2.","code":""},{"path":"function-factories.html","id":"labelling","chapter":"4 Function factories","heading":"4.3.1 Labelling","text":"One goals scales package make easy customise labels ggplot2. provides many functions control fine details axes legends. formatter functions18 useful class functions make easier control appearance axis breaks. design functions might initially seem little odd: return function, call order format number.words, primary interface function factory. first glance, seems add extra complexity little gain. enables nice interaction ggplot2’s scales, accept functions label argument:","code":"\ny <- c(12345, 123456, 1234567)\ncomma_format()(y)\n#> [1] \"12,345\"    \"123,456\"   \"1,234,567\"\n\nnumber_format(scale = 1e-3, suffix = \" K\")(y)\n#> [1] \"12 K\"    \"123 K\"   \"1 235 K\"\ndf <- data.frame(x = 1, y = y)\ncore <- ggplot(df, aes(x, y)) + \n  geom_point() + \n  scale_x_continuous(breaks = 1, labels = NULL) +\n  labs(x = NULL, y = NULL)\n  \ncore\ncore + scale_y_continuous(\n  labels = comma_format()\n)\ncore + scale_y_continuous(\n  labels = number_format(scale = 1e-3, suffix = \" K\")\n)\ncore + scale_y_continuous(\n  labels = scientific_format()\n)"},{"path":"function-factories.html","id":"histogram-bins","chapter":"4 Function factories","heading":"4.3.2 Histogram bins","text":"little known feature geom_histogram() binwidth argument can function. particularly useful function executed group, means can different binwidths different facets, otherwise possible.illustrate idea, see variable binwidth might useful, ’m going construct example fixed binwidth isn’t great.facet number observations, variability different. nice request binwidths vary get approximately number observations bin. One way function factory inputs desired number bins (n), outputs function takes numeric vector returns binwidth:use pattern wrap around base R functions automatically find -called optimal19 binwidth, nclass.Sturges(), nclass.scott(), nclass.FD():","code":"\n# construct some sample data with very different numbers in each cell\nsd <- c(1, 5, 15)\nn <- 100\n\ndf <- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbinwidth_bins <- function(n) {\n  force(n)\n  \n  function(x) {\n    (max(x) - min(x)) / n\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = binwidth_bins(20)) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbase_bins <- function(type) {\n  fun <- switch(type,\n    Sturges = nclass.Sturges,\n    scott = nclass.scott,\n    FD = nclass.FD,\n    stop(\"Unknown type\", call. = FALSE)\n  )\n  \n  function(x) {\n    (max(x) - min(x)) / fun(x)\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = base_bins(\"FD\")) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)"},{"path":"function-factories.html","id":"ggsave","chapter":"4 Function factories","heading":"4.3.3 ggsave()","text":"Finally, want show function factory used internally ggplot2. ggplot2:::plot_dev() used ggsave() go file extension (e.g. png, jpeg etc) graphics device function (e.g. png(), jpeg()). challenge arises base graphics devices minor inconsistencies need paper :filename first argument file.filename first argument file.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.mildly simplified version plot_dev() shown :","code":"\nplot_dev <- function(ext, dpi = 96) {\n  force(dpi)\n  \n  switch(ext,\n    eps =  ,\n    ps  =  function(path, ...) {\n      grDevices::postscript(\n        file = filename, ..., onefile = FALSE, \n        horizontal = FALSE, paper = \"special\"\n      )\n    },\n    pdf = function(filename, ...) grDevices::pdf(file = filename, ...),\n    svg = function(filename, ...) svglite::svglite(file = filename, ...),\n    emf = ,\n    wmf = function(...) grDevices::win.metafile(...),\n    png = function(...) grDevices::png(..., res = dpi, units = \"in\"),\n    jpg = ,\n    jpeg = function(...) grDevices::jpeg(..., res = dpi, units = \"in\"),\n    bmp = function(...) grDevices::bmp(..., res = dpi, units = \"in\"),\n    tiff = function(...) grDevices::tiff(..., res = dpi, units = \"in\"),\n    stop(\"Unknown graphics extension: \", ext, call. = FALSE)\n  )\n}\n\nplot_dev(\"pdf\")\n#> function(filename, ...) grDevices::pdf(file = filename, ...)\n#> <bytecode: 0x55d1f5f04150>\n#> <environment: 0x55d1f62b0728>\nplot_dev(\"png\")\n#> function(...) grDevices::png(..., res = dpi, units = \"in\")\n#> <bytecode: 0x55d1f5cc6c30>\n#> <environment: 0x55d1f59505b0>"},{"path":"function-factories.html","id":"exercises-15","chapter":"4 Function factories","heading":"4.3.4 Exercises","text":"Compare contrast ggplot2::label_bquote() \nscales::number_format()","code":""},{"path":"function-factories.html","id":"stat-fact","chapter":"4 Function factories","heading":"4.4 Statistical factories","text":"motivating examples function factories come statistics:Box-Cox transformation.Bootstrap resampling.Maximum likelihood estimation.examples can tackled without function factories, think function factories good fit problems provide elegant solutions. examples expect statistical background, feel free skip don’t make much sense .","code":""},{"path":"function-factories.html","id":"box-cox-transformation","chapter":"4 Function factories","heading":"4.4.1 Box-Cox transformation","text":"Box-Cox transformation (type power transformation) flexible transformation often used transform data towards normality. single parameter, \\(\\lambda\\), controls strength transformation. express transformation simple two argument function:re-formulating function factory makes easy explore behaviour stat_function():general, allows use Box-Cox transformation function accepts unary transformation function: don’t worry function providing ... pass along additional arguments. also think partitioning lambda x two different function arguments natural since lambda plays quite different role x.","code":"\nboxcox1 <- function(x, lambda) {\n  stopifnot(length(lambda) == 1)\n  \n  if (lambda == 0) {\n    log(x)\n  } else {\n    (x ^ lambda - 1) / lambda\n  }\n}\nboxcox2 <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}\n\nstat_boxcox <- function(lambda) {\n  stat_function(aes(colour = lambda), fun = boxcox2(lambda), size = 1)\n}\n\nggplot(data.frame(x = c(0, 5)), aes(x)) + \n  lapply(c(0.5, 1, 1.5), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))\n\n# visually, log() does seem to make sense as the transformation\n# for lambda = 0; as values get smaller and smaller, the function\n# gets close and closer to a log transformation\nggplot(data.frame(x = c(0.01, 1)), aes(x)) + \n  lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))"},{"path":"function-factories.html","id":"bootstrap-generators","chapter":"4 Function factories","heading":"4.4.2 Bootstrap generators","text":"Function factories useful approach bootstrapping. Instead thinking single bootstrap (always need one!), can think bootstrap generator, function yields fresh bootstrap every time called:advantage function factory clear parametric bootstrap first fit model. can setup step , factory called, rather every time generate bootstrap:use rm(mod) linear model objects quite large (include complete copies model matrix input data) want keep manufactured function small possible.","code":"\nboot_permute <- function(df, var) {\n  n <- nrow(df)\n  force(var)\n  \n  function() {\n    col <- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nboot_mtcars1 <- boot_permute(mtcars, \"mpg\")\nhead(boot_mtcars1())\n#> [1] 16.4 22.8 22.8 22.8 16.4 19.2\nhead(boot_mtcars1())\n#> [1] 17.8 18.7 30.4 30.4 16.4 21.0\nboot_model <- function(df, formula) {\n  mod <- lm(formula, data = df)\n  fitted <- unname(fitted(mod))\n  resid <- unname(resid(mod))\n  rm(mod)\n\n  function() {\n    fitted + sample(resid)\n  }\n} \n\nboot_mtcars2 <- boot_model(mtcars, mpg ~ wt)\nhead(boot_mtcars2())\n#> [1] 25.0 24.0 21.7 19.2 24.9 16.0\nhead(boot_mtcars2())\n#> [1] 27.4 21.0 20.3 19.4 16.3 21.3"},{"path":"function-factories.html","id":"MLE","chapter":"4 Function factories","heading":"4.4.3 Maximum likelihood estimation","text":"\n\ngoal maximum likelihood estimation (MLE) find parameter values distribution make observed data likely. MLE, start probability function. example, take Poisson distribution. know \\(\\lambda\\), can compute probability getting vector \\(\\mathbf{x}\\) values (\\(x_1\\), \\(x_2\\), …, \\(x_n\\)) multiplying Poisson probability function follows:\\[ P(\\lambda, \\mathbf{x}) = \\prod_{=1}^{n} \\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!} \\]statistics, almost always work log function. log monotonic transformation preserves important properties (.e. extrema occur place), specific advantages:log turns product sum, easier work .log turns product sum, easier work .Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Let’s apply log transformation probability function simplify much possible:\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\log(\\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!}) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\left( x_i \\log(\\lambda) - \\lambda - \\log(x_i!) \\right) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n     \\sum_{=1}^{n} x_i \\log(\\lambda)\n   - \\sum_{=1}^{n} \\lambda \n   - \\sum_{=1}^{n} \\log(x_i!) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n   \\log(\\lambda) \\sum_{=1}^{n} x_i - n \\lambda - \\sum_{=1}^{n} \\log(x_i!) \\]can now turn function R function. R function quite elegant R vectorised , ’s statistical programming language, R comes built-functions like log-factorial (lfactorial()).Consider vector observations:can use lprob_poisson() compute (logged) probability x1 different values lambda.far ’ve thinking lambda fixed known function told us probability getting different values x. real-life, observe x lambda unknown. likelihood probability function seen lens: want find lambda makes observed x likely. , given x, value lambda gives us highest value lprob_poisson()?statistics, highlight change perspective writing \\(f_{\\mathbf{x}}(\\lambda)\\) instead \\(f(\\lambda, \\mathbf{x})\\). R, can use function factory. provide x generate function single parameter, lambda:(don’t need force() length() implicitly forces evaluation x.)One nice thing approach can precomputation: term involves x can computed factory. useful ’re going need call function many times find best lambda.Now can use function find value lambda maximizes (log) likelihood:Rather trial error, can automate process finding best value optimise(). evaluate ll1() many times, using mathematical tricks narrow largest value quickly possible. results tell us highest value -30.27 occurs lambda = 32.1:Now, solved problem without using function factory optimise() passes ... function optimised. means use log-probability function directly:advantage using function factory fairly small, two niceties:can precompute values factory, saving computation time\niteration.can precompute values factory, saving computation time\niteration.two-level design better reflects mathematical structure \nunderlying problem.two-level design better reflects mathematical structure \nunderlying problem.advantages get bigger complex MLE problems, multiple parameters multiple data vectors.","code":"\nlprob_poisson <- function(lambda, x) {\n  n <- length(x)\n  (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x))\n}\nx1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\nlprob_poisson(10, x1)\n#> [1] -184\nlprob_poisson(20, x1)\n#> [1] -61.1\nlprob_poisson(30, x1)\n#> [1] -31\nll_poisson1 <- function(x) {\n  n <- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\nll_poisson2 <- function(x) {\n  n <- length(x)\n  sum_x <- sum(x)\n  c <- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\nll1 <- ll_poisson2(x1)\n\nll1(10)\n#> [1] -184\nll1(20)\n#> [1] -61.1\nll1(30)\n#> [1] -31\noptimise(ll1, c(0, 100), maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3\noptimise(lprob_poisson, c(0, 100), x = x1, maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3"},{"path":"function-factories.html","id":"exercises-16","chapter":"4 Function factories","heading":"4.4.4 Exercises","text":"boot_model(), don’t need force evaluation df\nmodel?boot_model(), don’t need force evaluation df\nmodel?might formulate Box-Cox transformation like ?\n\nboxcox3 <- function(x) {\n  function(lambda) {\n    (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}might formulate Box-Cox transformation like ?don’t need worry boot_permute() stores copy \ndata inside function generates?don’t need worry boot_permute() stores copy \ndata inside function generates?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?","code":"\nboxcox3 <- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}"},{"path":"function-factories.html","id":"functional-factories","chapter":"4 Function factories","heading":"4.5 Function factories + functionals","text":"finish chapter, ’ll show might combine functionals function factories turn data many functions. following code creates many specially named power functions iterating list arguments:idea extends straightforward way function factory takes two (replace map() map2()) (replace pmap()) arguments.One downside current construction prefix every function call funs$. three ways eliminate additional syntax:temporary effect, can use ():\n\n(funs, root(100))\n#> [1] 10\nrecommend makes clear code \nexecuted special context context .temporary effect, can use ():recommend makes clear code \nexecuted special context context .longer effect, can attach() functions search path,\ndetach() ’re done:\n\nattach(funs)\n#> following objects masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\n’ve probably told avoid using attach(), ’s generally\ngood advice. However, situation little different usual\n’re attaching list functions, data frame. ’s less\nlikely ’ll modify function column data frame, \nworst problems attach() don’t apply.longer effect, can attach() functions search path,\ndetach() ’re done:’ve probably told avoid using attach(), ’s generally\ngood advice. However, situation little different usual\n’re attaching list functions, data frame. ’s less\nlikely ’ll modify function column data frame, \nworst problems attach() don’t apply.Finally, copy functions global environment \nenv_bind() (’ll learn !!! Section ??).\nmostly permanent:\n\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\ncan later unbind names, ’s guarantee \nhaven’t rebound meantime, might deleting \nobject someone else created.\n\nrlang::env_unbind(globalenv(), names(funs))Finally, copy functions global environment \nenv_bind() (’ll learn !!! Section ??).\nmostly permanent:can later unbind names, ’s guarantee \nhaven’t rebound meantime, might deleting \nobject someone else created.’ll learn alternative approach problem Section ??. Instead using function factory, construct function quasiquotation. requires additional knowledge, generates functions readable bodies, avoids accidentally capturing large objects enclosing scope. use idea Section ?? work tools generating HTML R.","code":"\nnames <- list(\n  square = 2, \n  cube = 3, \n  root = 1/2, \n  cuberoot = 1/3, \n  reciprocal = -1\n)\nfuns <- purrr::map(names, power1)\n\nfuns$root(64)\n#> [1] 8\nfuns$root\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x55d1f5235450>\n#> <environment: 0x55d1f7d01378>\nwith(funs, root(100))\n#> [1] 10\nattach(funs)\n#> The following objects are masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\nrlang::env_unbind(globalenv(), names(funs))"},{"path":"function-factories.html","id":"exercises-17","chapter":"4 Function factories","heading":"4.5.1 Exercises","text":"following commands equivalent (x, f(z))?\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\ndepends.\nfollowing commands equivalent (x, f(z))?x$f(x$z).f(x$z).x$f(z).f(z).depends.Compare contrast effects env_bind() vs. attach() \nfollowing code.\n\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> following objects masked package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))Compare contrast effects env_bind() vs. attach() \nfollowing code.","code":"\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> The following objects are masked from package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))"},{"path":"function-operators.html","id":"function-operators","chapter":"5 Function operators","heading":"5 Function operators","text":"","code":""},{"path":"function-operators.html","id":"introduction-4","chapter":"5 Function operators","heading":"5.1 Introduction","text":"chapter, ’ll learn function operators. function operator function takes one () functions input returns function output. following code shows simple function operator, chatty(). wraps function, making new function prints first argument. might create function like gives window see functionals, like map_int(), work.Function operators closely related function factories; indeed ’re just function factory takes function input. Like factories, ’s nothing can’t without , often allow factor complexity order make code readable reusable.Function operators typically paired functionals. ’re using -loop, ’s rarely reason use function operator, make code complex little gain.’re familiar Python, decorators just another name function operators.","code":"\nchatty <- function(f) {\n  force(f)\n  \n  function(x, ...) {\n    res <- f(x, ...)\n    cat(\"Processing \", x, \"\\n\", sep = \"\")\n    res\n  }\n}\nf <- function(x) x ^ 2\ns <- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n#> Processing 3\n#> Processing 2\n#> Processing 1\n#> [1] 9 4 1"},{"path":"function-operators.html","id":"outline-4","chapter":"5 Function operators","heading":"Outline","text":"Section 5.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 5.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 5.3 works problem amenable solution\nfunction operators: downloading many web pages.Section 5.3 works problem amenable solution\nfunction operators: downloading many web pages.","code":""},{"path":"function-operators.html","id":"prerequisites-3","chapter":"5 Function operators","heading":"Prerequisites","text":"Function operators type function factory, make sure ’re familiar least Section 1.2 go .’ll use purrr couple functionals learned Chapter 3, function operators ’ll learn . ’ll also use memoise package20 memoise() operator.","code":"\nlibrary(purrr)\nlibrary(memoise)"},{"path":"function-operators.html","id":"existing-fos","chapter":"5 Function operators","heading":"5.2 Existing function operators","text":"two useful function operators help solve common recurring problems, give sense function operators can : purrr::safely() memoise::memoise().","code":""},{"path":"function-operators.html","id":"safely","chapter":"5 Function operators","heading":"5.2.1 Capturing errors with purrr::safely()","text":"One advantage -loops one iterations fails, can still access results failure:thing functional, get output, making hard figure problem lies:purrr::safely() provides tool help problem. safely() function operator transforms function turn errors data. (can learn basic idea makes work Section ??.) Let’s start taking look outside map_dbl():Like function operators, safely() takes function returns wrapped function can call usual:can see function transformed safely() always returns list two elements, result error. function runs successfully, error NULL result contains result; function fails, result NULL error contains error.Now lets use safely() functional:output slightly inconvenient form, since four lists, list containing result error. can make output easier use turning “inside-” purrr::transpose(), get list results list errors:Now can easily find results worked, inputs failed:can use technique many different situations. example, imagine ’re fitting generalised linear model (GLM) list data frames. GLMs can sometimes fail optimisation problems, still want able try fit models, later look back failed:think great example power combining functionals function operators: safely() lets succinctly express need solve common data analysis problem.purrr comes three function operators similar vein:possibly(): returns default value ’s error.\nprovides way tell error occured , ’s best\nreserved cases ’s obvious sentinel value (like NA).possibly(): returns default value ’s error.\nprovides way tell error occured , ’s best\nreserved cases ’s obvious sentinel value (like NA).quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.auto_browser(): automatically executes browser() inside \nfunction ’s error.auto_browser(): automatically executes browser() inside \nfunction ’s error.See documentation details.","code":"\nx <- list(\n  c(0.512, 0.165, 0.717),\n  c(0.064, 0.781, 0.427),\n  c(0.890, 0.785, 0.495),\n  \"oops\"\n)\n\nout <- rep(NA_real_, length(x))\nfor (i in seq_along(x)) {\n  out[[i]] <- sum(x[[i]])\n}\n#> Error in sum(x[[i]]): invalid 'type' (character) of argument\nout\n#> [1] 1.39 1.27 2.17   NA\nmap_dbl(x, sum)\n#> Error in .Primitive(\"sum\")(..., na.rm = na.rm): invalid 'type' (character) of argument\nsafe_sum <- safely(sum)\nsafe_sum\n#> function (...) \n#> capture_error(.f(...), otherwise, quiet)\n#> <bytecode: 0x55dd0415f418>\n#> <environment: 0x55dd0415ef80>\nstr(safe_sum(x[[1]]))\n#> List of 2\n#>  $ result: num 1.39\n#>  $ error : NULL\nstr(safe_sum(x[[4]]))\n#> List of 2\n#>  $ result: NULL\n#>  $ error :List of 2\n#>   ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- map(x, safely(sum))\nstr(out)\n#> List of 4\n#>  $ :List of 2\n#>   ..$ result: num 1.39\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 1.27\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 2.17\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: NULL\n#>   ..$ error :List of 2\n#>   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- transpose(map(x, safely(sum)))\nstr(out)\n#> List of 2\n#>  $ result:List of 4\n#>   ..$ : num 1.39\n#>   ..$ : num 1.27\n#>   ..$ : num 2.17\n#>   ..$ : NULL\n#>  $ error :List of 4\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ :List of 2\n#>   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nok <- map_lgl(out$error, is.null)\nok\n#> [1]  TRUE  TRUE  TRUE FALSE\n\nx[!ok]\n#> [[1]]\n#> [1] \"oops\"\n\nout$result[ok]\n#> [[1]]\n#> [1] 1.39\n#> \n#> [[2]]\n#> [1] 1.27\n#> \n#> [[3]]\n#> [1] 2.17\nfit_model <- function(df) {\n  glm(y ~ x1 + x2 * x3, data = df)\n}\n\nmodels <- transpose(map(datasets, safely(fit_model)))\nok <- map_lgl(models$error, is.null)\n\n# which data failed to converge?\ndatasets[!ok]\n\n# which models were successful?\nmodels[ok]"},{"path":"function-operators.html","id":"memoise","chapter":"5 Function operators","heading":"5.2.2 Caching computations with memoise::memoise()","text":"\nAnother handy function operator memoise::memoise(). memoises function, meaning function remember previous inputs return cached results. Memoisation example classic computer science tradeoff memory versus speed. memoised function can run much faster, stores previous inputs outputs, uses memory.Let’s explore idea toy function simulates expensive operation:memoise function, ’s slow call new arguments. call arguments ’s seen ’s instantaneous: retrieves previous value computation.relatively realistic use memoisation computing Fibonacci series. Fibonacci series defined recursively: first two values defined convention, \\(f(0) = 0\\), \\(f(1) = 1\\), \\(f(n) = f(n - 1) + f(n - 2)\\) (positive integer). naive version slow , example, fib(10) computes fib(9) fib(8), fib(9) computes fib(8) fib(7), .Memoising fib() makes implementation much faster value computed :future calls can rely previous computations:example dynamic programming, complex problem can broken many overlapping subproblems, remembering results subproblem considerably improves performance.Think carefully memoising function. function pure, .e. output depend input, get misleading confusing results. created subtle bug devtools memoised results available.packages(), rather slow download large file CRAN. available packages don’t change frequently, R process ’s running days, changes can become important, problem arose long-running R processes, bug painful find.","code":"\nslow_function <- function(x) {\n  Sys.sleep(1)\n  x * 10 * runif(1)\n}\nsystem.time(print(slow_function(1)))\n#> [1] 0.808\n#>    user  system elapsed \n#>       0       0       1\n\nsystem.time(print(slow_function(1)))\n#> [1] 8.34\n#>    user  system elapsed \n#>   0.003   0.000   1.004\nfast_function <- memoise::memoise(slow_function)\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>   0.001   0.000   1.002\n\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>   0.017   0.000   0.017\nfib <- function(n) {\n  if (n < 2) return(1)\n  fib(n - 2) + fib(n - 1)\n}\nsystem.time(fib(23))\n#>    user  system elapsed \n#>   0.047   0.000   0.047\nsystem.time(fib(24))\n#>    user  system elapsed \n#>    0.08    0.00    0.08\nfib2 <- memoise::memoise(function(n) {\n  if (n < 2) return(1)\n  fib2(n - 2) + fib2(n - 1)\n})\nsystem.time(fib2(23))\n#>    user  system elapsed \n#>   0.007   0.000   0.007\nsystem.time(fib2(24))\n#>    user  system elapsed \n#>   0.001   0.000   0.001"},{"path":"function-operators.html","id":"exercises-18","chapter":"5 Function operators","heading":"5.2.3 Exercises","text":"Base R provides function operator form Vectorize().\n? might use ?Base R provides function operator form Vectorize().\n? might use ?Read source code possibly(). work?Read source code possibly(). work?Read source code safely(). work?Read source code safely(). work?","code":""},{"path":"function-operators.html","id":"fo-case-study","chapter":"5 Function operators","heading":"5.3 Case study: Creating your own function operators","text":"meomoise() safely() useful also quite complex. case study ’ll learn create simpler function operators. Imagine named vector URLs ’d like download one disk. ’s pretty simple walk2() file.download():approach fine handful URLs, vector gets longer, might want add couple features:Add small delay request avoid hammering server.Add small delay request avoid hammering server.Display . every URLs know function still\nworking.Display . every URLs know function still\nworking.’s relatively easy add extra features ’re using loop:think loop suboptimal interleaves different concerns: pausing, showing progress, downloading. makes code harder read, makes harder reuse components new situations. Instead, let’s see can use function operators extract pausing showing progress make reusable.First, let’s write function operator adds small delay. ’m going call delay_by() reasons clear shortly, two arguments: function wrap, amount delay add. actual implementation quite simple. main trick forcing evaluation arguments described Section 4.2.5, function operators special type function factory:can use original walk2():Creating function display occasional dot little harder, can longer rely index loop. pass index along another argument, breaks encapsulation: concern progress function now becomes problem higher level wrapper needs handle. Instead, ’ll use another function factory trick (Section 4.2.4), progress wrapper can manage internal counter:Now can express original loop :starting get little hard read composing many function calls, arguments getting spread . One way resolve use pipe:pipe works well ’ve carefully chosen function names yield (almost) readable sentence: take download.file (add) dot every 10 iterations, delay 0.1s. clearly can express intent code function names, easily others (including future !) can read understand code.","code":"\nurls <- c(\n  \"adv-r\" = \"https://adv-r.hadley.nz\", \n  \"r4ds\" = \"http://r4ds.had.co.nz/\"\n  # and many many more\n)\npath <- paste(tempdir(), names(urls), \".html\")\n\nwalk2(urls, path, download.file, quiet = TRUE)\nfor(i in seq_along(urls)) {\n  Sys.sleep(0.1)\n  if (i %% 10 == 0) cat(\".\")\n  download.file(urls[[i]], paths[[i]])\n}\ndelay_by <- function(f, amount) {\n  force(f)\n  force(amount)\n  \n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\nsystem.time(runif(100))\n#>    user  system elapsed \n#>       0       0       0\nsystem.time(delay_by(runif, 0.1)(100))\n#>    user  system elapsed \n#>     0.0     0.0     0.1\nwalk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)\ndot_every <- function(f, n) {\n  force(f)\n  force(n)\n  \n  i <- 0\n  function(...) {\n    i <<- i + 1\n    if (i %% n == 0) cat(\".\")\n    f(...)\n  }\n}\nwalk(1:100, runif)\nwalk(1:100, dot_every(runif, 10))\n#> ..........\nwalk2(\n  urls, path, \n  dot_every(delay_by(download.file, 0.1), 10), \n  quiet = TRUE\n)\nwalk2(\n  urls, path, \n  download.file %>% dot_every(10) %>% delay_by(0.1), \n  quiet = TRUE\n)"},{"path":"function-operators.html","id":"exercises-19","chapter":"5 Function operators","heading":"5.3.1 Exercises","text":"Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).memoise file.download()? ?memoise file.download()? ?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Write function operator logs timestamp message file\nevery time function run.Write function operator logs timestamp message file\nevery time function run.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t \nextra delay.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t \nextra delay.","code":""}]
