[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":" website 2nd edition ‚ÄúAdvanced R‚Äù, book Chapman & Hall‚Äôs R Series. book designed primarily R users want improve programming skills understanding language. also useful programmers coming R languages, help understand R works way .‚Äôre looking 1st edition, can find http://adv-r..co.nz/.","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"work, whole, licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.code contained book simultaneously available MIT license; means free use packages, long cite source.","code":""},{"path":"index.html","id":"other-books","chapter":"Welcome","heading":"Other books","text":"may also interested :‚ÄúAdvanced R Solutions‚Äù \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.‚ÄúAdvanced R Solutions‚Äù \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.‚ÄúR Data Science‚Äù introduces R\ntool data science, focussing consistent\nset packages known tidyverse.‚ÄúR Data Science‚Äù introduces R\ntool data science, focussing consistent\nset packages known tidyverse.‚ÄúR Packages‚Äù teaches \nmake R‚Äôs fantastic package system.‚ÄúR Packages‚Äù teaches \nmake R‚Äôs fantastic package system.","code":""},{"path":"fp.html","id":"fp","chapter":"Introduction","heading":"Introduction","text":"R, heart, functional language. means certain technical properties, importantly lends style problem solving centred functions. ‚Äôll give brief overview technical definition functional language, book primarily focus functional style programming, think extremely good fit types problem commonly encounter data analysis.Recently, functional techniques experienced surge interest can produce efficient elegant solutions many modern problems. functional style tends create functions can easily analysed isolation (.e.¬†using local information), hence often much easier automatically optimise parallelise. traditional weaknesses functional languages, poorer performance sometimes unpredictable memory usage, much reduced recent years. Functional programming complementary object-oriented programming, dominant programming paradigm last several decades.","code":""},{"path":"fp.html","id":"functional-programming-languages","chapter":"Introduction","heading":"Functional programming languages","text":"Every programming language functions, makes programming language functional? many definitions precisely makes language functional, two common threads.Firstly, functional languages first-class functions, functions behave like data structure. R, means can many things function can vector: can assign variables, store lists, pass arguments functions, create inside functions, even return result function.Secondly, many functional languages require functions pure. function pure satisfies two properties:output depends inputs, .e.¬†call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.output depends inputs, .e.¬†call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.Pure functions much easier reason , obviously significant downsides: imagine data analysis couldn‚Äôt generate random numbers read files disk.Strictly speaking, R isn‚Äôt functional programming language doesn‚Äôt require write pure functions. However, can certainly adopt functional style parts code: don‚Äôt write pure functions, often . experience, partitioning code functions either extremely pure extremely impure tends lead code easier understand extends new situations.","code":""},{"path":"fp.html","id":"functional-style","chapter":"Introduction","heading":"Functional style","text":"‚Äôs hard describe exactly functional style , generally think means decomposing big problem smaller pieces, solving piece function combination functions. using functional style, strive decompose components problem isolated functions operate independently. function taken simple straightforward understand; complexity handled composing functions various ways.following three chapters discuss three key functional techniques help decompose problems smaller pieces:Chapter 1 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n‚Äôll use time data analysis.Chapter 1 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n‚Äôll use time data analysis.Chapter 2 introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter 2 introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter 3 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Chapter 3 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Collectively, types function called higher-order functions fill two--two table:","code":""},{"path":"functionals.html","id":"functionals","chapter":"1 Functionals","heading":"1 Functionals","text":"","code":""},{"path":"functionals.html","id":"introduction","chapter":"1 Functionals","heading":"1.1 Introduction","text":"become significantly reliable, code must become transparent.\nparticular, nested conditions loops must viewed great\nsuspicion. Complicated control flows confuse programmers. Messy code often\nhides bugs.‚Äî Bjarne StroustrupA functional function takes function input returns vector output. ‚Äôs simple functional: calls function provided input 1000 random uniform numbers.chances ‚Äôve already used functional. might used -loop replacements like base R‚Äôs lapply(), apply(), tapply(); purrr‚Äôs map(); maybe ‚Äôve used mathematical functional like integrate() optim().\ncommon use functionals alternative loops. loops bad rap R many people believe slow1, real downside loops ‚Äôre flexible: loop conveys ‚Äôre iterating, done results. Just ‚Äôs better use repeat, ‚Äôs better use (Section ??), ‚Äôs better use functional . functional tailored specific task, recognise functional immediately know ‚Äôs used.‚Äôre experienced loop user, switching functionals typically pattern matching exercise. look loop find functional matches basic form. one doesn‚Äôt exist, don‚Äôt try torture existing functional fit form need. Instead, just leave loop! (‚Äôve repeated loop two times, maybe think writing functional).","code":"\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n#> [1] 0.506\nrandomise(mean)\n#> [1] 0.501\nrandomise(sum)\n#> [1] 489"},{"path":"functionals.html","id":"outline","chapter":"1 Functionals","heading":"Outline","text":"Section 1.2 introduces first functional: purrr::map().Section 1.2 introduces first functional: purrr::map().Section 1.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 1.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 1.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 1.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 1.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 1.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 1.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 1.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 1.7 reviews functionals base R \nmembers map, reduce, predicate families.Section 1.7 reviews functionals base R \nmembers map, reduce, predicate families.","code":""},{"path":"functionals.html","id":"prerequisites","chapter":"1 Functionals","heading":"Prerequisites","text":"chapter focus functionals provided purrr package.2 functions consistent interface makes easier understand key ideas base equivalents, grown organically many years. ‚Äôll compare contrast base R functions go, wrap chapter discussion base functionals don‚Äôt purrr equivalents.","code":"\nlibrary(purrr)"},{"path":"functionals.html","id":"map","chapter":"1 Functionals","heading":"1.2 My first functional: map()","text":"fundamental functional purrr::map()3. takes vector function, calls function element vector, returns results list. words, map(1:3, f) equivalent list(f(1), f(2), f(3))., graphically:might wonder function called map(). depicting physical features land sea üó∫? fact, meaning comes mathematics map refers ‚Äúoperation associates element given set one elements second set.‚Äù makes sense map() defines mapping one vector another. (‚ÄúMap‚Äù also nice property short, useful fundamental building block.)implementation map() quite simple. allocate list length input, fill list loop. heart implementation handful lines code:real purrr::map() function differences: written C eke every last iota performance, preserves names, supports shortcuts ‚Äôll learn Section 1.2.2.base equivalent map() lapply(). difference lapply() support helpers ‚Äôll learn , ‚Äôre using map() purrr, can skip additional dependency use lapply() directly.","code":"\ntriple <- function(x) x * 3\nmap(1:3, triple)\n#> [[1]]\n#> [1] 3\n#> \n#> [[2]]\n#> [1] 6\n#> \n#> [[3]]\n#> [1] 9\nsimple_map <- function(x, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"map-atomic","chapter":"1 Functionals","heading":"1.2.1 Producing atomic vectors","text":"map() returns list, makes general map family can put anything list. inconvenient return list simpler data structure , four specific variants: map_lgl(), map_int(), map_dbl(), map_chr(). returns atomic vector specified type:purrr uses convention suffixes, like _dbl(), refer output. map_*() functions can take type vector input. examples rely two facts: mtcars data frame, data frames lists containing vectors length. obvious draw data frame orientation vector:map functions always return output vector length input, implies call .f must return single value. , ‚Äôll get error:similar error ‚Äôll get .f returns wrong type result:either case, ‚Äôs often useful switch back map(), map() can accept type output. allows see problematic output, figure .Base R two apply functions can return atomic vectors: sapply() vapply(). recommend avoid sapply() tries simplify result, can return list, vector, matrix. makes difficult program , avoided non-interactive settings. vapply() safer allows provide template, FUN.VALUE, describes output shape. don‚Äôt want use purrr, recommend always use vapply() functions, sapply(). primary downside vapply() verbosity: example, equivalent map_dbl(x, mean, na.rm = TRUE) vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1)).","code":"\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n#>      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#> \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#>       am     gear     carb \n#> \"double\" \"double\" \"double\"\n\n# map_lgl() always returns a logical vector\nmap_lgl(mtcars, is.double)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#> TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() always returns a integer vector\nn_unique <- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n#>     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#>  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 \n#>    carb \n#>   2.812\npair <- function(x) c(x, x)\nmap_dbl(1:2, pair)\n#> Error: Result 1 must be a single double, not an integer vector of length 2\nmap_dbl(1:2, as.character)\n#> Error: Can't coerce element 1 from a character to a double\nmap(1:2, pair)\n#> [[1]]\n#> [1] 1 1\n#> \n#> [[2]]\n#> [1] 2 2\nmap(1:2, as.character)\n#> [[1]]\n#> [1] \"1\"\n#> \n#> [[2]]\n#> [1] \"2\""},{"path":"functionals.html","id":"purrr-shortcuts","chapter":"1 Functionals","heading":"1.2.2 Anonymous functions and shortcuts","text":"\nInstead using map() existing function, can create inline anonymous function (mentioned Section ??):Anonymous functions useful, syntax verbose. purrr supports special shortcut:works purrr functions translate formulas, created ~ (pronounced ‚Äútwiddle‚Äù), functions. can see ‚Äôs happening behind scenes calling as_mapper():function arguments look little quirky allow refer . one argument functions, .x .y two argument functions, ..1, ..2, ..3, etc, functions arbitrary number arguments. . remains backward compatibility don‚Äôt recommend using ‚Äôs easily confused . used magrittr‚Äôs pipe.shortcut particularly useful generating random data:Reserve syntax short simple functions. good rule thumb function spans lines uses {}, ‚Äôs time give name.map functions also shortcuts extracting elements vector, powered purrr::pluck(). can use character vector select elements name, integer vector select position, list select name position. useful working deeply nested lists, often arise working JSON.base R functions, like lapply(), can provide name function string. isn‚Äôt tremendously useful lapply(x, \"f\") almost always equivalent lapply(x, f) typing.","code":"\nmap_dbl(mtcars, function(x) length(unique(x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nmap_dbl(mtcars, ~ length(unique(.x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nas_mapper(~ length(unique(.x)))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(unique(.x))\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\nx <- map(1:3, ~ runif(2))\nstr(x)\n#> List of 3\n#>  $ : num [1:2] 0.281 0.53\n#>  $ : num [1:2] 0.433 0.917\n#>  $ : num [1:2] 0.0275 0.8249\nx <- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n#> [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n#> [1] -1 -2 -3\n\n# Or by both\nmap_dbl(x, list(\"y\", 1))\n#> [1] 2 5 9\n\n# You'll get an error if a component doesn't exist:\nmap_chr(x, \"z\")\n#> Error: Result 3 must be a single string, not NULL of length 0\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n#> [1] \"a\" \"b\" NA"},{"path":"functionals.html","id":"passing-arguments","chapter":"1 Functionals","heading":"1.2.3 Passing arguments with ...","text":"‚Äôs often convenient pass along additional arguments function ‚Äôre calling. example, might want pass na.rm = TRUE along mean(). One way anonymous function:map functions pass ... along, ‚Äôs simpler form available:easiest understand picture: arguments come f call map() inserted data individual calls f():‚Äôs important note arguments decomposed; said another way, map() vectorised first argument. argument f vector, passed along :(‚Äôll learn map variants vectorised multiple arguments Sections 1.4.2 1.4.5.)Note ‚Äôs subtle difference placing extra arguments inside anonymous function compared passing map(). Putting anonymous function means evaluated every time f() executed, just call map(). easiest see make additional argument random:","code":"\nx <- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n#> [1] 3.0 5.5\nmap_dbl(x, mean, na.rm = TRUE)\n#> [1] 3.0 5.5\nplus <- function(x, y) x + y\n\nx <- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n#> [1] 0.0625 0.0625 0.0625 0.0625\nmap_dbl(x, ~ plus(.x, runif(1)))\n#> [1] 0.903 0.132 0.629 0.945"},{"path":"functionals.html","id":"argument-names","chapter":"1 Functionals","heading":"1.2.4 Argument names","text":"diagrams, ‚Äôve omitted argument names focus overall structure. recommend writing full names code, makes easier read. map(x, mean, 0.1) perfectly valid code, call mean(x[[1]], 0.1) relies reader remembering second argument mean() trim. avoid unnecessary burden brain reader4, kind write map(x, mean, trim = 0.1).reason arguments map() little odd: instead x f, .x .f. ‚Äôs easiest see problem leads names using simple_map() defined . simple_map() arguments x f ‚Äôll problems whenever function calling arguments x f:error little bewildering remember call simple_map() equivalent simple_map(x = mtcars, f = mean, bootstrap_summary) named matching beats positional matching.purrr functions reduce likelihood clash using .f .x instead common f x. course technique isn‚Äôt perfect (function calling might still use .f .x), avoids 99% issues. remaining 1% time, use anonymous function.Base functions pass along ... use variety naming conventions prevent undesired argument matching:apply family mostly uses capital letters (e.g.¬†X FUN).apply family mostly uses capital letters (e.g.¬†X FUN).transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection ??. makes undesired matches extremely\nunlikely.transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection ??. makes undesired matches extremely\nunlikely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.","code":"\nboostrap_summary <- function(x, f) {\n  f(sample(x, replace = TRUE))\n}\n\nsimple_map(mtcars, boostrap_summary, f = mean)\n#> Error in mean.default(x[[i]], ...): 'trim' must be numeric of length one"},{"path":"functionals.html","id":"change-argument","chapter":"1 Functionals","heading":"1.2.5 Varying another argument","text":"far first argument map() always become first argument function. happens first argument constant, want vary different argument? get result picture?turns ‚Äôs way directly, two tricks can use instead. illustrate , imagine vector contains unusual values, want explore effect different amounts trimming computing mean. case, first argument mean() constant, want vary second argument, trim.simplest technique use anonymous function rearrange \nargument order:\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nstill little confusing ‚Äôm using x .x.\ncan make little clearer abandoning ~ helper:\n\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502The simplest technique use anonymous function rearrange \nargument order:still little confusing ‚Äôm using x .x.\ncan make little clearer abandoning ~ helper:Sometimes, want () clever, can take advantage R‚Äôs\nflexible argument matching rules (described Section\n??). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :\n\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502\ndon‚Äôt recommend technique relies reader‚Äôs familiarity argument order .f, R‚Äôs\nargument matching rules.Sometimes, want () clever, can take advantage R‚Äôs\nflexible argument matching rules (described Section\n??). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :don‚Äôt recommend technique relies reader‚Äôs familiarity argument order .f, R‚Äôs\nargument matching rules.‚Äôll see one alternative Section 1.4.5.","code":"\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502"},{"path":"functionals.html","id":"exercises","chapter":"1 Functionals","heading":"1.2.6 Exercises","text":"Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?Use appropriate map() function :\nCompute standard deviation every column numeric data frame.\nCompute standard deviation every numeric column mixed data\nframe. (Hint: ‚Äôll need two steps.)\nCompute number levels every factor data frame.\nUse appropriate map() function :Compute standard deviation every column numeric data frame.Compute standard deviation every column numeric data frame.Compute standard deviation every numeric column mixed data\nframe. (Hint: ‚Äôll need two steps.)Compute standard deviation every numeric column mixed data\nframe. (Hint: ‚Äôll need two steps.)Compute number levels every factor data frame.Compute number levels every factor data frame.following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.\n\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?\n\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error .f(.x[[]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?Use map() fit linear models mtcars dataset using formulas\nstored list:\n\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ (1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ (1 / disp) + wt\n)Use map() fit linear models mtcars dataset using formulas\nstored list:Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)\n\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)","code":"\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error in .f(.x[[i]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))"},{"path":"functionals.html","id":"purrr-style","chapter":"1 Functionals","heading":"1.3 Purrr style","text":"go explore map variants, let‚Äôs take quick look tend use multiple purrr functions solve moderately realistic problem: fitting model subgroup extracting coefficient model. toy example, ‚Äôm going break mtcars data set groups defined number cylinders, using base split function:creates list three data frames: cars 4, 6, 8 cylinders respectively.Now imagine want fit linear model, extract second coefficient (.e.¬†slope). following code shows might purrr:(haven‚Äôt seen %>%, pipe, , ‚Äôs described Section ??.)think code easy read line encapsulates single step, can easily distinguish functional , purrr helpers allow us concisely describe step.attack problem base R? certainly replace purrr function equivalent base function:isn‚Äôt really base R since ‚Äôre using pipe. tackle purely base think ‚Äôd use intermediate variable, step:, course, use loop:‚Äôs interesting note move purrr base apply functions loops tend iteration. purrr iterate 3 times (map(), map(), map_dbl()), apply functions iterate twice (lapply(), vapply()), loop iterate . prefer , simpler, steps think makes code easier understand later modify.","code":"\nby_cyl <- split(mtcars, mtcars$cyl)\nby_cyl %>% \n  map(~ lm(mpg ~ wt, data = .x)) %>% \n  map(coef) %>% \n  map_dbl(2)\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nby_cyl %>% \n  lapply(function(data) lm(mpg ~ wt, data = data)) %>% \n  lapply(coef) %>% \n  vapply(function(x) x[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nmodels <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))\nvapply(models, function(x) coef(x)[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nslopes <- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model <- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] <- coef(model)[[2]]\n}\nslopes\n#> [1] -5.65 -2.78 -2.19"},{"path":"functionals.html","id":"map-variants","chapter":"1 Functionals","heading":"1.4 Map variants","text":"23 primary variants map(). far, ‚Äôve learned five (map(), map_lgl(), map_int(), map_dbl() map_chr()). means ‚Äôve got 18 (!!) learn. sounds like lot, fortunately design purrr means need learn five new ideas:Output type input modify()Iterate two inputs map2().Iterate index using imap()Return nothing walk().Iterate number inputs pmap().map family functions orthogonal input outputs, meaning can organise family matrix, inputs rows outputs columns. ‚Äôve mastered idea row, can combine column; ‚Äôve mastered idea column, can combine row. relationship summarised following table:","code":""},{"path":"functionals.html","id":"modify","chapter":"1 Functionals","heading":"1.4.1 Same type of output as input: modify()","text":"Imagine wanted double every column data frame. might first try using map(), map() always returns list:want keep output data frame, can use modify(), always returns type output input:Despite name, modify() doesn‚Äôt modify place, returns modified copy, wanted permanently modify df, ‚Äôd need assign :usual, basic implementation modify() simple, fact ‚Äôs even simpler map() don‚Äôt need create new output vector; can just progressively replace input. (real code little complex handle edge cases gracefully.)Section 1.6.2 ‚Äôll learn useful variant modify(), called modify_if(). allows (e.g.) double numeric columns data frame modify_if(df, .numeric, ~ .x * 2).","code":"\ndf <- data.frame(\n  x = 1:3,\n  y = 6:4\n)\n\nmap(df, ~ .x * 2)\n#> $x\n#> [1] 2 4 6\n#> \n#> $y\n#> [1] 12 10  8\nmodify(df, ~ .x * 2)\n#>   x  y\n#> 1 2 12\n#> 2 4 10\n#> 3 6  8\ndf <- modify(df, ~ .x * 2)\nsimple_modify <- function(x, f, ...) {\n  for (i in seq_along(x)) {\n    x[[i]] <- f(x[[i]], ...)\n  }\n  x\n}"},{"path":"functionals.html","id":"map2","chapter":"1 Functionals","heading":"1.4.2 Two inputs: map2() and friends","text":"map() vectorised single argument, .x. means varies .x calling .f, arguments passed along unchanged, thus making poorly suited problems. example, find weighted mean list observations list weights? Imagine following data:can use map_dbl() compute unweighted means:passing ws additional argument doesn‚Äôt work arguments .f transformed:need new tool: map2(), vectorised two arguments. means .x .y varied call .f:arguments map2() slightly different arguments map() two vectors come function, rather one. Additional arguments still go afterwards:basic implementation map2() simple, quite similar map(). Instead iterating one vector, iterate two parallel:One big differences map2() simple function map2() recycles inputs make sure ‚Äôre length:words, map2(x, y, f) automatically behave like map(x, f, y) needed. helpful writing functions; scripts ‚Äôd generally just use simpler form directly.closest base equivalent map2() Map(), discussed Section 1.4.5.","code":"\nxs <- map(1:8, ~ runif(10))\nxs[[1]][[1]] <- NA\nws <- map(1:8, ~ rpois(10, 5) + 1)\nmap_dbl(xs, mean)\n#> [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443\nmap_dbl(xs, weighted.mean, w = ws)\n#> Error in weighted.mean.default(.x[[i]], ...): 'x' and 'w' must have the same length\nmap2_dbl(xs, ws, weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nmap2_dbl(xs, ws, weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nsimple_map2 <- function(x, y, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], y[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"no-outputs-walk-and-friends","chapter":"1 Functionals","heading":"1.4.3 No outputs: walk() and friends","text":"functions called value return, makes sense capture store value map() function. functions called primarily side-effects (e.g.¬†cat(), write.csv(), ggsave()) doesn‚Äôt make sense capture results. Take simple example displays welcome message using cat(). cat() returns NULL, map() works (sense generates desired welcomes), also returns list(NULL, NULL).avoid problem assigning results map() variable never use, muddy intent code. Instead, purrr provides walk family functions ignore return values .f instead return .x invisibly5.visual depiction walk attempts capture important difference map(): outputs ephemeral, input returned invisibly.One useful walk() variants walk2() common side-effect saving something disk, saving something disk always pair values: object path want save .example, imagine list data frames (‚Äôve created using split()), ‚Äôd like save one separate CSV file. ‚Äôs easy walk2():walk2() equivalent write.csv(cyls[[1]], paths[[1]]), write.csv(cyls[[2]], paths[[2]]), write.csv(cyls[[3]], paths[[3]]).base equivalent walk(); either wrap result lapply() invisible() save variable never used.","code":"\nwelcome <- function(x) {\n  cat(\"Welcome \", x, \"!\\n\", sep = \"\")\n}\nnames <- c(\"Hadley\", \"Jenny\")\n\n# As well as generate the welcomes, it also shows \n# the return value of cat()\nmap(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> NULL\nwalk(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\ntemp <- tempfile()\ndir.create(temp)\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\ndir(temp)\n#> [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\""},{"path":"functionals.html","id":"iterating-over-values-and-indices","chapter":"1 Functionals","heading":"1.4.4 Iterating over values and indices","text":"three basic ways loop vector loop:Loop elements: (x xs)Loop numeric indices: (seq_along(xs))Loop names: (nm names(xs))first form analogous map() family. second third forms equivalent imap() family allows iterate values indices vector parallel.imap() like map2() sense .f gets called two arguments, derived vector. imap(x, f) equivalent map2(x, names(x), f) x names, map2(x, seq_along(x), f) .imap() often useful constructing labels:vector unnamed, second argument index:imap() useful helper want work values vector along positions.","code":"\nimap_chr(iris, ~ paste0(\"The first value of \", .y, \" is \", .x[[1]]))\n#>                             Sepal.Length \n#> \"The first value of Sepal.Length is 5.1\" \n#>                              Sepal.Width \n#>  \"The first value of Sepal.Width is 3.5\" \n#>                             Petal.Length \n#> \"The first value of Petal.Length is 1.4\" \n#>                              Petal.Width \n#>  \"The first value of Petal.Width is 0.2\" \n#>                                  Species \n#>   \"The first value of Species is setosa\"\nx <- map(1:6, ~ sample(1000, 10))\nimap_chr(x, ~ paste0(\"The highest value of \", .y, \" is \", max(.x)))\n#> [1] \"The highest value of 1 is 975\" \"The highest value of 2 is 915\"\n#> [3] \"The highest value of 3 is 982\" \"The highest value of 4 is 955\"\n#> [5] \"The highest value of 5 is 971\" \"The highest value of 6 is 696\""},{"path":"functionals.html","id":"pmap","chapter":"1 Functionals","heading":"1.4.5 Any number of inputs: pmap() and friends","text":"Since map() map2(), might expect map3(), map4(), map5(), ‚Ä¶ stop? Instead generalising map2() arbitrary number arguments, purrr takes slightly different tack pmap(): supply single list, contains number arguments. cases, list equal-length vectors, .e.¬†something similar data frame. diagrams, ‚Äôll emphasise relationship drawing input similar data frame.‚Äôs simple equivalence map2() pmap(): map2(x, y, f) pmap(list(x, y), f). pmap() equivalent map2_dbl(xs, ws, weighted.mean) used :, varying arguments come .f (although now must wrapped list), constant arguments come afterwards.big difference pmap() map functions pmap() gives much finer control argument matching can name components list. Returning example Section 1.2.5, wanted vary trim argument x, instead use pmap():think ‚Äôs good practice name components list make clear function called.‚Äôs often convenient call pmap() data frame. handy way create data frame tibble::tribble(), allows describe data frame row--row (rather column--column, usual): thinking parameters function data frame powerful pattern. following example shows might draw random uniform numbers varying parameters:\n, column names critical: ‚Äôve carefully chosen match arguments runif(), pmap(params, runif) equivalent runif(n = 1L, min = 0, max = 1), runif(n = 2, min = 10, max = 100), runif(n = 3L, min = 100, max = 1000). (data frame hand, names don‚Äôt match, use dplyr::rename() similar.)two base equivalents pmap() family: Map() mapply(). significant drawbacks:Map() vectorises arguments supply arguments \nvary.Map() vectorises arguments supply arguments \nvary.mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().","code":"\npmap_dbl(list(xs, ws), weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\npmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\n\npmap_dbl(list(trim = trims), mean, x = x)\n#> [1] -6.6740  0.0210  0.0235  0.0151\nparams <- tibble::tribble(\n  ~ n, ~ min, ~ max,\n   1L,     0,     1,\n   2L,    10,   100,\n   3L,   100,  1000\n)\n\npmap(params, runif)\n#> [[1]]\n#> [1] 0.332\n#> \n#> [[2]]\n#> [1] 53.5 47.6\n#> \n#> [[3]]\n#> [1] 231 715 515"},{"path":"functionals.html","id":"exercises-1","chapter":"1 Functionals","heading":"1.4.6 Exercises","text":"Explain results modify(mtcars, 1).Explain results modify(mtcars, 1).Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?Explain following code transforms data frame using functions\nstored list.\n\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nCompare contrast map2() approach map() approach:\n\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))Explain following code transforms data frame using functions\nstored list.Compare contrast map2() approach map() approach:write.csv() return, .e.¬†happens use \nmap2() instead walk2()?write.csv() return, .e.¬†happens use \nmap2() instead walk2()?","code":"\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))"},{"path":"functionals.html","id":"reduce","chapter":"1 Functionals","heading":"1.5 Reduce family","text":"map family, next important family functions reduce family. family much smaller, two main variants, used less commonly, ‚Äôs powerful idea, gives us opportunity discuss useful algebra, powers map-reduce framework frequently used processing large datasets.","code":""},{"path":"functionals.html","id":"basics","chapter":"1 Functionals","heading":"1.5.1 Basics","text":"reduce() takes vector length n produces vector length 1 calling function pair values time: reduce(1:4, f) equivalent f(f(f(1, 2), 3), 4).reduce() useful way generalise function works two inputs (binary function) work number inputs. Imagine list numeric vectors, want find values occur every element. First generate sample data:solve challenge need use intersect() repeatedly:reduce() automates solution us, can write:apply idea wanted list elements appear least one entry. switch intersect() union():Like map family, can also pass additional arguments. intersect() union() don‚Äôt take extra arguments can‚Äôt demonstrate , principle straightforward drew picture.usual, essence reduce() can reduced simple wrapper around loop:base equivalent Reduce(). Note argument order different: function comes first, followed vector, way supply additional arguments.","code":"\nl <- map(1:4, ~ sample(1:10, 15, replace = T))\nstr(l)\n#> List of 4\n#>  $ : int [1:15] 7 1 8 8 3 8 2 4 7 10 ...\n#>  $ : int [1:15] 3 1 10 2 5 2 9 8 5 4 ...\n#>  $ : int [1:15] 6 10 9 5 6 7 8 6 10 8 ...\n#>  $ : int [1:15] 9 8 6 4 4 5 2 9 9 6 ...\nout <- l[[1]]\nout <- intersect(out, l[[2]])\nout <- intersect(out, l[[3]])\nout <- intersect(out, l[[4]])\nout\n#> [1] 8 4\nreduce(l, intersect)\n#> [1] 8 4\nreduce(l, union)\n#>  [1]  7  1  8  3  2  4 10  5  9  6\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}"},{"path":"functionals.html","id":"accumulate","chapter":"1 Functionals","heading":"1.5.2 Accumulate","text":"first reduce() variant, accumulate(), useful understanding reduce works, instead returning just final result, returns intermediate results well:Another useful way understand reduce think sum(): sum(x) equivalent x[[1]] + x[[2]] + x[[3]] + ..., .e.¬†reduce(x, `+`). accumulate(x, `+`) cumulative sum:","code":"\naccumulate(l, intersect)\n#> [[1]]\n#>  [1]  7  1  8  8  3  8  2  4  7 10 10  3  7 10 10\n#> \n#> [[2]]\n#> [1]  1  8  3  2  4 10\n#> \n#> [[3]]\n#> [1]  8  4 10\n#> \n#> [[4]]\n#> [1] 8 4\nx <- c(4, 3, 10)\nreduce(x, `+`)\n#> [1] 17\n\naccumulate(x, `+`)\n#> [1]  4  7 17"},{"path":"functionals.html","id":"output-types","chapter":"1 Functionals","heading":"1.5.3 Output types","text":"example using +, reduce() return x short, .e.¬†length 1 0? Without additional arguments, reduce() just returns input x length 1:means reduce() way check input valid:‚Äôs length 0? get error suggests need use .init argument:.init ? figure , need see happens .init supplied:call reduce(1, `+`, init) result 1 + init. Now know result just 1, suggests .init 0:also ensures reduce() checks length 1 inputs valid function ‚Äôre calling:want get algebraic , 0 called identity real numbers operation addition: add 0 number, get number back. R applies principle determine summary function zero length input return:‚Äôre using reduce() function, always supply .init. Think carefully function return pass vector length 0 1, make sure test implementation.","code":"\nreduce(1, `+`)\n#> [1] 1\nreduce(\"a\", `+`)\n#> [1] \"a\"\nreduce(integer(), `+`)\n#> Error: `.x` is empty, and no `.init` supplied\nreduce(integer(), `+`, .init = 0)\n#> [1] 0\nreduce(\"a\", `+`, .init = 0)\n#> Error in .x + .y: non-numeric argument to binary operator\nsum(integer())  # x + 0 = x\n#> [1] 0\nprod(integer()) # x * 1 = x\n#> [1] 1\nmin(integer())  # min(x, Inf) = x\n#> [1] Inf\nmax(integer())  # max(x, -Inf) = x\n#> [1] -Inf"},{"path":"functionals.html","id":"multiple-inputs","chapter":"1 Functionals","heading":"1.5.4 Multiple inputs","text":"occasionally need pass two arguments function ‚Äôre reducing. example, might list data frames want join together, variables use join vary element element. specialised scenario, don‚Äôt want spend much time , want know reduce2() exists.length second argument varies based whether .init supplied: four elements x, f called three times. supply init, f called four times.","code":""},{"path":"functionals.html","id":"map-reduce","chapter":"1 Functionals","heading":"1.5.5 Map-reduce","text":"might heard map-reduce, idea powers technology like Hadoop. Now can see simple powerful underlying idea : map-reduce map combined reduce. difference large data data spread multiple computers. computer performs map data , sends result back coordinator reduces individual results back single result.simple example, imagine computing mean large vector, large split multiple computers. ask computer calculate sum length, return coordinator computes overall mean dividing total sum total length.","code":""},{"path":"functionals.html","id":"predicate-functionals","chapter":"1 Functionals","heading":"1.6 Predicate functionals","text":"\npredicate function returns single TRUE FALSE, like .character(), .null(), (), say predicate matches vector returns TRUE.","code":""},{"path":"functionals.html","id":"basics-1","chapter":"1 Functionals","heading":"1.6.1 Basics","text":"predicate functional applies predicate element vector. purrr provides seven useful functions come three groups:(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.\nsimilar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.similar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.following example shows might use functionals data frame:","code":"\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\ndetect(df, is.factor)\n#> NULL\ndetect_index(df, is.factor)\n#> [1] 0\n\nstr(keep(df, is.factor))\n#> 'data.frame':    3 obs. of  0 variables\nstr(discard(df, is.factor))\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ x: int  1 2 3\n#>  $ y: chr  \"a\" \"b\" \"c\""},{"path":"functionals.html","id":"predicate-map","chapter":"1 Functionals","heading":"1.6.2 Map variants","text":"map() modify() come variants also take predicate functions, transforming elements .x .p TRUE.","code":"\ndf <- data.frame(\n  num1 = c(0, 10, 20),\n  num2 = c(5, 6, 7),\n  chr1 = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\n\nstr(map_if(df, is.numeric, mean))\n#> List of 3\n#>  $ num1: num 10\n#>  $ num2: num 6\n#>  $ chr1: chr [1:3] \"a\" \"b\" \"c\"\nstr(modify_if(df, is.numeric, mean))\n#> 'data.frame':    3 obs. of  3 variables:\n#>  $ num1: num  10 10 10\n#>  $ num2: num  6 6 6\n#>  $ chr1: chr  \"a\" \"b\" \"c\"\nstr(map(keep(df, is.numeric), mean))\n#> List of 2\n#>  $ num1: num 10\n#>  $ num2: num 6"},{"path":"functionals.html","id":"exercises-2","chapter":"1 Functionals","heading":"1.6.3 Exercises","text":"isn‚Äôt .na() predicate function? base R function closest\npredicate version .na()?isn‚Äôt .na() predicate function? base R function closest\npredicate version .na()?simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .\n\nsimple_reduce <- function(x, f) {\n  <- x[[1]]\n  (seq(2, length(x))) {\n    <- f(, x[[]])\n  }\n  \n}simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?\n\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?","code":"\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}"},{"path":"functionals.html","id":"base-functionals","chapter":"1 Functionals","heading":"1.7 Base functionals","text":"finish chapter, provide survey important base functionals members map, reduce, predicate families, hence equivalent purrr. say ‚Äôre important, mathematical statistical flavour, generally less useful data analysis.","code":""},{"path":"functionals.html","id":"matrices-and-arrays","chapter":"1 Functionals","heading":"1.7.1 Matrices and arrays","text":"map() friends specialised work one-dimensional vectors. base::apply() specialised work two-dimensional higher vectors, .e.¬†matrices arrays. can think apply() operation summarises matrix array collapsing row column single value. four arguments:X, matrix array summarise.X, matrix array summarise.MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)FUN, summary function.FUN, summary function.... arguments passed FUN.... arguments passed FUN.typical example apply() looks like thisYou can specify multiple dimensions MARGIN, useful high-dimensional arrays:two caveats using apply():Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().apply() also idempotent sense summary\nfunction identity operator, output always \ninput.\n\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUEapply() also idempotent sense summary\nfunction identity operator, output always \ninput.Never use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.\n\ndf <- data.frame(x = 1:3, y = c(\"\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n#>  x  y \n#> NA NANever use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.","code":"\na2d <- matrix(1:20, nrow = 5)\napply(a2d, 1, mean)\n#> [1]  8.5  9.5 10.5 11.5 12.5\napply(a2d, 2, mean)\n#> [1]  3  8 13 18\na3d <- array(1:24, c(2, 3, 4))\napply(a3d, 1, mean)\n#> [1] 12 13\napply(a3d, c(1, 2), mean)\n#>      [,1] [,2] [,3]\n#> [1,]   10   12   14\n#> [2,]   11   13   15\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUE\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n#>  x  y \n#> NA NA"},{"path":"functionals.html","id":"mathematical-concerns","chapter":"1 Functionals","heading":"1.7.2 Mathematical concerns","text":"Functionals common mathematics. limit, maximum, roots (set points f(x) = 0), definite integral functionals: given function, return single number (vector numbers). first glance, functions don‚Äôt seem fit theme eliminating loops, dig deeper ‚Äôll find implemented using algorithm involves iteration.Base R provides useful set:integrate() finds area curve defined f()uniroot() finds f() hits zerooptimise() finds location lowest (highest) value f()following example shows functionals might used simple function, sin():","code":"\nintegrate(sin, 0, pi)\n#> 2 with absolute error < 2.2e-14\nstr(uniroot(sin, pi * c(1 / 2, 3 / 2)))\n#> List of 5\n#>  $ root      : num 3.14\n#>  $ f.root    : num 1.22e-16\n#>  $ iter      : int 2\n#>  $ init.it   : int NA\n#>  $ estim.prec: num 6.1e-05\nstr(optimise(sin, c(0, 2 * pi)))\n#> List of 2\n#>  $ minimum  : num 4.71\n#>  $ objective: num -1\nstr(optimise(sin, c(0, pi), maximum = TRUE))\n#> List of 2\n#>  $ maximum  : num 1.57\n#>  $ objective: num 1"},{"path":"functionals.html","id":"exercises-3","chapter":"1 Functionals","heading":"1.7.3 Exercises","text":"apply() arrange output? Read documentation perform\nexperiments.apply() arrange output? Read documentation perform\nexperiments.eapply() rapply() ? purrr equivalents?eapply() rapply() ? purrr equivalents?Challenge: read \nfixed point algorithm.\nComplete exercises using R.Challenge: read \nfixed point algorithm.\nComplete exercises using R.","code":""},{"path":"function-factories.html","id":"function-factories","chapter":"2 Function factories","heading":"2 Function factories","text":"","code":""},{"path":"function-factories.html","id":"introduction-1","chapter":"2 Function factories","heading":"2.1 Introduction","text":"function factory function makes functions. ‚Äôs simple example: use function factory (power1()) make two child functions (square() cube()):Don‚Äôt worry doesn‚Äôt make sense yet, end chapter!\n\n‚Äôll call square() cube() manufactured functions, just term ease communication humans: R‚Äôs perspective different functions created way.already learned individual components make function factories possible:Section ??, learned R‚Äôs first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section ??, learned R‚Äôs first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section ??, learned function\ncaptures (encloses) environment created.Section ??, learned function\ncaptures (encloses) environment created.Section ??, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.Section ??, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.chapter, ‚Äôll learn non-obvious combination three features leads function factory. ‚Äôll also see examples usage visualisation statistics.three main functional programming tools (functionals, function factories, function operators), function factories least used. Generally, don‚Äôt tend reduce overall code complexity instead partition complexity easily digested chunks. Function factories also important building block useful function operators, ‚Äôll learn Chapter 3.","code":"\npower1 <- function(exp) {\n  function(x) {\n    x ^ exp\n  }\n}\n\nsquare <- power1(2)\ncube <- power1(3)\nsquare(3)\n#> [1] 9\ncube(3)\n#> [1] 27"},{"path":"function-factories.html","id":"outline-1","chapter":"2 Function factories","heading":"Outline","text":"Section 2.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ‚Äôll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 2.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ‚Äôll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 2.3 illustrates use function factories \nexamples ggplot2. ‚Äôll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 2.3 illustrates use function factories \nexamples ggplot2. ‚Äôll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 2.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 2.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 2.5 shows can combine function\nfactories functionals rapidly generate family functions data.Section 2.5 shows can combine function\nfactories functionals rapidly generate family functions data.","code":""},{"path":"function-factories.html","id":"prerequisites-1","chapter":"2 Function factories","heading":"Prerequisites","text":"Make sure ‚Äôre familiar contents Sections ?? (first-class functions), ?? (function environment), ?? (execution environments) mentioned .Function factories need base R. ‚Äôll use little rlang peek inside easily, ‚Äôll use ggplot2 scales explore use function factories visualisation.","code":"\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(scales)"},{"path":"function-factories.html","id":"factory-fundamentals","chapter":"2 Function factories","heading":"2.2 Factory fundamentals","text":"key idea makes function factories work can expressed concisely:enclosing environment manufactured function execution\nenvironment function factory.takes words express big ideas, takes lot work really understand means. section help put pieces together interactive exploration diagrams.","code":""},{"path":"function-factories.html","id":"environments","chapter":"2 Function factories","heading":"2.2.1 Environments","text":"Let‚Äôs start taking look square() cube():‚Äôs obvious x comes , R find value associated exp? Simply printing manufactured functions revealing bodies identical; contents enclosing environment important factors. can get little insight using rlang::env_print(). shows us two different environments (originally execution environment power1()). environments parent, enclosing environment power1(), global environment.env_print() shows us environments binding exp, want see value6. can first getting environment function, extracting values:makes manufactured functions behave differently one another: names enclosing environment bound different values.","code":"\nsquare\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <environment: 0x55d1f510b598>\n\ncube\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x55d1f5235450>\n#> <environment: 0x55d1f51541c0>\nenv_print(square)\n#> <environment: 0x55d1f510b598>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\n\nenv_print(cube)\n#> <environment: 0x55d1f51541c0>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\nfn_env(square)$exp\n#> [1] 2\n\nfn_env(cube)$exp\n#> [1] 3"},{"path":"function-factories.html","id":"diagram-conventions","chapter":"2 Function factories","heading":"2.2.2 Diagram conventions","text":"can also show relationships diagram:‚Äôs lot going diagram details aren‚Äôt important. can simplify considerably using two conventions:free floating symbol lives global environment.free floating symbol lives global environment.environment without explicit parent inherits global\nenvironment.environment without explicit parent inherits global\nenvironment.view, focuses environments, doesn‚Äôt show direct link cube() square(). ‚Äôs link body function, identical , shown diagram.finish , let‚Äôs look execution environment square(10). square() executes x ^ exp finds x execution environment exp enclosing environment.","code":"\nsquare(10)\n#> [1] 100"},{"path":"function-factories.html","id":"forcing-evaluation","chapter":"2 Function factories","heading":"2.2.3 Forcing evaluation","text":"‚Äôs subtle bug power1() caused lazy evaluation. see problem need introduce indirection:square(2) return? hope returns 4:Unfortunately doesn‚Äôt x evaluated lazily square() run, power1() run. general, problem arise whenever binding changes calling factory function calling manufactured function. likely happen rarely, , lead real head-scratcher bug.can fix problem forcing evaluation force():Whenever create function factory, make sure every argument evaluated, using force() necessary argument used manufactured function.","code":"\nx <- 2\nsquare <- power1(x)\nx <- 3\nsquare(2)\n#> [1] 8\npower2 <- function(exp) {\n  force(exp)\n  function(x) {\n    x ^ exp\n  }\n}\n\nx <- 2\nsquare <- power2(x)\nx <- 3\nsquare(2)\n#> [1] 4"},{"path":"function-factories.html","id":"stateful-funs","chapter":"2 Function factories","heading":"2.2.4 Stateful functions","text":"Function factories also allow maintain state across function invocations, generally hard fresh start principle described Section ??.two things make possible:enclosing environment manufactured function unique constant.enclosing environment manufactured function unique constant.R special assignment operator, <<-, modifies bindings \nenclosing environment.R special assignment operator, <<-, modifies bindings \nenclosing environment.usual assignment operator, <-, always creates binding current environment. super assignment operator, <<- rebinds existing name found parent environment.following example shows can combine ideas create function records many times called:manufactured function run <<- + 1 modify enclosing environment. manufactured functions independent enclosing environments, independent counts:Stateful functions best used moderation. soon function starts managing state multiple variables, ‚Äôs better switch R6, topic Chapter ??.","code":"\nnew_counter <- function() {\n  i <- 0\n  \n  function() {\n    i <<- i + 1\n    i\n  }\n}\n\ncounter_one <- new_counter()\ncounter_two <- new_counter()\ncounter_one()\n#> [1] 1\ncounter_one()\n#> [1] 2\ncounter_two()\n#> [1] 1"},{"path":"function-factories.html","id":"factory-pitfalls","chapter":"2 Function factories","heading":"2.2.5 Garbage collection","text":"functions, can rely garbage collector clean large temporary objects created inside function. However, manufactured functions hold execution environment, ‚Äôll need explicitly unbind large temporary objects rm(). Compare sizes g1() g2() example :","code":"\nf1 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  function() m\n}\n\ng1 <- f1(1e6)\nlobstr::obj_size(g1)\n#> 8,013,104 B\n\nf2 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  rm(x)\n  function() m\n}\n\ng2 <- f2(1e6)\nlobstr::obj_size(g2)\n#> 12,944 B"},{"path":"function-factories.html","id":"exercises-4","chapter":"2 Function factories","heading":"2.2.6 Exercises","text":"definition force() simple:\n\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x55d1f1342d40>\n#> <environment: namespace:base>\nbetter force(x) instead just x?definition force() simple:better force(x) instead just x?Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Create function pick() takes index, , argument \nreturns function argument x subsets x .\n\npick(1)(x)\n# equivalent \nx[[1]]\n\nlapply(mtcars, pick(5))\n# equivalent \nlapply(mtcars, function(x) x[[5]])Create function pick() takes index, , argument \nreturns function argument x subsets x .Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:\n\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(.equal(m1(x), 0))\nstopifnot(.equal(m2(x), var(x) * 99 / 100))Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:happens don‚Äôt use closure? Make predictions, verify \ncode .\n\n<- 0\nnew_counter2 <- function() {\n  <<- + 1\n  \n}happens don‚Äôt use closure? Make predictions, verify \ncode .happens use <- instead <<-? Make predictions, verify\ncode .\n\nnew_counter3 <- function() {\n  <- 0\n  function() {\n    <- + 1\n    \n  }\n}happens use <- instead <<-? Make predictions, verify\ncode .","code":"\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x55d1f1342d40>\n#> <environment: namespace:base>\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\ni <- 0\nnew_counter2 <- function() {\n  i <<- i + 1\n  i\n}\nnew_counter3 <- function() {\n  i <- 0\n  function() {\n    i <- i + 1\n    i\n  }\n}"},{"path":"function-factories.html","id":"graph-fact","chapter":"2 Function factories","heading":"2.3 Graphical factories","text":"‚Äôll begin exploration useful function factories examples ggplot2.","code":""},{"path":"function-factories.html","id":"labelling","chapter":"2 Function factories","heading":"2.3.1 Labelling","text":"One goals scales package make easy customise labels ggplot2. provides many functions control fine details axes legends. formatter functions7 useful class functions make easier control appearance axis breaks. design functions might initially seem little odd: return function, call order format number.words, primary interface function factory. first glance, seems add extra complexity little gain. enables nice interaction ggplot2‚Äôs scales, accept functions label argument:","code":"\ny <- c(12345, 123456, 1234567)\ncomma_format()(y)\n#> [1] \"12,345\"    \"123,456\"   \"1,234,567\"\n\nnumber_format(scale = 1e-3, suffix = \" K\")(y)\n#> [1] \"12 K\"    \"123 K\"   \"1 235 K\"\ndf <- data.frame(x = 1, y = y)\ncore <- ggplot(df, aes(x, y)) + \n  geom_point() + \n  scale_x_continuous(breaks = 1, labels = NULL) +\n  labs(x = NULL, y = NULL)\n  \ncore\ncore + scale_y_continuous(\n  labels = comma_format()\n)\ncore + scale_y_continuous(\n  labels = number_format(scale = 1e-3, suffix = \" K\")\n)\ncore + scale_y_continuous(\n  labels = scientific_format()\n)"},{"path":"function-factories.html","id":"histogram-bins","chapter":"2 Function factories","heading":"2.3.2 Histogram bins","text":"little known feature geom_histogram() binwidth argument can function. particularly useful function executed group, means can different binwidths different facets, otherwise possible.illustrate idea, see variable binwidth might useful, ‚Äôm going construct example fixed binwidth isn‚Äôt great.facet number observations, variability different. nice request binwidths vary get approximately number observations bin. One way function factory inputs desired number bins (n), outputs function takes numeric vector returns binwidth:use pattern wrap around base R functions automatically find -called optimal8 binwidth, nclass.Sturges(), nclass.scott(), nclass.FD():","code":"\n# construct some sample data with very different numbers in each cell\nsd <- c(1, 5, 15)\nn <- 100\n\ndf <- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbinwidth_bins <- function(n) {\n  force(n)\n  \n  function(x) {\n    (max(x) - min(x)) / n\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = binwidth_bins(20)) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbase_bins <- function(type) {\n  fun <- switch(type,\n    Sturges = nclass.Sturges,\n    scott = nclass.scott,\n    FD = nclass.FD,\n    stop(\"Unknown type\", call. = FALSE)\n  )\n  \n  function(x) {\n    (max(x) - min(x)) / fun(x)\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = base_bins(\"FD\")) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)"},{"path":"function-factories.html","id":"ggsave","chapter":"2 Function factories","heading":"2.3.3 ggsave()","text":"Finally, want show function factory used internally ggplot2. ggplot2:::plot_dev() used ggsave() go file extension (e.g.¬†png, jpeg etc) graphics device function (e.g.¬†png(), jpeg()). challenge arises base graphics devices minor inconsistencies need paper :filename first argument file.filename first argument file.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.mildly simplified version plot_dev() shown :","code":"\nplot_dev <- function(ext, dpi = 96) {\n  force(dpi)\n  \n  switch(ext,\n    eps =  ,\n    ps  =  function(path, ...) {\n      grDevices::postscript(\n        file = filename, ..., onefile = FALSE, \n        horizontal = FALSE, paper = \"special\"\n      )\n    },\n    pdf = function(filename, ...) grDevices::pdf(file = filename, ...),\n    svg = function(filename, ...) svglite::svglite(file = filename, ...),\n    emf = ,\n    wmf = function(...) grDevices::win.metafile(...),\n    png = function(...) grDevices::png(..., res = dpi, units = \"in\"),\n    jpg = ,\n    jpeg = function(...) grDevices::jpeg(..., res = dpi, units = \"in\"),\n    bmp = function(...) grDevices::bmp(..., res = dpi, units = \"in\"),\n    tiff = function(...) grDevices::tiff(..., res = dpi, units = \"in\"),\n    stop(\"Unknown graphics extension: \", ext, call. = FALSE)\n  )\n}\n\nplot_dev(\"pdf\")\n#> function(filename, ...) grDevices::pdf(file = filename, ...)\n#> <bytecode: 0x55d1f5f04150>\n#> <environment: 0x55d1f62b0728>\nplot_dev(\"png\")\n#> function(...) grDevices::png(..., res = dpi, units = \"in\")\n#> <bytecode: 0x55d1f5cc6c30>\n#> <environment: 0x55d1f59505b0>"},{"path":"function-factories.html","id":"exercises-5","chapter":"2 Function factories","heading":"2.3.4 Exercises","text":"Compare contrast ggplot2::label_bquote() \nscales::number_format()","code":""},{"path":"function-factories.html","id":"stat-fact","chapter":"2 Function factories","heading":"2.4 Statistical factories","text":"motivating examples function factories come statistics:Box-Cox transformation.Bootstrap resampling.Maximum likelihood estimation.examples can tackled without function factories, think function factories good fit problems provide elegant solutions. examples expect statistical background, feel free skip don‚Äôt make much sense .","code":""},{"path":"function-factories.html","id":"box-cox-transformation","chapter":"2 Function factories","heading":"2.4.1 Box-Cox transformation","text":"Box-Cox transformation (type power transformation) flexible transformation often used transform data towards normality. single parameter, \\(\\lambda\\), controls strength transformation. express transformation simple two argument function:re-formulating function factory makes easy explore behaviour stat_function():general, allows use Box-Cox transformation function accepts unary transformation function: don‚Äôt worry function providing ... pass along additional arguments. also think partitioning lambda x two different function arguments natural since lambda plays quite different role x.","code":"\nboxcox1 <- function(x, lambda) {\n  stopifnot(length(lambda) == 1)\n  \n  if (lambda == 0) {\n    log(x)\n  } else {\n    (x ^ lambda - 1) / lambda\n  }\n}\nboxcox2 <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}\n\nstat_boxcox <- function(lambda) {\n  stat_function(aes(colour = lambda), fun = boxcox2(lambda), size = 1)\n}\n\nggplot(data.frame(x = c(0, 5)), aes(x)) + \n  lapply(c(0.5, 1, 1.5), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))\n\n# visually, log() does seem to make sense as the transformation\n# for lambda = 0; as values get smaller and smaller, the function\n# gets close and closer to a log transformation\nggplot(data.frame(x = c(0.01, 1)), aes(x)) + \n  lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))"},{"path":"function-factories.html","id":"bootstrap-generators","chapter":"2 Function factories","heading":"2.4.2 Bootstrap generators","text":"Function factories useful approach bootstrapping. Instead thinking single bootstrap (always need one!), can think bootstrap generator, function yields fresh bootstrap every time called:advantage function factory clear parametric bootstrap first fit model. can setup step , factory called, rather every time generate bootstrap:use rm(mod) linear model objects quite large (include complete copies model matrix input data) want keep manufactured function small possible.","code":"\nboot_permute <- function(df, var) {\n  n <- nrow(df)\n  force(var)\n  \n  function() {\n    col <- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nboot_mtcars1 <- boot_permute(mtcars, \"mpg\")\nhead(boot_mtcars1())\n#> [1] 16.4 22.8 22.8 22.8 16.4 19.2\nhead(boot_mtcars1())\n#> [1] 17.8 18.7 30.4 30.4 16.4 21.0\nboot_model <- function(df, formula) {\n  mod <- lm(formula, data = df)\n  fitted <- unname(fitted(mod))\n  resid <- unname(resid(mod))\n  rm(mod)\n\n  function() {\n    fitted + sample(resid)\n  }\n} \n\nboot_mtcars2 <- boot_model(mtcars, mpg ~ wt)\nhead(boot_mtcars2())\n#> [1] 25.0 24.0 21.7 19.2 24.9 16.0\nhead(boot_mtcars2())\n#> [1] 27.4 21.0 20.3 19.4 16.3 21.3"},{"path":"function-factories.html","id":"MLE","chapter":"2 Function factories","heading":"2.4.3 Maximum likelihood estimation","text":"\n\ngoal maximum likelihood estimation (MLE) find parameter values distribution make observed data likely. MLE, start probability function. example, take Poisson distribution. know \\(\\lambda\\), can compute probability getting vector \\(\\mathbf{x}\\) values (\\(x_1\\), \\(x_2\\), ‚Ä¶, \\(x_n\\)) multiplying Poisson probability function follows:\\[ P(\\lambda, \\mathbf{x}) = \\prod_{=1}^{n} \\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!} \\]statistics, almost always work log function. log monotonic transformation preserves important properties (.e.¬†extrema occur place), specific advantages:log turns product sum, easier work .log turns product sum, easier work .Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Let‚Äôs apply log transformation probability function simplify much possible:\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\log(\\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!}) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\left( x_i \\log(\\lambda) - \\lambda - \\log(x_i!) \\right) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n     \\sum_{=1}^{n} x_i \\log(\\lambda)\n   - \\sum_{=1}^{n} \\lambda \n   - \\sum_{=1}^{n} \\log(x_i!) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n   \\log(\\lambda) \\sum_{=1}^{n} x_i - n \\lambda - \\sum_{=1}^{n} \\log(x_i!) \\]can now turn function R function. R function quite elegant R vectorised , ‚Äôs statistical programming language, R comes built-functions like log-factorial (lfactorial()).Consider vector observations:can use lprob_poisson() compute (logged) probability x1 different values lambda.far ‚Äôve thinking lambda fixed known function told us probability getting different values x. real-life, observe x lambda unknown. likelihood probability function seen lens: want find lambda makes observed x likely. , given x, value lambda gives us highest value lprob_poisson()?statistics, highlight change perspective writing \\(f_{\\mathbf{x}}(\\lambda)\\) instead \\(f(\\lambda, \\mathbf{x})\\). R, can use function factory. provide x generate function single parameter, lambda:(don‚Äôt need force() length() implicitly forces evaluation x.)One nice thing approach can precomputation: term involves x can computed factory. useful ‚Äôre going need call function many times find best lambda.Now can use function find value lambda maximizes (log) likelihood:Rather trial error, can automate process finding best value optimise(). evaluate ll1() many times, using mathematical tricks narrow largest value quickly possible. results tell us highest value -30.27 occurs lambda = 32.1:Now, solved problem without using function factory optimise() passes ... function optimised. means use log-probability function directly:advantage using function factory fairly small, two niceties:can precompute values factory, saving computation time\niteration.can precompute values factory, saving computation time\niteration.two-level design better reflects mathematical structure \nunderlying problem.two-level design better reflects mathematical structure \nunderlying problem.advantages get bigger complex MLE problems, multiple parameters multiple data vectors.","code":"\nlprob_poisson <- function(lambda, x) {\n  n <- length(x)\n  (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x))\n}\nx1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\nlprob_poisson(10, x1)\n#> [1] -184\nlprob_poisson(20, x1)\n#> [1] -61.1\nlprob_poisson(30, x1)\n#> [1] -31\nll_poisson1 <- function(x) {\n  n <- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\nll_poisson2 <- function(x) {\n  n <- length(x)\n  sum_x <- sum(x)\n  c <- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\nll1 <- ll_poisson2(x1)\n\nll1(10)\n#> [1] -184\nll1(20)\n#> [1] -61.1\nll1(30)\n#> [1] -31\noptimise(ll1, c(0, 100), maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3\noptimise(lprob_poisson, c(0, 100), x = x1, maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3"},{"path":"function-factories.html","id":"exercises-6","chapter":"2 Function factories","heading":"2.4.4 Exercises","text":"boot_model(), don‚Äôt need force evaluation df\nmodel?boot_model(), don‚Äôt need force evaluation df\nmodel?might formulate Box-Cox transformation like ?\n\nboxcox3 <- function(x) {\n  function(lambda) {\n    (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}might formulate Box-Cox transformation like ?don‚Äôt need worry boot_permute() stores copy \ndata inside function generates?don‚Äôt need worry boot_permute() stores copy \ndata inside function generates?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?","code":"\nboxcox3 <- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}"},{"path":"function-factories.html","id":"functional-factories","chapter":"2 Function factories","heading":"2.5 Function factories + functionals","text":"finish chapter, ‚Äôll show might combine functionals function factories turn data many functions. following code creates many specially named power functions iterating list arguments:idea extends straightforward way function factory takes two (replace map() map2()) (replace pmap()) arguments.One downside current construction prefix every function call funs$. three ways eliminate additional syntax:temporary effect, can use ():\n\n(funs, root(100))\n#> [1] 10\nrecommend makes clear code \nexecuted special context context .temporary effect, can use ():recommend makes clear code \nexecuted special context context .longer effect, can attach() functions search path,\ndetach() ‚Äôre done:\n\nattach(funs)\n#> following objects masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\n‚Äôve probably told avoid using attach(), ‚Äôs generally\ngood advice. However, situation little different usual\n‚Äôre attaching list functions, data frame. ‚Äôs less\nlikely ‚Äôll modify function column data frame, \nworst problems attach() don‚Äôt apply.longer effect, can attach() functions search path,\ndetach() ‚Äôre done:‚Äôve probably told avoid using attach(), ‚Äôs generally\ngood advice. However, situation little different usual\n‚Äôre attaching list functions, data frame. ‚Äôs less\nlikely ‚Äôll modify function column data frame, \nworst problems attach() don‚Äôt apply.Finally, copy functions global environment \nenv_bind() (‚Äôll learn !!! Section ??).\nmostly permanent:\n\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\ncan later unbind names, ‚Äôs guarantee \nhaven‚Äôt rebound meantime, might deleting \nobject someone else created.\n\nrlang::env_unbind(globalenv(), names(funs))Finally, copy functions global environment \nenv_bind() (‚Äôll learn !!! Section ??).\nmostly permanent:can later unbind names, ‚Äôs guarantee \nhaven‚Äôt rebound meantime, might deleting \nobject someone else created.‚Äôll learn alternative approach problem Section ??. Instead using function factory, construct function quasiquotation. requires additional knowledge, generates functions readable bodies, avoids accidentally capturing large objects enclosing scope. use idea Section ?? work tools generating HTML R.","code":"\nnames <- list(\n  square = 2, \n  cube = 3, \n  root = 1/2, \n  cuberoot = 1/3, \n  reciprocal = -1\n)\nfuns <- purrr::map(names, power1)\n\nfuns$root(64)\n#> [1] 8\nfuns$root\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x55d1f5235450>\n#> <environment: 0x55d1f7d01378>\nwith(funs, root(100))\n#> [1] 10\nattach(funs)\n#> The following objects are masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\nrlang::env_unbind(globalenv(), names(funs))"},{"path":"function-factories.html","id":"exercises-7","chapter":"2 Function factories","heading":"2.5.1 Exercises","text":"following commands equivalent (x, f(z))?\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\ndepends.\nfollowing commands equivalent (x, f(z))?x$f(x$z).f(x$z).x$f(z).f(z).depends.Compare contrast effects env_bind() vs.¬†attach() \nfollowing code.\n\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> following objects masked package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))Compare contrast effects env_bind() vs.¬†attach() \nfollowing code.","code":"\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> The following objects are masked from package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))"},{"path":"function-operators.html","id":"function-operators","chapter":"3 Function operators","heading":"3 Function operators","text":"","code":""},{"path":"function-operators.html","id":"introduction-2","chapter":"3 Function operators","heading":"3.1 Introduction","text":"chapter, ‚Äôll learn function operators. function operator function takes one () functions input returns function output. following code shows simple function operator, chatty(). wraps function, making new function prints first argument. might create function like gives window see functionals, like map_int(), work.Function operators closely related function factories; indeed ‚Äôre just function factory takes function input. Like factories, ‚Äôs nothing can‚Äôt without , often allow factor complexity order make code readable reusable.Function operators typically paired functionals. ‚Äôre using -loop, ‚Äôs rarely reason use function operator, make code complex little gain.‚Äôre familiar Python, decorators just another name function operators.","code":"\nchatty <- function(f) {\n  force(f)\n  \n  function(x, ...) {\n    res <- f(x, ...)\n    cat(\"Processing \", x, \"\\n\", sep = \"\")\n    res\n  }\n}\nf <- function(x) x ^ 2\ns <- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n#> Processing 3\n#> Processing 2\n#> Processing 1\n#> [1] 9 4 1"},{"path":"function-operators.html","id":"outline-2","chapter":"3 Function operators","heading":"Outline","text":"Section 3.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 3.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 3.3 works problem amenable solution\nfunction operators: downloading many web pages.Section 3.3 works problem amenable solution\nfunction operators: downloading many web pages.","code":""},{"path":"function-operators.html","id":"prerequisites-2","chapter":"3 Function operators","heading":"Prerequisites","text":"Function operators type function factory, make sure ‚Äôre familiar least Section ?? go .‚Äôll use purrr couple functionals learned Chapter 1, function operators ‚Äôll learn . ‚Äôll also use memoise package9 memoise() operator.","code":"\nlibrary(purrr)\nlibrary(memoise)"},{"path":"function-operators.html","id":"existing-fos","chapter":"3 Function operators","heading":"3.2 Existing function operators","text":"two useful function operators help solve common recurring problems, give sense function operators can : purrr::safely() memoise::memoise().","code":""},{"path":"function-operators.html","id":"safely","chapter":"3 Function operators","heading":"3.2.1 Capturing errors with purrr::safely()","text":"One advantage -loops one iterations fails, can still access results failure:thing functional, get output, making hard figure problem lies:purrr::safely() provides tool help problem. safely() function operator transforms function turn errors data. (can learn basic idea makes work Section ??.) Let‚Äôs start taking look outside map_dbl():Like function operators, safely() takes function returns wrapped function can call usual:can see function transformed safely() always returns list two elements, result error. function runs successfully, error NULL result contains result; function fails, result NULL error contains error.Now lets use safely() functional:output slightly inconvenient form, since four lists, list containing result error. can make output easier use turning ‚Äúinside-‚Äù purrr::transpose(), get list results list errors:Now can easily find results worked, inputs failed:can use technique many different situations. example, imagine ‚Äôre fitting generalised linear model (GLM) list data frames. GLMs can sometimes fail optimisation problems, still want able try fit models, later look back failed:think great example power combining functionals function operators: safely() lets succinctly express need solve common data analysis problem.purrr comes three function operators similar vein:possibly(): returns default value ‚Äôs error.\nprovides way tell error occured , ‚Äôs best\nreserved cases ‚Äôs obvious sentinel value (like NA).possibly(): returns default value ‚Äôs error.\nprovides way tell error occured , ‚Äôs best\nreserved cases ‚Äôs obvious sentinel value (like NA).quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.auto_browser(): automatically executes browser() inside \nfunction ‚Äôs error.auto_browser(): automatically executes browser() inside \nfunction ‚Äôs error.See documentation details.","code":"\nx <- list(\n  c(0.512, 0.165, 0.717),\n  c(0.064, 0.781, 0.427),\n  c(0.890, 0.785, 0.495),\n  \"oops\"\n)\n\nout <- rep(NA_real_, length(x))\nfor (i in seq_along(x)) {\n  out[[i]] <- sum(x[[i]])\n}\n#> Error in sum(x[[i]]): invalid 'type' (character) of argument\nout\n#> [1] 1.39 1.27 2.17   NA\nmap_dbl(x, sum)\n#> Error in .Primitive(\"sum\")(..., na.rm = na.rm): invalid 'type' (character) of argument\nsafe_sum <- safely(sum)\nsafe_sum\n#> function (...) \n#> capture_error(.f(...), otherwise, quiet)\n#> <bytecode: 0x55dd0415f418>\n#> <environment: 0x55dd0415ef80>\nstr(safe_sum(x[[1]]))\n#> List of 2\n#>  $ result: num 1.39\n#>  $ error : NULL\nstr(safe_sum(x[[4]]))\n#> List of 2\n#>  $ result: NULL\n#>  $ error :List of 2\n#>   ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- map(x, safely(sum))\nstr(out)\n#> List of 4\n#>  $ :List of 2\n#>   ..$ result: num 1.39\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 1.27\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 2.17\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: NULL\n#>   ..$ error :List of 2\n#>   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- transpose(map(x, safely(sum)))\nstr(out)\n#> List of 2\n#>  $ result:List of 4\n#>   ..$ : num 1.39\n#>   ..$ : num 1.27\n#>   ..$ : num 2.17\n#>   ..$ : NULL\n#>  $ error :List of 4\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ :List of 2\n#>   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nok <- map_lgl(out$error, is.null)\nok\n#> [1]  TRUE  TRUE  TRUE FALSE\n\nx[!ok]\n#> [[1]]\n#> [1] \"oops\"\n\nout$result[ok]\n#> [[1]]\n#> [1] 1.39\n#> \n#> [[2]]\n#> [1] 1.27\n#> \n#> [[3]]\n#> [1] 2.17\nfit_model <- function(df) {\n  glm(y ~ x1 + x2 * x3, data = df)\n}\n\nmodels <- transpose(map(datasets, safely(fit_model)))\nok <- map_lgl(models$error, is.null)\n\n# which data failed to converge?\ndatasets[!ok]\n\n# which models were successful?\nmodels[ok]"},{"path":"function-operators.html","id":"memoise","chapter":"3 Function operators","heading":"3.2.2 Caching computations with memoise::memoise()","text":"\nAnother handy function operator memoise::memoise(). memoises function, meaning function remember previous inputs return cached results. Memoisation example classic computer science tradeoff memory versus speed. memoised function can run much faster, stores previous inputs outputs, uses memory.Let‚Äôs explore idea toy function simulates expensive operation:memoise function, ‚Äôs slow call new arguments. call arguments ‚Äôs seen ‚Äôs instantaneous: retrieves previous value computation.relatively realistic use memoisation computing Fibonacci series. Fibonacci series defined recursively: first two values defined convention, \\(f(0) = 0\\), \\(f(1) = 1\\), \\(f(n) = f(n - 1) + f(n - 2)\\) (positive integer). naive version slow , example, fib(10) computes fib(9) fib(8), fib(9) computes fib(8) fib(7), .Memoising fib() makes implementation much faster value computed :future calls can rely previous computations:example dynamic programming, complex problem can broken many overlapping subproblems, remembering results subproblem considerably improves performance.Think carefully memoising function. function pure, .e.¬†output depend input, get misleading confusing results. created subtle bug devtools memoised results available.packages(), rather slow download large file CRAN. available packages don‚Äôt change frequently, R process ‚Äôs running days, changes can become important, problem arose long-running R processes, bug painful find.","code":"\nslow_function <- function(x) {\n  Sys.sleep(1)\n  x * 10 * runif(1)\n}\nsystem.time(print(slow_function(1)))\n#> [1] 0.808\n#>    user  system elapsed \n#>       0       0       1\n\nsystem.time(print(slow_function(1)))\n#> [1] 8.34\n#>    user  system elapsed \n#>   0.003   0.000   1.004\nfast_function <- memoise::memoise(slow_function)\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>   0.001   0.000   1.002\n\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>   0.017   0.000   0.017\nfib <- function(n) {\n  if (n < 2) return(1)\n  fib(n - 2) + fib(n - 1)\n}\nsystem.time(fib(23))\n#>    user  system elapsed \n#>   0.047   0.000   0.047\nsystem.time(fib(24))\n#>    user  system elapsed \n#>    0.08    0.00    0.08\nfib2 <- memoise::memoise(function(n) {\n  if (n < 2) return(1)\n  fib2(n - 2) + fib2(n - 1)\n})\nsystem.time(fib2(23))\n#>    user  system elapsed \n#>   0.007   0.000   0.007\nsystem.time(fib2(24))\n#>    user  system elapsed \n#>   0.001   0.000   0.001"},{"path":"function-operators.html","id":"exercises-8","chapter":"3 Function operators","heading":"3.2.3 Exercises","text":"Base R provides function operator form Vectorize().\n? might use ?Base R provides function operator form Vectorize().\n? might use ?Read source code possibly(). work?Read source code possibly(). work?Read source code safely(). work?Read source code safely(). work?","code":""},{"path":"function-operators.html","id":"fo-case-study","chapter":"3 Function operators","heading":"3.3 Case study: Creating your own function operators","text":"meomoise() safely() useful also quite complex. case study ‚Äôll learn create simpler function operators. Imagine named vector URLs ‚Äôd like download one disk. ‚Äôs pretty simple walk2() file.download():approach fine handful URLs, vector gets longer, might want add couple features:Add small delay request avoid hammering server.Add small delay request avoid hammering server.Display . every URLs know function still\nworking.Display . every URLs know function still\nworking.‚Äôs relatively easy add extra features ‚Äôre using loop:think loop suboptimal interleaves different concerns: pausing, showing progress, downloading. makes code harder read, makes harder reuse components new situations. Instead, let‚Äôs see can use function operators extract pausing showing progress make reusable.First, let‚Äôs write function operator adds small delay. ‚Äôm going call delay_by() reasons clear shortly, two arguments: function wrap, amount delay add. actual implementation quite simple. main trick forcing evaluation arguments described Section 2.2.5, function operators special type function factory:can use original walk2():Creating function display occasional dot little harder, can longer rely index loop. pass index along another argument, breaks encapsulation: concern progress function now becomes problem higher level wrapper needs handle. Instead, ‚Äôll use another function factory trick (Section 2.2.4), progress wrapper can manage internal counter:Now can express original loop :starting get little hard read composing many function calls, arguments getting spread . One way resolve use pipe:pipe works well ‚Äôve carefully chosen function names yield (almost) readable sentence: take download.file (add) dot every 10 iterations, delay 0.1s. clearly can express intent code function names, easily others (including future !) can read understand code.","code":"\nurls <- c(\n  \"adv-r\" = \"https://adv-r.hadley.nz\", \n  \"r4ds\" = \"http://r4ds.had.co.nz/\"\n  # and many many more\n)\npath <- paste(tempdir(), names(urls), \".html\")\n\nwalk2(urls, path, download.file, quiet = TRUE)\nfor(i in seq_along(urls)) {\n  Sys.sleep(0.1)\n  if (i %% 10 == 0) cat(\".\")\n  download.file(urls[[i]], paths[[i]])\n}\ndelay_by <- function(f, amount) {\n  force(f)\n  force(amount)\n  \n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\nsystem.time(runif(100))\n#>    user  system elapsed \n#>       0       0       0\nsystem.time(delay_by(runif, 0.1)(100))\n#>    user  system elapsed \n#>     0.0     0.0     0.1\nwalk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)\ndot_every <- function(f, n) {\n  force(f)\n  force(n)\n  \n  i <- 0\n  function(...) {\n    i <<- i + 1\n    if (i %% n == 0) cat(\".\")\n    f(...)\n  }\n}\nwalk(1:100, runif)\nwalk(1:100, dot_every(runif, 10))\n#> ..........\nwalk2(\n  urls, path, \n  dot_every(delay_by(download.file, 0.1), 10), \n  quiet = TRUE\n)\nwalk2(\n  urls, path, \n  download.file %>% dot_every(10) %>% delay_by(0.1), \n  quiet = TRUE\n)"},{"path":"function-operators.html","id":"exercises-9","chapter":"3 Function operators","heading":"3.3.1 Exercises","text":"Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).memoise file.download()? ?memoise file.download()? ?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Write function operator logs timestamp message file\nevery time function run.Write function operator logs timestamp message file\nevery time function run.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn‚Äôt \nextra delay.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn‚Äôt \nextra delay.","code":""}]
