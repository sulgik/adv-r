[{"path":"index.html","id":"환영합니다","chapter":"환영합니다","heading":"환영합니다","text":" website 2nd edition “Advanced R”, book Chapman & Hall’s R Series. book designed primarily R users want improve programming skills understanding language. also useful programmers coming R languages, help understand R works way .’re looking 1st edition, can find http://adv-r..co.nz/.","code":""},{"path":"index.html","id":"license","chapter":"환영합니다","heading":"License","text":"work, whole, licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.code contained book simultaneously available MIT license; means free use packages, long cite source.","code":""},{"path":"index.html","id":"other-books","chapter":"환영합니다","heading":"Other books","text":"may also interested :“Advanced R Solutions” \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.“Advanced R Solutions” \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.“R Data Science” introduces R\ntool data science, focussing consistent\nset packages known tidyverse.“R Data Science” introduces R\ntool data science, focussing consistent\nset packages known tidyverse.“R Packages” teaches \nmake R’s fantastic package system.“R Packages” teaches \nmake R’s fantastic package system.","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"Welcome second edition Advanced R. three main goals edition:Improve coverage important concepts fully understood \npublication first edition.Improve coverage important concepts fully understood \npublication first edition.Reduce coverage topics time shown less useful, think\nreally exciting turn practical.Reduce coverage topics time shown less useful, think\nreally exciting turn practical.Generally make material easier understand better text, clearer\ncode, many diagrams.Generally make material easier understand better text, clearer\ncode, many diagrams.’re familiar first edition, preface describes major changes can focus reading new areas. ’re reading printed version book ’ll notice one big change quickly: Advanced R now colour! considerably improved syntax highlighting code chunks, made much easier create helpful diagrams. taken advantage included 100 new diagrams throughout book.Another big change version use new packages, particularly rlang, provides clean interface low-level data structures operations. first edition used base R functions almost exclusively, created pedagogical challenges many functions evolved independently multiple years, making hard see big underlying ideas hidden amongst incidental variations function names arguments. continue show base equivalents sidebars, footnotes, needed, individual sections, want see purest base R expression ideas book, recommend reading first edition, can find online http://adv-r..co.nz.foundations R changed five years since first edition, understanding certainly . Thus, overall structure “Foundations” remained roughly , many individual chapters considerably improved:Chapter 2, “Names values,” brand new chapter\nhelps understand difference objects names \nobjects. helps accurately predict R make copy \ndata structure, lays important groundwork understand functional\nprogramming.Chapter 2, “Names values,” brand new chapter\nhelps understand difference objects names \nobjects. helps accurately predict R make copy \ndata structure, lays important groundwork understand functional\nprogramming.Chapter ??, “Vectors” (previously called data structures),\nrewritten focus vector types like integers, factors, \ndata frames. contains details important S3 vectors (like dates\ndate-times), discusses data frame variation provided \ntibble package,1 generally reflects improved understanding\nvector data types.Chapter ??, “Vectors” (previously called data structures),\nrewritten focus vector types like integers, factors, \ndata frames. contains details important S3 vectors (like dates\ndate-times), discusses data frame variation provided \ntibble package,1 generally reflects improved understanding\nvector data types.Chapter ??, “Subsetting,” now distinguishes [ \n[[ intention: [ extracts many values [[ extracts \nsingle value (previously characterised whether “simplified”\n“preserved”). Section ?? draws “train” help \nunderstand [[ works lists, introduces new functions \nprovide consistent behaviour --bounds indices.Chapter ??, “Subsetting,” now distinguishes [ \n[[ intention: [ extracts many values [[ extracts \nsingle value (previously characterised whether “simplified”\n“preserved”). Section ?? draws “train” help \nunderstand [[ works lists, introduces new functions \nprovide consistent behaviour --bounds indices.Chapter ??, “Control flow,” new chapter: somehow\npreviously forgot important tools like statements \nloops!Chapter ??, “Control flow,” new chapter: somehow\npreviously forgot important tools like statements \nloops!Chapter 3, “Functions,” improved ordering,\nintroduces pipe (%>%) third way compose functions (Section\n3.3), considerably improved coverage \nfunction forms (Section 3.8).Chapter 3, “Functions,” improved ordering,\nintroduces pipe (%>%) third way compose functions (Section\n3.3), considerably improved coverage \nfunction forms (Section 3.8).Chapter 4, “Environments,” reorganised treatment \nspecial environments (Section 4.4), much\nimproved discussion call stack (Section 4.5).Chapter 4, “Environments,” reorganised treatment \nspecial environments (Section 4.4), much\nimproved discussion call stack (Section 4.5).Chapter ??, “Conditions,” contains material previously\n“Exceptions debugging,” much new content R’s condition\nsystem works. also shows create custom condition\nclasses (Section ??).Chapter ??, “Conditions,” contains material previously\n“Exceptions debugging,” much new content R’s condition\nsystem works. also shows create custom condition\nclasses (Section ??).chapters following Part , Foundations, re-organised around three important programming paradigms R: functional programming, object-oriented programming, metaprogramming.Functional programming now cleanly divided three main\ntechniques: “Functionals” (Chapter 5), “Function\nfactories” (Chapter ??), “Function operators”\n(Chapter 7). ’ve focussed ideas \npractical applications data science reduced amount pure theory.\nchapters now use functions provided purrr package,2\nallow focus underlying ideas less \nincidental details. led considerable simplification \nfunction operators chapter since major use work around absence\nellipses (...) base functionals.Functional programming now cleanly divided three main\ntechniques: “Functionals” (Chapter 5), “Function\nfactories” (Chapter ??), “Function operators”\n(Chapter 7). ’ve focussed ideas \npractical applications data science reduced amount pure theory.chapters now use functions provided purrr package,2\nallow focus underlying ideas less \nincidental details. led considerable simplification \nfunction operators chapter since major use work around absence\nellipses (...) base functionals.Object-oriented programming (OOP) now forms major section book \ncompletely new chapters base types (Chapter ??),\nS3 (Chapter ??), S4 (Chapter ??), R6 (Chapter ??),\ntradeoffs systems (Chapter ??).\nchapters focus different object systems work,\nuse effectively. unfortunate, necessary, \nmany technical details described elsewhere, effective use\nOOP needs whole book .Object-oriented programming (OOP) now forms major section book \ncompletely new chapters base types (Chapter ??),\nS3 (Chapter ??), S4 (Chapter ??), R6 (Chapter ??),\ntradeoffs systems (Chapter ??).chapters focus different object systems work,\nuse effectively. unfortunate, necessary, \nmany technical details described elsewhere, effective use\nOOP needs whole book .Metaprogramming (previously called “computing language”) describes \nsuite tools can use generate code code. Compared \nfirst edition material substantially expanded now focusses \n“tidy evaluation,” set ideas theory make metaprogramming\nsafe, well-principled, accessible many R programmers.\nChapter ??, “Big picture” coarsely lays \npieces fit together; Chapter ??, “Expressions,” describes\nunderlying data structures; Chapter ??,\n“Quasiquotation,” covers quoting unquoting; Chapter ??,\n“Evaluation,” explains evaluation code special environments; Chapter\n??, “Translations,” pulls themes together show\nmight translate one (programming) language another.Metaprogramming (previously called “computing language”) describes \nsuite tools can use generate code code. Compared \nfirst edition material substantially expanded now focusses \n“tidy evaluation,” set ideas theory make metaprogramming\nsafe, well-principled, accessible many R programmers.\nChapter ??, “Big picture” coarsely lays \npieces fit together; Chapter ??, “Expressions,” describes\nunderlying data structures; Chapter ??,\n“Quasiquotation,” covers quoting unquoting; Chapter ??,\n“Evaluation,” explains evaluation code special environments; Chapter\n??, “Translations,” pulls themes together show\nmight translate one (programming) language another.final section book pulls together chapters programming techniques: profiling, measuring improving performance, Rcpp. contents similar first edition, although organisation little different. made light updates throughout chapters particularly use newer packages (microbenchmark -> bench, lineprof -> profvis), majority text .second edition mostly expanded coverage existing material, five chapters removed:vocabulary chapter removed always bit odd\nduck, effective ways present vocabulary lists \nbook chapter.vocabulary chapter removed always bit odd\nduck, effective ways present vocabulary lists \nbook chapter.style chapter replaced online style guide,\nhttp://style.tidyverse.org/. style guide paired new\nstyler package3 can automatically apply many rules.style chapter replaced online style guide,\nhttp://style.tidyverse.org/. style guide paired new\nstyler package3 can automatically apply many rules.C chapter moved https://github.com/hadley/r-internals, , time, provide\nguide writing C code works R’s data structures.C chapter moved https://github.com/hadley/r-internals, , time, provide\nguide writing C code works R’s data structures.memory chapter removed. Much material integrated\nChapter 2 remainder felt excessively technical\nimportant understand.memory chapter removed. Much material integrated\nChapter 2 remainder felt excessively technical\nimportant understand.chapter R’s performance language removed. delivered\nactionable insights, became dated R changed.chapter R’s performance language removed. delivered\nactionable insights, became dated R changed.","code":""},{"path":"introduction.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"now programming R 15 years, full-time last five years. given luxury time examine language works. book attempt pass ’ve learned can understand intricacies R quickly painlessly possible. Reading help avoid mistakes ’ve made dead ends ’ve gone , teach useful tools, techniques, idioms can help attack many types problems. process, hope show , despite sometimes frustrating quirks, R , heart, elegant beautiful language, well tailored data science.","code":""},{"path":"introduction.html","id":"why-r","chapter":"1 Introduction","heading":"1.1 Why R?","text":"new R, might wonder makes learning quirky language worthwhile. , best features :’s free, open source, available every major platform. result, \nanalysis R, anyone can easily replicate , regardless \nlive much money earn.’s free, open source, available every major platform. result, \nanalysis R, anyone can easily replicate , regardless \nlive much money earn.R diverse welcoming community, online (e.g. \n#rstats twitter community) person (like \nmany R meetups). Two particularly inspiring community groups \nrweekly newsletter makes easy keep date \nR, R-Ladies made wonderfully welcoming community\nwomen minority genders.R diverse welcoming community, online (e.g. \n#rstats twitter community) person (like \nmany R meetups). Two particularly inspiring community groups \nrweekly newsletter makes easy keep date \nR, R-Ladies made wonderfully welcoming community\nwomen minority genders.massive set packages statistical modelling, machine learning,\nvisualisation, importing manipulating data. Whatever model \ngraphic ’re trying , chances someone already tried\ncan learn efforts.massive set packages statistical modelling, machine learning,\nvisualisation, importing manipulating data. Whatever model \ngraphic ’re trying , chances someone already tried\ncan learn efforts.Powerful tools communicating results. RMarkdown makes\neasy turn results HTML files, PDFs, Word documents,\nPowerPoint presentations, dashboards . Shiny allows \nmake beautiful interactive apps without knowledge HTML javascript.Powerful tools communicating results. RMarkdown makes\neasy turn results HTML files, PDFs, Word documents,\nPowerPoint presentations, dashboards . Shiny allows \nmake beautiful interactive apps without knowledge HTML javascript.RStudio, IDE, provides integrated\ndevelopment environment, tailored needs data science, interactive\ndata analysis, statistical programming.RStudio, IDE, provides integrated\ndevelopment environment, tailored needs data science, interactive\ndata analysis, statistical programming.Cutting edge tools. Researchers statistics machine learning often\npublish R package accompany articles. means immediate\naccess latest statistical techniques implementations.Cutting edge tools. Researchers statistics machine learning often\npublish R package accompany articles. means immediate\naccess latest statistical techniques implementations.Deep-seated language support data analysis. includes features\nlike missing values, data frames, vectorisation.Deep-seated language support data analysis. includes features\nlike missing values, data frames, vectorisation.strong foundation functional programming. ideas functional\nprogramming well suited challenges data science, \nR language functional heart, provides many primitives needed\neffective functional programming.strong foundation functional programming. ideas functional\nprogramming well suited challenges data science, \nR language functional heart, provides many primitives needed\neffective functional programming.RStudio, company, makes money \nselling professional products teams R users, turns around \ninvests much money back open source community (50%\nsoftware engineers RStudio work open source projects). work \nRStudio fundamentally believe mission.RStudio, company, makes money \nselling professional products teams R users, turns around \ninvests much money back open source community (50%\nsoftware engineers RStudio work open source projects). work \nRStudio fundamentally believe mission.Powerful metaprogramming facilities. R’s metaprogramming capabilities allow\nwrite magically succinct concise functions provide excellent\nenvironment designing domain-specific languages like ggplot2, dplyr,\ndata.table, .Powerful metaprogramming facilities. R’s metaprogramming capabilities allow\nwrite magically succinct concise functions provide excellent\nenvironment designing domain-specific languages like ggplot2, dplyr,\ndata.table, .ease R can connect high-performance programming languages\nlike C, Fortran, C++.ease R can connect high-performance programming languages\nlike C, Fortran, C++.course, R perfect. R’s biggest challenge (opportunity!) R users programmers. means :Much R code ’ll see wild written haste solve\npressing problem. result, code elegant, fast, easy \nunderstand. users revise code address shortcomings.Much R code ’ll see wild written haste solve\npressing problem. result, code elegant, fast, easy \nunderstand. users revise code address shortcomings.Compared programming languages, R community focussed \nresults processes. Knowledge software engineering best practices \npatchy. example, enough R programmers use source code control \nautomated testing.Compared programming languages, R community focussed \nresults processes. Knowledge software engineering best practices \npatchy. example, enough R programmers use source code control \nautomated testing.Metaprogramming double-edged sword. many R functions use\ntricks reduce amount typing cost making code \nhard understand can fail unexpected ways.Metaprogramming double-edged sword. many R functions use\ntricks reduce amount typing cost making code \nhard understand can fail unexpected ways.Inconsistency rife across contributed packages, even within base R.\nconfronted 25 years evolution every time use R,\ncan make learning R tough many special cases \nremember.Inconsistency rife across contributed packages, even within base R.\nconfronted 25 years evolution every time use R,\ncan make learning R tough many special cases \nremember.R particularly fast programming language, poorly written R code\ncan terribly slow. R also profligate user memory.R particularly fast programming language, poorly written R code\ncan terribly slow. R also profligate user memory.Personally, think challenges create great opportunity experienced programmers profound positive impact R R community. R users care writing high quality code, particularly reproducible research, don’t yet skills . hope book help R users become R programmers, also encourage programmers languages contribute R.","code":""},{"path":"introduction.html","id":"who-should-read","chapter":"1 Introduction","heading":"1.2 Who should read this book","text":"book aimed two complementary audiences:Intermediate R programmers want dive deeper R, understand \nlanguage works, learn new strategies solving diverse problems.Intermediate R programmers want dive deeper R, understand \nlanguage works, learn new strategies solving diverse problems.Programmers languages learning R want understand\nR works way .Programmers languages learning R want understand\nR works way .get book, ’ll need written decent amount code R another programming language. familiar basics data analysis (.e. data import, manipulation, visualisation), written number functions, familiar installation use CRAN packages.book walks narrow line reference book (primarily used lookup), linearly readable. involves tradeoffs, ’s difficult linearise material still keeping related materials together, concepts much easier explain ’re already familiar specific technical vocabulary. ’ve tried use footnotes cross-references make sure can still make sense even just dip toes chapter.","code":""},{"path":"introduction.html","id":"what-you-will-get","chapter":"1 Introduction","heading":"1.3 What you will get out of this book","text":"book delivers knowledge think advanced R programmer possess: deep understanding fundamentals coupled broad vocabulary means can tactically learn topic needed.reading book, :familiar foundations R. understand complex data types\nbest ways perform operations . deep\nunderstanding functions work, ’ll know environments , \nmake use condition system.familiar foundations R. understand complex data types\nbest ways perform operations . deep\nunderstanding functions work, ’ll know environments , \nmake use condition system.Understand functional programming means, useful tool \ndata science. ’ll able quickly learn use existing tools, \nknowledge create functional tools needed.Understand functional programming means, useful tool \ndata science. ’ll able quickly learn use existing tools, \nknowledge create functional tools needed.Know R’s rich variety object-oriented systems. ’ll \nfamiliar S3, ’ll know S4 R6 look \ninformation needed.Know R’s rich variety object-oriented systems. ’ll \nfamiliar S3, ’ll know S4 R6 look \ninformation needed.Appreciate double-edged sword metaprogramming. ’ll able \ncreate functions use tidy evaluation, saving typing creating elegant\ncode express important operations. ’ll also understand dangers\navoid .Appreciate double-edged sword metaprogramming. ’ll able \ncreate functions use tidy evaluation, saving typing creating elegant\ncode express important operations. ’ll also understand dangers\navoid .good intuition operations R slow use lot \nmemory. ’ll know use profiling pinpoint performance\nbottlenecks, ’ll know enough C++ convert slow R functions \nfast C++ equivalents.good intuition operations R slow use lot \nmemory. ’ll know use profiling pinpoint performance\nbottlenecks, ’ll know enough C++ convert slow R functions \nfast C++ equivalents.","code":""},{"path":"introduction.html","id":"what-you-will-not-learn","chapter":"1 Introduction","heading":"1.4 What you will not learn","text":"book R programming language, R data analysis tool. looking improve data science skills, instead recommend learn tidyverse, collection consistent packages developed colleagues. book ’ll learn techniques used develop tidyverse packages; want instead learn use , recommend R Data Science.want share R code others, need make R package. allows bundle code along documentation unit tests, easily distribute via CRAN. opinion, easiest way develop packages devtools, roxygen2, testthat, usethis. can learn using packages make package R packages.","code":""},{"path":"introduction.html","id":"meta-techniques","chapter":"1 Introduction","heading":"1.5 Meta-techniques","text":"two meta-techniques tremendously helpful improving skills R programmer: reading source code adopting scientific mindset.Reading source code important help write better code. great place start developing skill look source code functions packages use often. ’ll find things worth emulating code ’ll develop sense taste makes good R code. also see things don’t like, either virtues obvious offends sensibilities. code nonetheless valuable, helps make concrete opinions good bad code.scientific mindset extremely helpful learning R. don’t understand something works, develop hypothesis, design experiments, run , record results. exercise extremely useful since can’t figure something need get help, can easily show others tried. Also, learn right answer, ’ll mentally prepared update world view.","code":""},{"path":"introduction.html","id":"recommended-reading","chapter":"1 Introduction","heading":"1.6 Recommended reading","text":"R community mostly consists data scientists, computer scientists, relatively books go deep technical underpinnings R. personal journey understand R, ’ve found particularly helpful use resources programming languages. R aspects functional object-oriented (OO) programming languages. Learning concepts expressed R help leverage existing knowledge programming languages, help identify areas can improve.understand R’s object systems work way , found Structure Interpretation Computer Programs45 (SICP) particularly helpful. ’s concise deep book, reading , felt first time actually design object-oriented system. book first introduction encapsulated paradigm object-oriented programming found R, helped understand strengths weaknesses system. SICP also teaches functional mindset create functions simple individually, become powerful composed together.understand trade-offs R made compared programming languages, found Concepts, Techniques Models Computer Programming6 extremely helpful. helped understand R’s copy--modify semantics make substantially easier reason code, current implementation particularly efficient, solvable problem.want learn better programmer, ’s place better turn Pragmatic Programmer.7 book language agnostic, provides great advice better programmer.","code":""},{"path":"introduction.html","id":"getting-help","chapter":"1 Introduction","heading":"1.7 Getting help","text":"\nCurrently, three main venues get help ’re stuck can’t figure ’s causing problem: RStudio Community, StackOverflow R-help mailing list. can get fantastic help venue, cultures expectations. ’s usually good idea spend little time lurking, learning community expectations, put first post.good general advice:Make sure latest version R package (packages)\nproblems . may problem result \nrecently fixed bug.Make sure latest version R package (packages)\nproblems . may problem result \nrecently fixed bug.Spend time creating reproducible example, reprex.\nhelp others help , often leads solution without\nasking others, course making problem reproducible \noften figure root cause. highly recommend learning using\nreprex package.Spend time creating reproducible example, reprex.\nhelp others help , often leads solution without\nasking others, course making problem reproducible \noften figure root cause. highly recommend learning using\nreprex package.looking specific help solving exercises book, solutions Malte Grosser Henning Bumann available https://advanced-r-solutions.rbind.io.","code":""},{"path":"introduction.html","id":"intro-ack","chapter":"1 Introduction","heading":"1.8 Acknowledgments","text":"like thank many contributors R-devel R-help , recently, Stack Overflow RStudio Community. many name individually, ’d particularly like thank Luke Tierney, John Chambers, JJ Allaire, Brian Ripley generously giving time correcting countless misunderstandings.book written open, chapters advertised twitter complete. truly community effort: many people read drafts, fixed typos, suggested improvements, contributed content. Without contributors, book wouldn’t nearly good , ’m deeply grateful help. Special thanks go Jeff Hammerbacher, Peter Li, Duncan Murdoch, Greg Wilson, read book cover--cover provided many fixes suggestions.big thank 386 contributors (alphabetical order username): Aaron Wolen (@aaronwolen), @absolutelyNoWarranty, Adam Hunt (@adamphunt), @agrabovsky, Alexander Grueneberg (@agrueneberg), Anthony Damico (@ajdamico), James Manton (@ajdm), Aaron Schumacher (@ajschumacher), Alan Dipert (@alandipert), Alex Brown (@alexbbrown), @alexperrone, Alex Whitworth (@alexWhitworth), Alexandros Kokkalis (@alko989), @amarchin, Amelia McNamara (@AmeliaMN), Bryce Mecum (@amoeba), Andrew Laucius (@andrewla), Andrew Bray (@andrewpbray), Andrie de Vries (@andrie), Angela Li (@angela-li), @aranlunzer, Ari Lamstein (@arilamstein), @asnr, Andy Teucher (@ateucher), Albert Vilella (@avilella), baptiste (@baptiste), Brian G. Barkley (@BarkleyBG), Mara Averick (@batpigandme), Byron (@bcjaeger), Brandon Greenwell (@bgreenwell), Brandon Hurr (@bhive01), Jason Knight (@binarybana), Brett Klamer (@bklamer), Jesse Anderson (@blindjesse), Brian Mayer (@blmayer), Benjamin L. Moore (@blmoore), Brian Diggs (@BrianDiggs), Brian S. Yandell (@byandell), @carey1024, Chip Hogg (@chiphogg), Chris Muir (@ChrisMuir), Christopher Gandrud (@christophergandrud), Clay Ford (@clayford), Colin Fay (@ColinFay), @cortinah, Cameron Plouffe (@cplouffe), Carson Sievert (@cpsievert), Craig Citro (@craigcitro), Craig Grabowski (@craiggrabowski), Christopher Roach (@croach), Peter Meilstrup (@crowding), Crt Ahlin (@crtahlin), Carlos Scheidegger (@cscheid), Colin Gillespie (@csgillespie), Christopher Brown (@ctbrown), Davor Cubranic (@cubranic), Darren Cusanovich (@cusanovich), Christian G. Warden (@cwarden), Charlotte Wickham (@cwickham), Dean Attali (@daattali), Dan Sullivan (@dan87134), Daniel Barnett (@daniel-barnett), Daniel (@danielruc91), Kenny Darrell (@darrkj), Tracy Nance (@datapixie), Dave Childers (@davechilders), David Vukovic (@david-vukovic), David Rubinger (@davidrubinger), David Chudzicki (@dchudz), Deependra Dhakal (@DeependraD), Daisuke ICHIKAWA (@dichika), david kahle (@dkahle), David LeBauer (@dlebauer), David Schweizer (@dlschweizer), David Montaner (@dmontaner), @dmurdoch, Zhuoer Dong (@dongzhuoer), Doug Mitarotonda (@dougmitarotonda), Dragoș Moldovan-Grünfeld (@dragosmg), Jonathan Hill (@Dripdrop12), @drtjc, Julian (@duju211), @duncanwadsworth, @eaurele, Dirk Eddelbuettel (@eddelbuettel), @EdFineOKL, Eduard Szöcs (@EDiLD), Edwin Thoen (@EdwinTh), Ethan Heinzen (@eheinzen), @eijoac, Joel Schwartz (@eipi10), Eric Ronald Legrand (@elegrand), Elio Campitelli (@eliocamp), Ellis Valentiner (@ellisvalentiner), Emil Hvitfeldt (@EmilHvitfeldt), Emil Rehnberg (@EmilRehnberg), Daniel Lee (@erget), Eric C. Anderson (@eriqande), Enrico Spinielli (@espinielli), @etb, David Hajage (@eusebe), Fabian Scheipl (@fabian-s), @flammy0530, François Michonneau (@fmichonneau), Francois Pepin (@fpepin), Frank Farach (@frankfarach), @freezby, Frans van Dunné (@FvD), @fyears, @gagnagaman, Garrett Grolemund (@garrettgman), Gavin Simpson (@gavinsimpson), Brooke Anderson (@geanders), @gezakiss7, @gggtest, Gökçen Eraslan (@gokceneraslan), Josh Goldberg (@GoldbergData), Georg Russ (@gr650), @grasshoppermouse, Gregor Thomas (@gregorp), Garrett See (@gsee), Ari Friedman (@gsk3), Gunnlaugur Thor Briem (@gthb), Greg Wilson (@gvwilson), Hamed (@hamedbh), Jeff Hammerbacher (@hammer), Harley Day (@harleyday), @hassaad85, @helmingstay, Henning (@henningsway), Henrik Bengtsson (@HenrikBengtsson), Ching Boon (@hoscb), @hplieninger, Hörmet Yiltiz (@hyiltiz), Iain Dillingham (@iaindillingham), @IanKopacka, Ian Lyttle (@ijlyttle), Ilan Man (@ilanman), Imanuel Costigan (@imanuelcostigan), Thomas Bürli (@initdch), Os Keyes (@Ironholds), @irudnyts, (@isomorphisms), Irene Steves (@isteves), Jan Gleixner (@jan-glx), Jannes Muenchow (@jannes-m), Jason Asher (@jasonasher), Jason Davies (@jasondavies), Chris (@jastingo), jcborras (@jcborras), Joe Cheng (@jcheng5), John Blischak (@jdblischak), @jeharmse, Lukas Burk (@jemus42), Jennifer (Jenny) Bryan (@jennybc), Justin Jent (@jentjr), Jeston (@JestonBlu), Josh Cook (@jhrcook), Jim Hester (@jimhester), @JimInNashville, @jimmyliu2017, Jim Vine (@jimvine), Jinlong Yang (@jinlong25), J.J. Allaire (@jjallaire), @JMHay, Jochen Van de Velde (@jochenvdv), Johann Hibschman (@johannh), John Baumgartner (@johnbaums), John Horton (@johnjosephhorton), @johnthomas12, Jon Calder (@jonmcalder), Jon Harmon (@jonthegeek), Julia Gustavsen (@jooolia), JorneBiccler (@JorneBiccler), Jeffrey Arnold (@jrnold), Joyce Robbins (@jtr13), Juan Manuel Truppia (@juancentro), @juangomezduaso, Kevin Markham (@justmarkham), john verzani (@jverzani), Michael Kane (@kaneplusplus), Bart Kastermans (@kasterma), Kevin D’Auria (@kdauria), Karandeep Singh (@kdpsingh), Ken Williams (@kenahoo), Kendon Bell (@kendonB), Kent Johnson (@kent37), Kevin Ushey (@kevinushey), 电线杆 (@kfeng123), Karl Forner (@kforner), Kirill Sevastyanenko (@kirillseva), Brian Knaus (@knausb), Kirill Müller (@krlmlr), Kriti Sen Sharma (@ksens), Kai Tang (唐恺） (@ktang), Kevin Wright (@kwstat), suo.lawrence.liu@gmail.com (@Lawrence-Liu), @ldfmrails, Kevin Kainan Li (@legendre6891), Rachel Severson (@leighseverson), Laurent Gatto (@lgatto), C. Jason Liang (@liangcj), Steve Lianoglou (@lianos), Yongfu Liao (@liao961120), Likan (@likanzhan), @lindbrook, Lingbing Feng (@Lingbing), Marcel Ramos (@LiNk-NY), Zhongpeng Lin (@linzhp), Lionel Henry (@lionel-), Lluís (@llrs), myq (@lrcg), Luke W Johnston (@lwjohnst86), Kevin Lynagh (@lynaghk), @MajoroMask, Malcolm Barrett (@malcolmbarrett), @mannyishere, @mascaretti, Matt (@mattbaggott), Matthew Grogan (@mattgrogan), @matthewhillary, Matthieu Gomez (@matthieugomez), Matt Malin (@mattmalin), Mauro Lepore (@maurolepore), Max Ghenis (@MaxGhenis), Maximilian Held (@maxheld83), Michal Bojanowski (@mbojan), Mark Rosenstein (@mbrmbr), Michael Sumner (@mdsumner), Jun Mei (@meijun), merkliopas (@merkliopas), mfrasco (@mfrasco), Michael Bach (@michaelbach), Michael Bishop (@MichaelMBishop), Michael Buckley (@michaelmikebuckley), Michael Quinn (@michaelquinn32), @miguelmorin, Michael (@mikekaminsky), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), @mjsduncan, Mamoun Benghezal (@MoBeng), Matt Pettis (@mpettis), Martin Morgan (@mtmorgan), Guy Dawson (@Mullefa), Nacho Caballero (@nachocab), Natalya Rapstine (@natalya-patrikeeva), Nick Carchedi (@ncarchedi), Pascal Burkhard (@Nenuial), Noah Greifer (@ngreifer), Nicholas Vasile (@nickv9), Nikos Ignatiadis (@nignatiadis), Nina Munkholt Jakobsen (@nmjakobsen), Xavier Laviron (@norival), Nick Pullen (@nstjhp), Oge Nnadi (@ogennadi), Oliver Paisley (@oliverpaisley), Pariksheet Nanda (@omsai), Øystein Sørensen (@osorensen), Paul (@otepoti), Otho Mantegazza (@othomantegazza), Dewey Dunnington (@paleolimbot), Paola Corrales (@paocorrales), Parker Abercrombie (@parkerabercrombie), Patrick Hausmann (@patperu), Patrick Miller (@patr1ckm), Patrick Werkmeister (@Patrick01), @paulponcet, @pdb61, Tom Crockett (@pelotom), @pengyu, Jeremiah (@perryjer1), Peter Hickey (@PeteHaitch), Phil Chalmers (@philchalmers), Jose Antonio Magaña Mesa (@picarus), Pierre Casadebaig (@picasa), Antonio Piccolboni (@piccolbo), Pierre Roudier (@pierreroudier), Poor Yorick (@pooryorick), Marie-Helene Burle (@prosoitos), Peter Schulam (@pschulam), John (@quantbo), Quyu Kong (@qykong), Ramiro Magno (@ramiromagno), Ramnath Vaidyanathan (@ramnathv), Kun Ren (@renkun-ken), Richard Reeve (@richardreeve), Richard Cotton (@richierocks), Robert M Flight (@rmflight), R. Mark Sharp (@rmsharp), Robert Krzyzanowski (@robertzk), @robiRagan, Romain François (@romainfrancois), Ross Holmberg (@rossholmberg), Ricardo Pietrobon (@rpietro), @rrunner, Ryan Walker (@rtwalker), @rubenfcasal, Rob Weyant (@rweyant), Rumen Zarev (@rzarev), Nan Wang (@sailingwave), Samuel Perreault (@samperochkin), @sbgraves237, Scott Kostyshak (@scottkosty), Scott Leishman (@scttl), Sean Hughes (@seaaan), Sean Anderson (@seananderson), Sean Carmody (@seancarmody), Sebastian (@sebastian-c), Matthew Sedaghatfar (@sedaghatfar), @see24, Sven E. Templer (@setempler), @sflippl, @shabbybanks, Steven Pav (@shabbychef), Shannon Rush (@shannonrush), S’busiso Mkhondwane (@sibusiso16), Sigfried Gold (@Sigfried), Simon O’Hanlon (@simonohanlon101), Simon Potter (@sjp), Leo Razoumov (@slonik-az), Richard M. Smith (@Smudgerville), Steve (@SplashDance), Scott Ritchie (@sritchie73), Tim Cole (@statist7), @ste-fan, @stephens999, Steve Walker (@stevencarlislewalker), Stefan Widgren (@stewid), Homer Strong (@strongh), Suman Khanal (@sumanstats), Dirk (@surmann), Sebastien Vigneau (@svigneau), Steven Nydick (@swnydick), Taekyun Kim (@taekyunk), Tal Galili (@talgalili), @Tazinho, Tyler Bradley (@tbradley1013), Tom B (@tbuckl), @tdenes, @thomasherbig, Thomas (@thomaskern), Thomas Lin Pedersen (@thomasp85), Thomas Zumbrunn (@thomaszumbrunn), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Nagler (@tnagler), Anton Antonov (@tonytonov), Ben Torvaney (@Torvaney), Jeff Allen (@trestletech), Tyler Rinker (@trinker), Chitu Okoli (@Tripartio), Kirill Tsukanov (@tskir), Terence Teo (@tteo), Tim Triche, Jr. (@ttriche), @tyhenkaline, Tyler Ritchie (@tylerritchie), Tyler Littlefield (@tyluRp), Varun Agrawal (@varun729), Vijay Barve (@vijaybarve), Victor (@vkryukov), Vaidotas Zemlys-Balevičius (@vzemlys), Winston Chang (@wch), Linda Chin (@wchi144), Welliton Souza (@Welliton309), Gregg Whitworth (@whitwort), Beasley (@wibeasley), William R Bauer (@WilCrofter), William Doane (@WilDoane), Sean Wilkinson (@wilkinson), Christof Winter (@winterschlaefer), Jake Thompson (@wjakethompson), Bill Carver (@wmc3), Wolfgang Huber (@wolfganghuber), Krishna Sankar (@xsankar), Yihui Xie (@yihui), yang (@yiluheihei), Yoni Ben-Meshulam (@yoni), @yuchouchen, Yuqi Liao (@yuqiliao), Hiroaki Yutani (@yutannihilation), Zachary Foster (@zachary-foster), @zachcp, @zackham, Sergio Oller (@zeehio), Edward Cho (@zerokarmaleft), Albert Zhao (@zxzb).","code":""},{"path":"introduction.html","id":"conventions","chapter":"1 Introduction","heading":"1.9 Conventions","text":"Throughout book use f() refer functions, g refer variables function parameters, h/ paths.Larger code blocks intermingle input output. Output commented (#>) electronic version book, e.g., https://adv-r.hadley.nz/, can easily copy paste examples R.Many examples use random numbers. made reproducible set.seed(1014), executed automatically start chapter.","code":""},{"path":"introduction.html","id":"colophon","chapter":"1 Introduction","heading":"1.10 Colophon","text":"book written bookdown inside RStudio. website hosted netlify, automatically updated every commit travis-ci. complete source available GitHub. Code printed book set inconsolata. Emoji images printed book come open-licensed Twitter Emoji.version book built R version 4.1.1 (2021-08-10) following packages.","code":""},{"path":"foundations-intro.html","id":"foundations-intro","chapter":"Introduction","heading":"Introduction","text":"start journey mastering R, following six chapters help learn foundational components R. expect ’ve already seen many pieces , probably studied deeply. help check existing knowledge, chapter starts quiz; get questions right, feel free skip next chapter!Chapter 2 teaches important distinction\nprobably haven’t thought deeply : difference \nobject name. Improving mental model help make\nbetter predictions R copies data hence basic\noperations cheap expensive.Chapter 2 teaches important distinction\nprobably haven’t thought deeply : difference \nobject name. Improving mental model help make\nbetter predictions R copies data hence basic\noperations cheap expensive.Chapter ?? dives details vectors, helping \nlearn different types vector fit\ntogether. ’ll also learn attributes, allow store\narbitrary metadata, form basis two R’s object-oriented\nprogramming toolkits.Chapter ?? dives details vectors, helping \nlearn different types vector fit\ntogether. ’ll also learn attributes, allow store\narbitrary metadata, form basis two R’s object-oriented\nprogramming toolkits.Chapter ?? describes use subsetting write\nclear, concise, efficient R code. Understanding fundamental\ncomponents allow solve new problems combining building\nblocks novel ways.Chapter ?? describes use subsetting write\nclear, concise, efficient R code. Understanding fundamental\ncomponents allow solve new problems combining building\nblocks novel ways.Chapter ?? presents tools control flow allow \nexecute code certain conditions, repeatedly execute code\nchanging inputs. include important constructs, well \nrelated tools like switch() .Chapter ?? presents tools control flow allow \nexecute code certain conditions, repeatedly execute code\nchanging inputs. include important constructs, well \nrelated tools like switch() .Chapter 3 deals functions, important building\nblocks R code. ’ll learn exactly work, including \nscoping rules, govern R looks values names. ’ll also\nlearn details behind lazy evaluation, can\ncontrol happens exit function.Chapter 3 deals functions, important building\nblocks R code. ’ll learn exactly work, including \nscoping rules, govern R looks values names. ’ll also\nlearn details behind lazy evaluation, can\ncontrol happens exit function.Chapter 4 describes data structure crucial \nunderstanding R works, quite unimportant data analysis: \nenvironment. Environments data structure binds\nnames values, power important tools like package namespaces.\nUnlike programming languages, environments R “first class”\nmeans can manipulate just like objects.Chapter 4 describes data structure crucial \nunderstanding R works, quite unimportant data analysis: \nenvironment. Environments data structure binds\nnames values, power important tools like package namespaces.\nUnlike programming languages, environments R “first class”\nmeans can manipulate just like objects.Chapter ?? concludes foundations R \nexploration “conditions,” umbrella term used describe errors,\nwarnings, messages. ’ve certainly encountered , \nchapter learn signal appropriately \nfunctions, handle signalled elsewhere.Chapter ?? concludes foundations R \nexploration “conditions,” umbrella term used describe errors,\nwarnings, messages. ’ve certainly encountered , \nchapter learn signal appropriately \nfunctions, handle signalled elsewhere.","code":""},{"path":"names-values.html","id":"names-values","chapter":"2 Names and values","heading":"2 Names and values","text":"","code":""},{"path":"names-values.html","id":"introduction-1","chapter":"2 Names and values","heading":"2.1 Introduction","text":"R, important understand distinction object name. help :accurately predict performance memory usage code.Write faster code avoiding accidental copies, major source slow code.Better understand R’s functional programming tools.goal chapter help understand distinction names values, R copy object.","code":""},{"path":"names-values.html","id":"quiz","chapter":"2 Names and values","heading":"Quiz","text":"Answer following questions see can safely skip chapter. can find answers end chapter Section 2.7.Given following data frame, create new column called “3”\ncontains sum 1 2? may use $, [[.\nmakes 1, 2, 3 challenging variable names?\n\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)Given following data frame, create new column called “3”\ncontains sum 1 2? may use $, [[.\nmakes 1, 2, 3 challenging variable names?following code, much memory y occupy?\n\nx <- runif(1e6)\ny <- list(x, x, x)following code, much memory y occupy?line get copied following example?\n\n<- c(1, 5, 3, 2)\nb <- \nb[[1]] <- 10On line get copied following example?","code":"\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\nx <- runif(1e6)\ny <- list(x, x, x)\na <- c(1, 5, 3, 2)\nb <- a\nb[[1]] <- 10"},{"path":"names-values.html","id":"outline","chapter":"2 Names and values","heading":"Outline","text":"Section 2.2 introduces distinction \nnames values, discusses <- creates binding, reference,\nname value.Section 2.2 introduces distinction \nnames values, discusses <- creates binding, reference,\nname value.Section 2.3 describes R makes copy: whenever \nmodify vector, ’re almost certainly creating new, modified vector.\n’ll learn use tracemem() figure copy actually\noccurs. ’ll explore implications apply function calls,\nlists, data frames, character vectors.Section 2.3 describes R makes copy: whenever \nmodify vector, ’re almost certainly creating new, modified vector.\n’ll learn use tracemem() figure copy actually\noccurs. ’ll explore implications apply function calls,\nlists, data frames, character vectors.Section 2.4 explores implications previous two\nsections much memory object occupies. Since intuition may \nprofoundly wrong since utils::object.size() unfortunately\ninaccurate, ’ll learn use lobstr::obj_size().Section 2.4 explores implications previous two\nsections much memory object occupies. Since intuition may \nprofoundly wrong since utils::object.size() unfortunately\ninaccurate, ’ll learn use lobstr::obj_size().Section 2.5 describes two important exceptions \ncopy--modify: environments values single name, objects \nactually modified place.Section 2.5 describes two important exceptions \ncopy--modify: environments values single name, objects \nactually modified place.Section 2.6 concludes chapter discussion garbage\ncollector, frees memory used objects longer referenced \nname.Section 2.6 concludes chapter discussion garbage\ncollector, frees memory used objects longer referenced \nname.","code":""},{"path":"names-values.html","id":"prerequisites","chapter":"2 Names and values","heading":"Prerequisites","text":"’ll use lobstr package dig internal representation R objects.","code":"\nlibrary(lobstr)"},{"path":"names-values.html","id":"sources","chapter":"2 Names and values","heading":"Sources","text":"details R’s memory management documented single place. Much information chapter gleaned close reading documentation (particularly ?Memory ?gc), memory profiling section Writing R extensions,8 SEXPs section R internals.9 rest figured reading C source code, performing small experiments, asking questions R-devel. mistakes entirely mine.","code":""},{"path":"names-values.html","id":"binding-basics","chapter":"2 Names and values","heading":"2.2 Binding basics","text":"\n\nConsider code:’s easy read : “create object named ‘x,’ containing values 1, 2, 3.” Unfortunately, ’s simplification lead inaccurate predictions R actually behind scenes. ’s accurate say code two things:’s creating object, vector values, c(1, 2, 3).’s binding object name, x.words, object, value, doesn’t name; ’s actually name value.clarify distinction, ’ll draw diagrams like :name, x, drawn rounded rectangle. arrow points (binds references) value, vector c(1, 2, 3). arrow points opposite direction assignment arrow: <- creates binding name left-hand side object right-hand side.Thus, can think name reference value. example, run code, don’t get another copy value c(1, 2, 3), get another binding existing object:might noticed value c(1, 2, 3) label: 0x74b. vector doesn’t name, ’ll occasionally need refer object independent bindings. make possible, ’ll label values unique identifier. identifiers special form looks like object’s memory “address,” .e. location memory object stored. actual memory addresses changes every time code run, use identifiers instead.can access object’s identifier lobstr::obj_addr(). allows see x y point identifier:identifiers long, change every time restart R.can take time get head around distinction names values, understanding really helpful functional programming functions can different names different contexts.","code":"\nx <- c(1, 2, 3)\ny <- x\nobj_addr(x)\n#> [1] \"0x559e9ecb71a8\"\nobj_addr(y)\n#> [1] \"0x559e9ecb71a8\""},{"path":"names-values.html","id":"non-syntactic","chapter":"2 Names and values","heading":"2.2.1 Non-syntactic names","text":"\n\nR strict rules constitutes valid name. syntactic name must consist letters10, digits, . _ can’t begin _ digit. Additionally, can’t use reserved words like TRUE, NULL, , function (see complete list ?Reserved). name doesn’t follow rules non-syntactic name; try use , ’ll get error:’s possible override rules use name, .e., sequence characters, surrounding backticks:’s unlikely ’d deliberately create crazy names, need understand crazy names work ’ll come across , commonly load data created outside R.can also create non-syntactic bindings using single double quotes (e.g. \"_abc\" <- 1) instead backticks, shouldn’t, ’ll use different syntax retrieve values. ability use strings left hand side assignment arrow historical artefact, used R supported backticks.","code":"_abc <- 1\n#> Error: unexpected input in \"_\"\n\nif <- 10\n#> Error: unexpected assignment in \"if <-\"\n`_abc` <- 1\n`_abc`\n#> [1] 1\n\n`if` <- 10\n`if`\n#> [1] 10"},{"path":"names-values.html","id":"exercises","chapter":"2 Names and values","heading":"2.2.2 Exercises","text":"Explain relationship , b, c d following\ncode:\n\n<- 1:10\nb <- \nc <- b\nd <- 1:10Explain relationship , b, c d following\ncode:following code accesses mean function multiple ways. \npoint underlying function object? Verify \nlobstr::obj_addr().\n\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")following code accesses mean function multiple ways. \npoint underlying function object? Verify \nlobstr::obj_addr().default, base R data import functions, like read.csv(), \nautomatically convert non-syntactic names syntactic ones. might\nproblematic? option allows suppress behaviour?default, base R data import functions, like read.csv(), \nautomatically convert non-syntactic names syntactic ones. might\nproblematic? option allows suppress behaviour?rules make.names() use convert non-syntactic names \nsyntactic ones?rules make.names() use convert non-syntactic names \nsyntactic ones?slightly simplified rules govern syntactic names. .123e1\nsyntactic name? Read ?make.names full details.slightly simplified rules govern syntactic names. .123e1\nsyntactic name? Read ?make.names full details.","code":"\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")"},{"path":"names-values.html","id":"copy-on-modify","chapter":"2 Names and values","heading":"2.3 Copy-on-modify","text":"Consider following code. binds x y underlying value, modifies y11.Modifying y clearly didn’t modify x. happened shared binding? value associated y changed, original object . Instead, R created new object, 0xcd2, copy 0x74b one value changed, rebound y object.behaviour called copy--modify. Understanding radically improve intuition performance R code. related way describe behaviour say R objects unchangeable, immutable. However, ’ll generally avoid term couple important exceptions copy--modify ’ll learn Section 2.5.exploring copy--modify behaviour interactively, aware ’ll get different results inside RStudio. ’s environment pane must make reference object order display information . distorts interactive exploration doesn’t affect code inside functions, doesn’t affect performance data analysis. experimentation, recommend either running R directly terminal, using RMarkdown (like book).","code":"\nx <- c(1, 2, 3)\ny <- x\n\ny[[3]] <- 4\nx\n#> [1] 1 2 3"},{"path":"names-values.html","id":"tracemem","chapter":"2 Names and values","heading":"2.3.1 tracemem()","text":"can see object gets copied help base::tracemem(). call function object, ’ll get object’s current address:, whenever object copied, tracemem() print message telling object copied, new address, sequence calls led copy:modify y , won’t get copied. ’s new object now single name bound , R applies modify--place optimisation. ’ll come back Section 2.5.untracemem() opposite tracemem(); turns tracing .","code":"\nx <- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n#> <0x7f80c0e0ffc8> \ny <- x\ny[[3]] <- 4L\n#> tracemem[0x7f80c0e0ffc8 -> 0x7f80c4427f40]: \ny[[3]] <- 5L\n\nuntracemem(x)"},{"path":"names-values.html","id":"function-calls","chapter":"2 Names and values","heading":"2.3.2 Function calls","text":"rules copying also apply function calls. Take code:f() running, inside function points value x outside function:’ll learn conventions used diagram Section 4.4.4. brief: function f() depicted yellow object right. formal argument, , becomes binding (indicated dotted black line) execution environment (gray box) function run.f() completes, x z point object. 0x74b never gets copied never gets modified. f() modify x, R create new copy, z bind object.","code":"\nf <- function(a) {\n  a\n}\n\nx <- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n#> <0x559ea06c1eb8>\n\nz <- f(x)\n# there's no copy here!\n\nuntracemem(x)"},{"path":"names-values.html","id":"list-references","chapter":"2 Names and values","heading":"2.3.3 Lists","text":"’s just names (.e. variables) point values; elements lists . Consider list, superficially similar numeric vector :list complex instead storing values , stores references :particularly important modify list:Like vectors, lists use copy--modify behaviour; original list left unchanged, R creates modified copy. , however, shallow copy: list object bindings copied, values pointed bindings . opposite shallow copy deep copy contents every reference copied. Prior R 3.1.0, copies always deep copies.see values shared across lists, use lobstr::ref(). ref() prints memory address object, along local ID can easily cross-reference shared components.","code":"\nl1 <- list(1, 2, 3)\nl2 <- l1\nl2[[3]] <- 4\nref(l1, l2)\n#> █ [1:0x559e9f81df58] <list> \n#> ├─[2:0x559e9e5ad4d8] <dbl> \n#> ├─[3:0x559e9e5ad4a0] <dbl> \n#> └─[4:0x559e9e5ad468] <dbl> \n#>  \n#> █ [5:0x559e9fc30ed8] <list> \n#> ├─[2:0x559e9e5ad4d8] \n#> ├─[3:0x559e9e5ad4a0] \n#> └─[6:0x559e9f116530] <dbl>"},{"path":"names-values.html","id":"df-modify","chapter":"2 Names and values","heading":"2.3.4 Data frames","text":"Data frames lists vectors, copy--modify important consequences modify data frame. Take data frame example:modify column, column needs modified; others still point original references:However, modify row, every column modified, means every column must copied:","code":"\nd1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\nd2 <- d1\nd2[, 2] <- d2[, 2] * 2\nd3 <- d1\nd3[1, ] <- d3[1, ] * 3"},{"path":"names-values.html","id":"character-vectors","chapter":"2 Names and values","heading":"2.3.5 Character vectors","text":"final place R uses references character vectors12. usually draw character vectors like :polite fiction. R actually uses global string pool element character vector pointer unique string pool:can request ref() show references setting character argument TRUE:profound impact amount memory character vector uses otherwise generally unimportant, elsewhere book ’ll draw character vectors strings lived inside vector.","code":"\nx <- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n#> █ [1:0x559e9f8f9dd8] <chr> \n#> ├─[2:0x559e9a541358] <string: \"a\"> \n#> ├─[2:0x559e9a541358] \n#> ├─[3:0x559e9e34bf80] <string: \"abc\"> \n#> └─[4:0x559e9a6f6c78] <string: \"d\">"},{"path":"names-values.html","id":"exercises-1","chapter":"2 Names and values","heading":"2.3.6 Exercises","text":"tracemem(1:10) useful?tracemem(1:10) useful?Explain tracemem() shows two copies run code.\nHint: carefully look difference code code\nshown earlier section.\n\nx <- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] <- 4Explain tracemem() shows two copies run code.\nHint: carefully look difference code code\nshown earlier section.Sketch relationship following objects:\n\n<- 1:10\nb <- list(, )\nc <- list(b, , 1:10)Sketch relationship following objects:happens run code?\n\nx <- list(1:10)\nx[[2]] <- x\nDraw picture.happens run code?Draw picture.","code":"\nx <- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] <- 4\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\nx <- list(1:10)\nx[[2]] <- x"},{"path":"names-values.html","id":"object-size","chapter":"2 Names and values","heading":"2.4 Object size","text":"can find much memory object takes lobstr::obj_size()13:Since elements lists references values, size list might much smaller expect:y 80 bytes14 bigger x. ’s size empty list three elements:Similarly, R uses global string pool character vectors take less memory might expect: repeating string 100 times make take 100 times much memory.References also make challenging think size individual objects. obj_size(x) + obj_size(y) equal obj_size(x, y) shared values. , combined size x y size y:Finally, R 3.5.0 later versions feature might lead surprises: ALTREP, short alternative representation. allows R represent certain types vectors compactly. place likely see : instead storing every single number sequence, R just stores first last number. means every sequence, matter large, size:","code":"\nobj_size(letters)\n#> 1,712 B\nobj_size(ggplot2::diamonds)\n#> 3,456,344 B\nx <- runif(1e6)\nobj_size(x)\n#> 8,000,048 B\n\ny <- list(x, x, x)\nobj_size(y)\n#> 8,000,128 B\nobj_size(list(NULL, NULL, NULL))\n#> 80 B\nbanana <- \"bananas bananas bananas\"\nobj_size(banana)\n#> 136 B\nobj_size(rep(banana, 100))\n#> 928 B\nobj_size(x, y)\n#> 8,000,128 B\nobj_size(1:3)\n#> 680 B\nobj_size(1:1e3)\n#> 680 B\nobj_size(1:1e6)\n#> 680 B\nobj_size(1:1e9)\n#> 680 B"},{"path":"names-values.html","id":"exercises-2","chapter":"2 Names and values","heading":"2.4.1 Exercises","text":"following example, object.size(y) obj_size(y)\nradically different? Consult documentation object.size().\n\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\nobj_size(y)\n#> 80,896 BIn following example, object.size(y) obj_size(y)\nradically different? Consult documentation object.size().Take following list. size somewhat misleading?\n\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 17,608 BTake following list. size somewhat misleading?Predict output following code:\n\n<- runif(1e6)\nobj_size()\n\nb <- list(, )\nobj_size(b)\nobj_size(, b)\n\nb[[1]][[1]] <- 10\nobj_size(b)\nobj_size(, b)\n\nb[[2]][[1]] <- 10\nobj_size(b)\nobj_size(, b)Predict output following code:","code":"\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\nobj_size(y)\n#> 80,896 B\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 17,608 B\na <- runif(1e6)\nobj_size(a)\n\nb <- list(a, a)\nobj_size(b)\nobj_size(a, b)\n\nb[[1]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)\n\nb[[2]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)"},{"path":"names-values.html","id":"modify-in-place","chapter":"2 Names and values","heading":"2.5 Modify-in-place","text":"’ve seen , modifying R object usually creates copy. two exceptions:Objects single binding get special performance optimisation.Objects single binding get special performance optimisation.Environments, special type object, always modified place.Environments, special type object, always modified place.","code":""},{"path":"names-values.html","id":"single-binding","chapter":"2 Names and values","heading":"2.5.1 Objects with a single binding","text":"object single name bound , R modify place:(Note object IDs : v continues bind object, 0x207.)Two complications make predicting exactly R applies optimisation challenging:comes bindings, R can currently15 count 0, 1,\nmany. means object two bindings, one goes away,\nreference count go back 1: one less many \nstill many. turn, means R make copies sometimes\ndoesn’t need .comes bindings, R can currently15 count 0, 1,\nmany. means object two bindings, one goes away,\nreference count go back 1: one less many \nstill many. turn, means R make copies sometimes\ndoesn’t need .Whenever call vast majority functions, makes reference \nobject. exception specially written “primitive” C functions.\ncan written R-core occur mostly base package.Whenever call vast majority functions, makes reference \nobject. exception specially written “primitive” C functions.\ncan written R-core occur mostly base package.Together, two complications make hard predict whether copy occur. Instead, ’s better determine empirically tracemem().\n\nLet’s explore subtleties case study using loops. loops reputation slow R, often slowness caused every iteration loop creating copy. Consider following code. subtracts median column large data frame:loop surprisingly slow iteration loop copies data frame. can see using tracemem():fact, iteration copies data frame , twice, three times! Two copies made [[.data.frame, copy16 made [[.data.frame regular function increments reference count x.can reduce number copies using list instead data frame. Modifying list uses internal C code, references incremented single copy made:’s hard determine copy made, hard prevent . find resorting exotic tricks avoid copies, may time rewrite function C++, described Chapter ??.","code":"\nv <- c(1, 2, 3)\nv[[3]] <- 4\nx <- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians <- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] <- x[[i]] - medians[[i]]\n}\ncat(tracemem(x), \"\\n\")\n#> <0x7f80c429e020> \n\nfor (i in 1:5) {\n  x[[i]] <- x[[i]] - medians[[i]]\n}\n#> tracemem[0x7f80c429e020 -> 0x7f80c0c144d8]: \n#> tracemem[0x7f80c0c144d8 -> 0x7f80c0c14540]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14540 -> 0x7f80c0c145a8]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c145a8 -> 0x7f80c0c14610]: \n#> tracemem[0x7f80c0c14610 -> 0x7f80c0c14678]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14678 -> 0x7f80c0c146e0]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c146e0 -> 0x7f80c0c14748]: \n#> tracemem[0x7f80c0c14748 -> 0x7f80c0c147b0]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c147b0 -> 0x7f80c0c14818]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14818 -> 0x7f80c0c14880]: \n#> tracemem[0x7f80c0c14880 -> 0x7f80c0c148e8]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c148e8 -> 0x7f80c0c14950]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14950 -> 0x7f80c0c149b8]: \n#> tracemem[0x7f80c0c149b8 -> 0x7f80c0c14a20]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14a20 -> 0x7f80c0c14a88]: [[<-.data.frame [[<- \n\nuntracemem(x)\ny <- as.list(x)\ncat(tracemem(y), \"\\n\")\n#> <0x7f80c5c3de20>\n  \nfor (i in 1:5) {\n  y[[i]] <- y[[i]] - medians[[i]]\n}\n#> tracemem[0x7f80c5c3de20 -> 0x7f80c48de210]: "},{"path":"names-values.html","id":"env-modify","chapter":"2 Names and values","heading":"2.5.2 Environments","text":"\n’ll learn environments Chapter 4, ’s important mention behaviour different objects: environments always modified place. property sometimes described reference semantics modify environment existing bindings environment continue reference.Take environment, bind e1 e2:change binding, environment modified place:basic idea can used create functions “remember” previous state. See Section 6.2.4 details. property also used implement R6 object-oriented programming system, topic Chapter ??.One consequence environments can contain :unique property environments!","code":"\ne1 <- rlang::env(a = 1, b = 2, c = 3)\ne2 <- e1\ne1$c <- 4\ne2$c\n#> [1] 4\ne <- rlang::env()\ne$self <- e\n\nref(e)\n#> █ [1:0x559ea17a27c0] <env> \n#> └─self = [1:0x559ea17a27c0]"},{"path":"names-values.html","id":"exercises-3","chapter":"2 Names and values","heading":"2.5.3 Exercises","text":"Explain following code doesn’t create circular list.\n\nx <- list()\nx[[1]] <- xExplain following code doesn’t create circular list.Wrap two methods subtracting medians two functions, \nuse ‘bench’ package17 carefully compare speeds. \nperformance change number columns increase?Wrap two methods subtracting medians two functions, \nuse ‘bench’ package17 carefully compare speeds. \nperformance change number columns increase?happens attempt use tracemem() environment?happens attempt use tracemem() environment?","code":"\nx <- list()\nx[[1]] <- x"},{"path":"names-values.html","id":"gc","chapter":"2 Names and values","heading":"2.6 Unbinding and the garbage collector","text":"\n\nConsider code:created two objects, time code finishes, neither object bound name. objects get deleted? ’s job garbage collector, GC short. GC frees memory deleting R objects longer used, requesting memory operating system needed.R uses tracing GC. means traces every object ’s reachable global18 environment, objects , turn, reachable objects (.e. references lists environments searched recursively). garbage collector use modify--place reference count described . two ideas closely related, internal data structures optimised different use cases.garbage collector (GC) runs automatically whenever R needs memory create new object. Looking outside, ’s basically impossible predict GC run. fact, shouldn’t even try. want find GC runs, call gcinfo(TRUE) GC print message console every time runs.\ncan force garbage collection calling gc(). despite might read elsewhere, ’s never need call gc() . reasons might want call gc() ask R return memory operating system programs can use , side-effect tells much memory currently used:lobstr::mem_used() wrapper around gc() prints total number bytes used:number won’t agree amount memory reported operating system. three reasons:includes objects created R R interpreter.includes objects created R R interpreter.R operating system lazy: won’t reclaim memory\n’s actually needed. R might holding memory \nOS hasn’t yet asked back.R operating system lazy: won’t reclaim memory\n’s actually needed. R might holding memory \nOS hasn’t yet asked back.R counts memory occupied objects may empty gaps due \ndeleted objects. problem known memory fragmentation.R counts memory occupied objects may empty gaps due \ndeleted objects. problem known memory fragmentation.","code":"\nx <- 1:3\nx <- 2:4\nrm(x)\ngc() \n#>           used (Mb) gc trigger  (Mb) max used  (Mb)\n#> Ncells  909428 48.6    1771768  94.7  1678962  89.7\n#> Vcells 5066005 38.7   15610985 119.2 13870733 105.9\nmem_used()\n#> 91,429,448 B"},{"path":"names-values.html","id":"names-values-answers","chapter":"2 Names and values","heading":"2.7 Quiz answers","text":"must quote non-syntactic names backticks: `: example,\nvariables 1, 2, 3.\n\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\n\ndf$`3` <- df$`1` + df$`2`must quote non-syntactic names backticks: `: example,\nvariables 1, 2, 3.occupies 8 MB.\n\nx <- runif(1e6)\ny <- list(x, x, x)\nobj_size(y)\n#> 8,000,128 BIt occupies 8 MB.copied b modified, b[[1]] <- 10.copied b modified, b[[1]] <- 10.","code":"\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\n\ndf$`3` <- df$`1` + df$`2`\nx <- runif(1e6)\ny <- list(x, x, x)\nobj_size(y)\n#> 8,000,128 B"},{"path":"functions.html","id":"functions","chapter":"3 함수","heading":"3 함수","text":"","code":""},{"path":"functions.html","id":"introduction-2","chapter":"3 함수","heading":"3.1 Introduction","text":"\n’re reading book, ’ve probably already created many R functions know use reduce duplication code. chapter, ’ll learn turn informal, working knowledge rigorous, theoretical understanding. ’ll see interesting tricks techniques along way, keep mind ’ll learn important understanding advanced topics discussed later book.","code":""},{"path":"functions.html","id":"quiz-1","chapter":"3 함수","heading":"Quiz","text":"Answer following questions see can safely skip chapter. can find answers Section 3.9.three components function?three components function?following code return?\n\nx <- 10\nf1 <- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()following code return?usually write code?\n\n`+`(1, `*`(2, 3))usually write code?make call easier read?\n\nmean(, TRUE, x = c(1:10, NA))make call easier read?following code throw error executed? ?\n\nf2 <- function(, b) {\n  * 10\n}\nf2(10, stop(\"error!\"))following code throw error executed? ?infix function? write ? ’s replacement\nfunction? write ?infix function? write ? ’s replacement\nfunction? write ?ensure cleanup action occurs regardless function\nexits?ensure cleanup action occurs regardless function\nexits?","code":"\nx <- 10\nf1 <- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()\n`+`(1, `*`(2, 3))\nmean(, TRUE, x = c(1:10, NA))\nf2 <- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))"},{"path":"functions.html","id":"outline-1","chapter":"3 함수","heading":"Outline","text":"Section 3.2 describes basics creating \nfunction, three main components function, exception\nmany function rules: primitive functions (implemented C, \nR).Section 3.2 describes basics creating \nfunction, three main components function, exception\nmany function rules: primitive functions (implemented C, \nR).Section 3.3 discusses strengths weaknesses\nthree forms function composition commonly used R code.Section 3.3 discusses strengths weaknesses\nthree forms function composition commonly used R code.Section 3.4 shows R finds value associated\ngiven name, .e. rules lexical scoping.Section 3.4 shows R finds value associated\ngiven name, .e. rules lexical scoping.Section 3.5 devoted important property \nfunction arguments: evaluated used first time.Section 3.5 devoted important property \nfunction arguments: evaluated used first time.Section 3.6 discusses special ... argument, \nallows pass extra arguments another function.Section 3.6 discusses special ... argument, \nallows pass extra arguments another function.Section 3.7 discusses two primary ways \nfunction can exit, define exit handler, code run \nexit, regardless triggers .Section 3.7 discusses two primary ways \nfunction can exit, define exit handler, code run \nexit, regardless triggers .Section 3.8 shows various ways R\ndisguises ordinary function calls, can use standard prefix\nform better understand ’s going .Section 3.8 shows various ways R\ndisguises ordinary function calls, can use standard prefix\nform better understand ’s going .","code":""},{"path":"functions.html","id":"function-fundamentals","chapter":"3 함수","heading":"3.2 Function fundamentals","text":"understand functions R need internalise two important ideas:Functions can broken three components: arguments, body, environment.exceptions every rule, case, small selection “primitive” base functions implemented purely C.Functions objects, just vectors objects.","code":""},{"path":"functions.html","id":"fun-components","chapter":"3 함수","heading":"3.2.1 Function components","text":"\n\n\n\n\n\n\nfunction three parts:formals(), list arguments control call function.formals(), list arguments control call function.body(), code inside function.body(), code inside function.environment(), data structure determines function finds\nvalues associated names.environment(), data structure determines function finds\nvalues associated names.formals body specified explicitly create function, environment specified implicitly, based defined function. function environment always exists, printed function isn’t defined global environment.’ll draw functions following diagram. black dot left environment. two blocks right function arguments.Like objects R, functions can also possess number additional attributes(). One attribute used base R srcref, short source reference. points source code used create function. srcref used printing , unlike body(), contains code comments formatting.","code":"\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n#> $x\n#> \n#> \n#> $y\n\nbody(f02)\n#> {\n#>     x + y\n#> }\n\nenvironment(f02)\n#> <environment: R_GlobalEnv>\nattr(f02, \"srcref\")\n#> function(x, y) {\n#>   # A comment\n#>   x + y\n#> }"},{"path":"functions.html","id":"primitive-functions","chapter":"3 함수","heading":"3.2.2 Primitive functions","text":"\n\none exception rule function three components. Primitive functions, like sum() [, call C code directly.either type builtin type special.functions exist primarily C, R, formals(), body(), environment() NULL:Primitive functions found base package. certain performance advantages, benefit comes price: harder write. reason, R-core generally avoids creating unless option.","code":"\nsum\n#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n#> .Primitive(\"[\")\ntypeof(sum)\n#> [1] \"builtin\"\ntypeof(`[`)\n#> [1] \"special\"\nformals(sum)\n#> NULL\nbody(sum)\n#> NULL\nenvironment(sum)\n#> NULL"},{"path":"functions.html","id":"first-class-functions","chapter":"3 함수","heading":"3.2.3 First-class functions","text":"\n’s important understand R functions objects right, language property often called “first-class functions.” Unlike many languages, special syntax defining naming function: simply create function object (function) bind name <-:almost always create function bind name, binding step compulsory. choose give function name, get anonymous function. useful ’s worth effort figure name:final option put functions list:R, ’ll often see functions called closures. name reflects fact R functions capture, enclose, environments, ’ll learn Section 4.4.2.","code":"\nf01 <- function(x) {\n  sin(1 / x ^ 2)\n}\nlapply(mtcars, function(x) length(unique(x)))\nFilter(function(x) !is.numeric(x), mtcars)\nintegrate(function(x) sin(x) ^ 2, 0, pi)\nfuns <- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n#> [1] 20"},{"path":"functions.html","id":"invoking-a-function","chapter":"3 함수","heading":"3.2.4 Invoking a function","text":"normally call function placing arguments, wrapped parentheses, name: mean(1:10, na.rm = TRUE). 인수들이 데이터 구조 안에 있으면 어떻게 할까?.call() 을 대신 사용하면 된다: 두 개의 인수를 취하는데, 호출하는 함수와 함수 인수들을 포함한 리스트이다.’ll come back idea Section ??.","code":"\nargs <- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n#> [1] 5.5"},{"path":"functions.html","id":"exercises-4","chapter":"3 함수","heading":"3.2.5 Exercises","text":"Given name, like \"mean\", match.fun() lets find function.\nGiven function, can find name? doesn’t make sense R?Given name, like \"mean\", match.fun() lets find function.\nGiven function, can find name? doesn’t make sense R?’s possible (although typically useful) call anonymous function.\ntwo approaches correct? ?\n\nfunction(x) 3()\n#> function(x) 3()\n(function(x) 3)()\n#> [1] 3It’s possible (although typically useful) call anonymous function.\ntwo approaches correct? ?good rule thumb anonymous function fit one line\nshouldn’t need use {}. Review code. \nused anonymous function instead named function? \nused named function instead anonymous function?good rule thumb anonymous function fit one line\nshouldn’t need use {}. Review code. \nused anonymous function instead named function? \nused named function instead anonymous function?function allows tell object function? function\nallows tell function primitive function?function allows tell object function? function\nallows tell function primitive function?code makes list functions base package.\n\nobjs <- mget(ls(\"package:base\", = TRUE), inherits = TRUE)\nfuns <- Filter(.function, objs)\nUse answer following questions:\nbase function arguments?\nmany base functions arguments? ’s special \nfunctions?\nadapt code find primitive functions?\ncode makes list functions base package.Use answer following questions:base function arguments?base function arguments?many base functions arguments? ’s special \nfunctions?many base functions arguments? ’s special \nfunctions?adapt code find primitive functions?adapt code find primitive functions?three important components function?three important components function?printing function show environment created ?printing function show environment created ?","code":"\nfunction(x) 3()\n#> function(x) 3()\n(function(x) 3)()\n#> [1] 3\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)"},{"path":"functions.html","id":"function-composition","chapter":"3 함수","heading":"3.3 Function composition","text":"\n\n\nBase R provides two ways compose multiple function calls. example, imagine want compute population standard deviation using sqrt() mean() building blocks:either nest function calls:save intermediate results variables:magrittr package19 provides third option: binary operator %>%, called pipe pronounced “.”x %>% f() equivalent f(x); x %>% f(y) equivalent f(x, y). pipe allows focus high-level composition functions rather low-level flow data; focus ’s done (verbs), rather ’s modified (nouns). style common Haskell F#, main inspiration magrittr, default style stack based programming languages like Forth Factor.three options strengths weaknesses:Nesting, f(g(x)), concise, well suited short sequences. \nlonger sequences hard read read inside \nright left. result, arguments can get spread long distances\ncreating Dagwood\nsandwich problem.Nesting, f(g(x)), concise, well suited short sequences. \nlonger sequences hard read read inside \nright left. result, arguments can get spread long distances\ncreating Dagwood\nsandwich problem.Intermediate objects, y <- f(x); g(y), requires name intermediate\nobjects. strength objects important, weakness \nvalues truly intermediate.Intermediate objects, y <- f(x); g(y), requires name intermediate\nobjects. strength objects important, weakness \nvalues truly intermediate.Piping, x %>% f() %>% g(), allows read code straightforward\nleft--right fashion doesn’t require name intermediate objects.\ncan use linear sequences transformations single\nobject. also requires additional third party package assumes \nreader understands piping.Piping, x %>% f() %>% g(), allows read code straightforward\nleft--right fashion doesn’t require name intermediate objects.\ncan use linear sequences transformations single\nobject. also requires additional third party package assumes \nreader understands piping.code use combination three styles. Piping common data analysis code, much analysis consists sequence transformations object (like data frame plot). tend use piping infrequently packages; bad idea, ’s often less natural fit.","code":"\nsquare <- function(x) x^2\ndeviation <- function(x) x - mean(x)\nx <- runif(100)\n\nsqrt(mean(square(deviation(x))))\n#> [1] 0.274\nout <- deviation(x)\nout <- square(out)\nout <- mean(out)\nout <- sqrt(out)\nout\n#> [1] 0.274\nlibrary(magrittr)\n\nx %>%\n  deviation() %>%\n  square() %>%\n  mean() %>%\n  sqrt()\n#> [1] 0.274"},{"path":"functions.html","id":"lexical-scoping","chapter":"3 함수","heading":"3.4 Lexical scoping","text":"Chapter 2, discussed assignment, act binding name value. ’ll discuss scoping, act finding value associated name.basic rules scoping quite intuitive, ’ve probably already internalised , even never explicitly studied . example, following code return, 10 20?20In section, ’ll learn formal rules scoping well subtle details. deeper understanding scoping help use advanced functional programming tools, eventually, even write tools translate R code languages.R uses lexical scoping21: 함수가 호출되는 방식이 아닌 정의된 방식에 기초하여 이름의 값을 조회한다. 여기서 “Lexical” 은 단어나 어휘와 관련한 의미를 뜻하는 영어 형용사가 아니다. 이는 스코핑 법칙이 run-time 구조가 아닌 parse-time 을 사용한다는 것을 알리는 컴퓨터 공학의 기술용어다.R’s lexical scoping follows four primary rules:Name maskingFunctions versus variablesA fresh startDynamic lookup","code":"\nx <- 10\ng01 <- function() {\n  x <- 20\n  x\n}\n\ng01()"},{"path":"functions.html","id":"name-masking","chapter":"3 함수","heading":"3.4.1 Name masking","text":"basic principle lexical scoping names defined inside function mask names defined outside function. illustrated following example.name isn’t defined inside function, R looks one level .rules apply function defined inside another function. First, R looks inside current function. , looks function defined (, way global environment). Finally, looks loaded packages.Run following code head, confirm result running code.22The rules also apply functions created functions, call manufactured functions, topic Chapter ??.","code":"\nx <- 10\ny <- 20\ng02 <- function() {\n  x <- 1\n  y <- 2\n  c(x, y)\n}\ng02()\n#> [1] 1 2\nx <- 2\ng03 <- function() {\n  y <- 1\n  c(x, y)\n}\ng03()\n#> [1] 2 1\n\n# And this doesn't change the previous value of y\ny\n#> [1] 20\nx <- 1\ng04 <- function() {\n  y <- 2\n  i <- function() {\n    z <- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()"},{"path":"functions.html","id":"functions-versus-variables","chapter":"3 함수","heading":"3.4.2 Functions versus variables","text":"R, functions ordinary objects. means scoping rules described also apply functions:However, function non-function share name (must, course, reside different environments), applying rules gets little complicated. use name function call, R ignores non-function objects looking value. example, code , g09 takes two different values:record, using name different things confusing best avoided!","code":"\ng07 <- function(x) x + 1\ng08 <- function() {\n  g07 <- function(x) x + 100\n  g07(10)\n}\ng08()\n#> [1] 110\ng09 <- function(x) x + 100\ng10 <- function() {\n  g09 <- 10\n  g09(g09)\n}\ng10()\n#> [1] 110"},{"path":"functions.html","id":"fresh-start","chapter":"3 함수","heading":"3.4.3 A fresh start","text":"happens values invocations function? Consider example . happen first time run function? happen second time?23 (haven’t seen exists() , returns TRUE ’s variable name returns FALSE .)might surprised g11() always returns value. happens every time function called new environment created host execution. means function way tell happened last time run; invocation completely independent. ’ll see ways get around Section 6.2.4.","code":"\ng11 <- function() {\n  if (!exists(\"a\")) {\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\n\ng11()\ng11()"},{"path":"functions.html","id":"dynamic-lookup","chapter":"3 함수","heading":"3.4.4 Dynamic lookup","text":"Lexical scoping determines , look values. R looks values function run, function created. Together, two properties tell us output function can differ depending objects outside function’s environment:behaviour can quite annoying. make spelling mistake code, won’t get error message create function. depending variables defined global environment, might even get error message run function.detect problem, use codetools::findGlobals(). function lists external dependencies (unbound symbols) within function:solve problem, can manually change function’s environment emptyenv(), environment contains nothing:problem solution reveal seemingly undesirable behaviour exists: R relies lexical scoping find everything, obvious, like mean(), less obvious, like + even {. gives R’s scoping rules rather beautiful simplicity.","code":"\ng12 <- function() x + 1\nx <- 15\ng12()\n#> [1] 16\n\nx <- 20\ng12()\n#> [1] 21\ncodetools::findGlobals(g12)\n#> [1] \"+\" \"x\"\nenvironment(g12) <- emptyenv()\ng12()\n#> Error in x + 1: could not find function \"+\""},{"path":"functions.html","id":"exercises-5","chapter":"3 함수","heading":"3.4.5 Exercises","text":"following code return? ? Describe three\nc’s interpreted.\n\nc <- 10\nc(c = c)following code return? ? Describe three\nc’s interpreted.four principles govern R looks values?four principles govern R looks values?following function return? Make prediction \nrunning code .\n\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)following function return? Make prediction \nrunning code .","code":"\nc <- 10\nc(c = c)\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)"},{"path":"functions.html","id":"lazy-evaluation","chapter":"3 함수","heading":"3.5 Lazy evaluation","text":"\n\nR, function arguments lazily evaluated: ’re evaluated accessed. example, code doesn’t generate error x never used:important feature allows things like include potentially expensive computations function arguments evaluated needed.","code":"\nh01 <- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n#> [1] 10"},{"path":"functions.html","id":"promises","chapter":"3 함수","heading":"3.5.1 Promises","text":"\nLazy evaluation powered data structure called promise, (less commonly) thunk. ’s one features makes R interesting programming language (’ll return promises Section ??).promise three components:expression, like x + y, gives rise delayed computation.expression, like x + y, gives rise delayed computation.environment expression evaluated, .e. \nenvironment function called. makes sure \nfollowing function returns 11, 101:\n\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\n\nh02(y)\n#> [1] 11\nalso means assignment inside call function,\nvariable bound outside function, inside .\n\nh02(y <- 1000)\n#> [1] 1001\ny\n#> [1] 1000An environment expression evaluated, .e. \nenvironment function called. makes sure \nfollowing function returns 11, 101:also means assignment inside call function,\nvariable bound outside function, inside .value, computed cached first time promise \naccessed expression evaluated specified environment.\nensures promise evaluated , \nsee “Calculating…” printed following example.\n\ndouble <- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 <- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#> Calculating...\n#> [1] 40 40A value, computed cached first time promise \naccessed expression evaluated specified environment.\nensures promise evaluated , \nsee “Calculating…” printed following example.manipulate promises R code. Promises like quantum state: attempt inspect R code force immediate evaluation, making promise disappear. Later, Section ??, ’ll learn quosures, convert promises R object can easily inspect expression environment.","code":"\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\n\nh02(y)\n#> [1] 11\nh02(y <- 1000)\n#> [1] 1001\ny\n#> [1] 1000\ndouble <- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 <- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#> Calculating...\n#> [1] 40 40"},{"path":"functions.html","id":"default-arguments","chapter":"3 함수","heading":"3.5.2 Default arguments","text":"Thanks lazy evaluation, default values can defined terms arguments, even terms variables defined later function:Many base R functions use technique, don’t recommend . makes code harder understand: predict returned, need know exact order default arguments evaluated.evaluation environment slightly different default user supplied arguments, default arguments evaluated inside function. means seemingly identical calls can yield different results. ’s easiest see extreme example:","code":"\nh04 <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 10\n  b <- 100\n  \n  c(x, y, z)\n}\n\nh04()\n#> [1]   1   2 110\nh05 <- function(x = ls()) {\n  a <- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n#> [1] \"a\" \"x\"\n\n# ls() evaluated in global environment:\nh05(ls())\n#> [1] \"h05\""},{"path":"functions.html","id":"missing-arguments","chapter":"3 함수","heading":"3.5.3 Missing arguments","text":"\ndetermine argument’s value comes user default, can use missing():missing() best used sparingly, however. Take sample(), example. many arguments required?looks like x size required, size supplied, sample() uses missing() provide default. rewrite sample, ’d use explicit NULL indicate size required can supplied:binary pattern created %||% infix function, uses left side ’s NULL right side otherwise, can simplify sample():\nlazy evaluation, don’t need worry unnecessary computation: right side %||% evaluated left side NULL.","code":"\nh06 <- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n#> List of 2\n#>  $ : logi TRUE\n#>  $ : num 10\nstr(h06(10))\n#> List of 2\n#>  $ : logi FALSE\n#>  $ : num 10\nargs(sample)\n#> function (x, size, replace = FALSE, prob = NULL) \n#> NULL\nsample <- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  if (is.null(size)) {\n    size <- length(x)\n  }\n  \n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}\n`%||%` <- function(lhs, rhs) {\n  if (!is.null(lhs)) {\n    lhs\n  } else {\n    rhs\n  }\n}\n\nsample <- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  size <- size %||% length(x)\n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}"},{"path":"functions.html","id":"exercises-6","chapter":"3 함수","heading":"3.5.4 Exercises","text":"important property && makes x_ok() work?\n\nx_ok <- function(x) {\n  !.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE\ndifferent code? behaviour undesirable ?\n\nx_ok <- function(x) {\n  !.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE FALSE FALSEWhat important property && makes x_ok() work?different code? behaviour undesirable ?function return? ? principle illustrate?\n\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()function return? ? principle illustrate?function return? ? principle illustrate?\n\ny <- 10\nf1 <- function(x = {y <- 1; 2}, y = 0) {\n  c(x, y)\n}\nf1()\nyWhat function return? ? principle illustrate?hist(), default value xlim range(breaks), default\nvalue breaks \"Sturges\", \n\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nExplain hist() works get correct xlim value.hist(), default value xlim range(breaks), default\nvalue breaks \"Sturges\", andExplain hist() works get correct xlim value.Explain function works. confusing?\n\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#> [1] \"2021-10-18 00:50:05 UTC\"Explain function works. confusing?many arguments required calling library()?many arguments required calling library()?","code":"\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE FALSE FALSE\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()\ny <- 10\nf1 <- function(x = {y <- 1; 2}, y = 0) {\n  c(x, y)\n}\nf1()\ny\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#> [1] \"2021-10-18 00:50:05 UTC\""},{"path":"functions.html","id":"fun-dot-dot-dot","chapter":"3 함수","heading":"3.6 ... (dot-dot-dot)","text":"\n\nFunctions can special argument ... (pronounced dot-dot-dot). , function can take number additional arguments. programming languages, type argument often called varargs (short variable arguments), function uses said variadic.can also use ... pass additional arguments another function.Using special form, ..N, ’s possible (rarely useful) refer elements ... position:useful list(...), evaluates arguments stores list:(See also rlang::list2() support splicing silently ignore trailing commas, rlang::enquos() capture unevaluated arguments, topic [quasiquotation].)two primary uses ..., ’ll come back later book:function takes function argument, want way \npass additional arguments function. example, lapply()\nuses ... pass na.rm mean():\n\nx <- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#> List 2\n#>  $ : num 2\n#>  $ : num 5\n’ll come back technique Section 5.2.3.function takes function argument, want way \npass additional arguments function. example, lapply()\nuses ... pass na.rm mean():’ll come back technique Section 5.2.3.function S3 generic, need way allow methods \ntake arbitrary extra arguments. example, take print() function.\ndifferent options printing depending type \nobject, ’s way pre-specify every possible argument ...\nallows individual methods different arguments:\n\nprint(factor(letters), max.levels = 4)\n\nprint(y ~ x, showEnv = TRUE)\n’ll come back use ... Section ??.function S3 generic, need way allow methods \ntake arbitrary extra arguments. example, take print() function.\ndifferent options printing depending type \nobject, ’s way pre-specify every possible argument ...\nallows individual methods different arguments:’ll come back use ... Section ??.Using ... comes two downsides:use pass arguments another function, \ncarefully explain user arguments go. makes \nhard understand can functions like lapply() \nplot().use pass arguments another function, \ncarefully explain user arguments go. makes \nhard understand can functions like lapply() \nplot().misspelled argument raise error. makes easy \ntypos go unnoticed:\n\nsum(1, 2, NA, na_rm = TRUE)\n#> [1] NAA misspelled argument raise error. makes easy \ntypos go unnoticed:","code":"\ni01 <- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 <- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n#> List of 2\n#>  $ y: num 2\n#>  $ z: num 3\ni03 <- function(...) {\n  list(first = ..1, third = ..3)\n}\nstr(i03(1, 2, 3))\n#> List of 2\n#>  $ first: num 1\n#>  $ third: num 3\ni04 <- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n#> List of 2\n#>  $ a: num 1\n#>  $ b: num 2\nx <- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#> List of 2\n#>  $ : num 2\n#>  $ : num 5\nprint(factor(letters), max.levels = 4)\n\nprint(y ~ x, showEnv = TRUE)\nsum(1, 2, NA, na_rm = TRUE)\n#> [1] NA"},{"path":"functions.html","id":"exercises-7","chapter":"3 함수","heading":"3.6.1 Exercises","text":"Explain following results:\n\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1Explain following results:Explain find documentation named arguments \nfollowing function call:\n\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\nExplain find documentation named arguments \nfollowing function call:plot(1:10, col = \"red\") colour points, axes\nlabels? Read source code plot.default() find .plot(1:10, col = \"red\") colour points, axes\nlabels? Read source code plot.default() find .","code":"\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")"},{"path":"functions.html","id":"exiting-a-function","chapter":"3 함수","heading":"3.7 Exiting a function","text":"functions exit one two ways24: either return value, indicating success, throw error, indicating failure. section describes return values (implicit versus explicit; visible versus invisible), briefly discusses errors, introduces exit handlers, allow run code function exits.","code":""},{"path":"functions.html","id":"implicit-versus-explicit-returns","chapter":"3 함수","heading":"3.7.1 Implicit versus explicit returns","text":"\ntwo ways function can return value:Implicitly, last evaluated expression return value:\n\nj01 <- function(x) {\n  (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#> [1] 0\nj01(15)\n#> [1] 10Implicitly, last evaluated expression return value:Explicitly, calling return():\n\nj02 <- function(x) {\n  (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}Explicitly, calling return():","code":"\nj01 <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#> [1] 0\nj01(15)\n#> [1] 10\nj02 <- function(x) {\n  if (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}"},{"path":"functions.html","id":"invisible","chapter":"3 함수","heading":"3.7.2 Invisible values","text":"\nfunctions return visibly: calling function interactive context prints result.However, can prevent automatic printing applying invisible() last value:verify value indeed exist, can explicitly print wrap parentheses:Alternatively, can use withVisible() return value visibility flag:common function returns invisibly <-:makes possible chain assignments:general, function called primarily side effect (like <-, print(), plot()) return invisible value (typically value first argument).","code":"\nj03 <- function() 1\nj03()\n#> [1] 1\nj04 <- function() invisible(1)\nj04()\nprint(j04())\n#> [1] 1\n\n(j04())\n#> [1] 1\nstr(withVisible(j04()))\n#> List of 2\n#>  $ value  : num 1\n#>  $ visible: logi FALSE\na <- 2\n(a <- 2)\n#> [1] 2\na <- b <- c <- d <- 2"},{"path":"functions.html","id":"errors","chapter":"3 함수","heading":"3.7.3 Errors","text":"function complete assigned task, throw error stop(), immediately terminates execution function.error indicates something gone wrong, forces user deal problem. languages (like C, Go, Rust) rely special return values indicate problems, R always throw error. ’ll learn errors, handle , Chapter ??.","code":"\nj05 <- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n#> Error in j05(): I'm an error"},{"path":"functions.html","id":"on-exit","chapter":"3 함수","heading":"3.7.4 Exit handlers","text":"Sometimes function needs make temporary changes global state. cleanup changes can painful (happens ’s error?). ensure changes undone global state restored matter function exits, use .exit() set exit handler. following simple example shows exit handler run regardless whether function exits normally error.Always set add = TRUE using .exit(). don’t, call .exit() overwrite previous exit handler. Even registering single handler, ’s good practice set add = TRUE won’t get unpleasant surprises later add exit handlers..exit() useful allows place clean-code directly next code requires clean-:Coupled lazy evaluation, creates useful pattern running block code altered environment:use force() isn’t strictly necessary simply referring code force evaluation. However, using force() makes clear deliberately forcing execution. ’ll learn uses force() Chapter ??.withr package25 provides collection functions setting temporary state.R 3.4 earlier, .exit() expressions always run order creation:can make cleanup little tricky actions need happen specific order; typically want recent added expression run first. R 3.5 later, can control setting = FALSE:","code":"\nj06 <- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE)\n  \n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n\nj06(TRUE)\n#> Hello\n#> Goodbye!\n#> [1] 10\n\nj06(FALSE)\n#> Hello\n#> Error in j06(FALSE): Error\n#> Goodbye!\ncleanup <- function(dir, code) {\n  old_dir <- setwd(dir)\n  on.exit(setwd(old_dir), add = TRUE)\n  \n  old_opt <- options(stringsAsFactors = FALSE)\n  on.exit(options(old_opt), add = TRUE)\n}\nwith_dir <- function(dir, code) {\n  old <- setwd(dir)\n  on.exit(setwd(old), add = TRUE)\n\n  force(code)\n}\n\ngetwd()\n#> [1] \"/home/sgkim/adv-r\"\nwith_dir(\"~\", getwd())\n#> [1] \"/home/sgkim\"\nj08 <- function() {\n  on.exit(message(\"a\"), add = TRUE)\n  on.exit(message(\"b\"), add = TRUE)\n}\nj08()\n#> a\n#> b\nj09 <- function() {\n  on.exit(message(\"a\"), add = TRUE, after = FALSE)\n  on.exit(message(\"b\"), add = TRUE, after = FALSE)\n}\nj09()\n#> b\n#> a"},{"path":"functions.html","id":"exercises-8","chapter":"3 함수","heading":"3.7.5 Exercises","text":"load() return? don’t normally see values?load() return? don’t normally see values?write.table() return? useful?write.table() return? useful?chdir parameter source() compare with_dir()? \nmight prefer one ?chdir parameter source() compare with_dir()? \nmight prefer one ?Write function opens graphics device, runs supplied code, \ncloses graphics device (always, regardless whether \nplotting code works).Write function opens graphics device, runs supplied code, \ncloses graphics device (always, regardless whether \nplotting code works).can use .exit() implement simple version capture.output().\n\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  .exit(file.remove(temp), add = TRUE, = TRUE)\n\n  sink(temp)\n  .exit(sink(), add = TRUE, = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"\", \"b\", \"c\", sep = \"\\n\"))\n#> [1] \"\" \"b\" \"c\"\nCompare capture.output() capture.output2(). functions\ndiffer? features removed make key ideas easier see?\nrewritten key ideas ’re easier understand?can use .exit() implement simple version capture.output().Compare capture.output() capture.output2(). functions\ndiffer? features removed make key ideas easier see?\nrewritten key ideas ’re easier understand?","code":"\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n#> [1] \"a\" \"b\" \"c\""},{"path":"functions.html","id":"function-forms","chapter":"3 함수","heading":"3.8 Function forms","text":"understand computations R, two slogans helpful:Everything exists object.Everything happens function call.— John ChambersWhile everything happens R result function call, calls look . Function calls come four varieties:prefix: function name comes arguments, like\nfoofy(, b, c). constitute majority function calls R.prefix: function name comes arguments, like\nfoofy(, b, c). constitute majority function calls R.infix: function name comes arguments, like\nx + y. Infix forms used many mathematical operators, \nuser-defined functions begin end %.infix: function name comes arguments, like\nx + y. Infix forms used many mathematical operators, \nuser-defined functions begin end %.replacement: functions replace values assignment, like\nnames(df) <- c(\"\", \"b\", \"c\"). actually look like prefix functions.replacement: functions replace values assignment, like\nnames(df) <- c(\"\", \"b\", \"c\"). actually look like prefix functions.special: functions like [[, , . don’t \nconsistent structure, play important roles R’s syntax.special: functions like [[, , . don’t \nconsistent structure, play important roles R’s syntax.four forms, actually need one call can written prefix form. ’ll demonstrate property, ’ll learn forms turn.","code":""},{"path":"functions.html","id":"prefix-transform","chapter":"3 함수","heading":"3.8.1 Rewriting to prefix form","text":"\n\ninteresting property R every infix, replacement, special form can rewritten prefix form. useful helps better understand structure language, gives real name every function, allows modify functions fun profit.following example shows three pairs equivalent calls, rewriting infix form, replacement form, special form prefix form.Suprisingly, R, can called like regular function! true basically every operation R, means knowing function name non-prefix function allows override behaviour. example, ’re ever feeling particularly evil, run following code friend away computer. introduce fun bug: 10% time, add 1 numeric calculation inside parentheses.course, overriding built-functions like bad idea, , ’ll learn Section ??, ’s possible apply selected code blocks. provides clean elegant approach writing domain specific languages translators languages.useful application comes using functional programming tools. example, use lapply() add 3 every element list first defining function add():can also get result simply relying existing + function:’ll explore idea detail Section 5.","code":"\nx + y\n`+`(x, y)\n\nnames(df) <- c(\"x\", \"y\", \"z\")\n`names<-`(df, c(\"x\", \"y\", \"z\"))\n\nfor(i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n`(` <- function(e1) {\n  if (is.numeric(e1) && runif(1) < 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n#>  [1] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n#> [39] 4 3 4 3 3 3 3 4 3 3 3 3\nrm(\"(\")\nadd <- function(x, y) x + y\nlapply(list(1:3, 4:5), add, 3)\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8\nlapply(list(1:3, 4:5), `+`, 3)\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8"},{"path":"functions.html","id":"prefix-form","chapter":"3 함수","heading":"3.8.2 Prefix form","text":"\nprefix form common form R code, indeed majority programming languages. Prefix calls R little special can specify arguments three ways:position, like help(mean).Using partial matching, like help(top = mean).name, like help(topic = mean).illustrated following chunk, arguments matched exact name, unique prefixes, finally position.general, use positional matching first one two arguments; commonly used, readers know . Avoid using positional matching less commonly used arguments, never use partial matching. Unfortunately can’t disable partial matching, can turn warning warnPartialMatchArgs option:\n","code":"\nk01 <- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(1, 2, 3))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\nstr(k01(2, 3, abcdef = 1))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# But this doesn't work because abbreviation is ambiguous\nstr(k01(1, 3, b = 1))\n#> Error in k01(1, 3, b = 1): argument 3 matches multiple formal arguments\noptions(warnPartialMatchArgs = TRUE)\nx <- k01(a = 1, 2, 3)\n#> Warning in k01(a = 1, 2, 3): partial argument match of 'a' to 'abcdef'"},{"path":"functions.html","id":"infix-functions","chapter":"3 함수","heading":"3.8.3 Infix functions","text":"\n\nInfix functions get name fact function name comes inbetween arguments, hence two arguments. R comes number built-infix operators: :, ::, :::, $, @, ^, *, /, +, -, >, >=, <, <=, ==, !=, !, &, &&, |, ||, ~, <-, <<-. can also create infix functions start end %. Base R uses pattern define %%, %*%, %/%, %%, %o%, %x%.Defining infix function simple. create two argument function bind name starts ends %:names infix functions flexible regular R functions: can contain sequence characters except %. need escape special characters string used define function, call :R’s default precedence rules mean infix operators composed left right:two special infix functions can called single argument: + -.","code":"\n`%+%` <- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n#> [1] \"new string\"\n`% %` <- function(a, b) paste(a, b)\n`%/\\\\%` <- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n#> [1] \"a b\"\n\"a\" %/\\% \"b\"\n#> [1] \"a b\"\n`%-%` <- function(a, b) paste0(\"(\", a, \" %-% \", b, \")\")\n\"a\" %-% \"b\" %-% \"c\"\n#> [1] \"((a %-% b) %-% c)\"\n-1\n#> [1] -1\n+10\n#> [1] 10"},{"path":"functions.html","id":"replacement-functions","chapter":"3 함수","heading":"3.8.4 Replacement functions","text":"\n\nReplacement functions act like modify arguments place, special name xxx<-. must arguments named x value, must return modified object. example, following function modifies second element vector:Replacement functions used placing function call left side <-:say act like modify arguments place, , explained Section 2.5, actually create modified copy. can see using tracemem():replacement function needs additional arguments, place x value, call replacement function additional arguments left:write modify(x, 1) <- 10, behind scenes R turns :Combining replacement functions requires complex translation. example:translated :(Yes, really create local variable named *tmp*, removed afterwards.)","code":"\n`second<-` <- function(x, value) {\n  x[2] <- value\n  x\n}\nx <- 1:10\nsecond(x) <- 5L\nx\n#>  [1]  1  5  3  4  5  6  7  8  9 10\nx <- 1:10\ntracemem(x)\n#> <0x7ffae71bd880>\n\nsecond(x) <- 6L\n#> tracemem[0x7ffae71bd880 -> 0x7ffae61b5480]: \n#> tracemem[0x7ffae61b5480 -> 0x7ffae73f0408]: second<- \n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\nmodify(x, 1) <- 10\nx\n#>  [1] 10  5  3  4  5  6  7  8  9 10\nx <- `modify<-`(x, 1, 10)\nx <- c(a = 1, b = 2, c = 3)\nnames(x)\n#> [1] \"a\" \"b\" \"c\"\n\nnames(x)[2] <- \"two\"\nnames(x)\n#> [1] \"a\"   \"two\" \"c\"\n`*tmp*` <- x\nx <- `names<-`(`*tmp*`, `[<-`(names(`*tmp*`), 2, \"two\"))\nrm(`*tmp*`)"},{"path":"functions.html","id":"special-forms","chapter":"3 함수","heading":"3.8.5 Special forms","text":"\nFinally, bunch language features usually written special ways, also prefix forms. include parentheses:(x) (`(`(x)){x} (`{`(x)).subsetting operators:x[] (`[`(x, ))x[[]] (`[[`(x, ))tools control flow:(cond) true (``(cond, true))(cond) true else false (``(cond, true, false))(var seq) action (``(var, seq, action))(cond) action (``(cond, action))repeat expr (`repeat`(expr))next (`next`())break (`break`())Finally, complex function function:function(arg1, arg2) {body} (`function`(alist(arg1, arg2), body, env))Knowing name function underlies special form useful getting documentation: ?( syntax error; ?`(` give documentation parentheses.special forms implemented primitive functions (.e. C); means printing functions informative:","code":"\n`for`\n#> .Primitive(\"for\")"},{"path":"functions.html","id":"exercises-9","chapter":"3 함수","heading":"3.8.6 Exercises","text":"Rewrite following code snippets prefix form:\n\n1 + 2 + 3\n\n1 + (2 + 3)\n\n(length(x) <= 5) x[[5]] else x[[n]]Rewrite following code snippets prefix form:Clarify following list odd function calls:\n\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)Clarify following list odd function calls:Explain following code fails:\n\nmodify(get(\"x\"), 1) <- 10\n#> Error: target assignment expands non-language objectExplain following code fails:Create replacement function modifies random location vector.Create replacement function modifies random location vector.Write version + pastes inputs together \ncharacter vectors behaves usual otherwise. words, make \ncode work:\n\n1 + 2\n#> [1] 3\n\n\"\" + \"b\"\n#> [1] \"ab\"Write version + pastes inputs together \ncharacter vectors behaves usual otherwise. words, make \ncode work:Create list replacement functions found base package.\nones primitive functions? (Hint: use apropos().)Create list replacement functions found base package.\nones primitive functions? (Hint: use apropos().)valid names user-created infix functions?valid names user-created infix functions?Create infix xor() operator.Create infix xor() operator.Create infix versions set functions intersect(), union(), \nsetdiff(). might call %n%, %u%, %/% match\nconventions mathematics.Create infix versions set functions intersect(), union(), \nsetdiff(). might call %n%, %u%, %/% match\nconventions mathematics.","code":"\n1 + 2 + 3\n\n1 + (2 + 3)\n\nif (length(x) <= 5) x[[5]] else x[[n]]\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\nmodify(get(\"x\"), 1) <- 10\n#> Error: target of assignment expands to non-language object\n1 + 2\n#> [1] 3\n\n\"a\" + \"b\"\n#> [1] \"ab\""},{"path":"functions.html","id":"function-answers","chapter":"3 함수","heading":"3.9 Quiz answers","text":"three components function body, arguments, environment.three components function body, arguments, environment.f1(1)() returns 11.f1(1)() returns 11.’d normally write infix style: 1 + (2 * 3).’d normally write infix style: 1 + (2 * 3).Rewriting call mean(c(1:10, NA), na.rm = TRUE) easier \nunderstand.Rewriting call mean(c(1:10, NA), na.rm = TRUE) easier \nunderstand., throw error second argument never used\n’s never evaluated., throw error second argument never used\n’s never evaluated.See Sections 3.8.3 3.8.4.See Sections 3.8.3 3.8.4.use .exit(); see Section 3.7.4 details.use .exit(); see Section 3.7.4 details.","code":""},{"path":"environments.html","id":"environments","chapter":"4 환경","heading":"4 환경","text":"","code":""},{"path":"environments.html","id":"introduction-3","chapter":"4 환경","heading":"4.1 Introduction","text":"environment data structure powers scoping. chapter dives deep environments, describing structure depth, using improve understanding four scoping rules described Section 3.4.\nUnderstanding environments necessary day--day use R. important understand power many important R features like lexical scoping, namespaces, R6 classes, interact evaluation give powerful tools making domain specific languages, like dplyr ggplot2.","code":""},{"path":"environments.html","id":"quiz-2","chapter":"4 환경","heading":"Quiz","text":"can answer following questions correctly, already know important topics chapter. can find answers end chapter Section 4.7.List least three ways environment differs list.List least three ways environment differs list.parent global environment? \nenvironment doesn’t parent?parent global environment? \nenvironment doesn’t parent?enclosing environment function? \nimportant?enclosing environment function? \nimportant?determine environment function called?determine environment function called?<- <<- different?<- <<- different?","code":""},{"path":"environments.html","id":"outline-2","chapter":"4 환경","heading":"Outline","text":"Section 4.2 introduces basic properties\nenvironment shows create .Section 4.2 introduces basic properties\nenvironment shows create .Section 4.3 provides function template\ncomputing environments, illustrating idea useful\nfunction.Section 4.3 provides function template\ncomputing environments, illustrating idea useful\nfunction.Section 4.4 describes environments used special\npurposes: packages, within functions, namespaces, \nfunction execution.Section 4.4 describes environments used special\npurposes: packages, within functions, namespaces, \nfunction execution.Section 4.5 explains last important environment: \ncaller environment. requires learn call stack,\ndescribes function called. ’ll seen call stack\n’ve ever called traceback() aid debugging.Section 4.5 explains last important environment: \ncaller environment. requires learn call stack,\ndescribes function called. ’ll seen call stack\n’ve ever called traceback() aid debugging.Section 4.6 briefly discusses three places \nenvironments useful data structures solving problems.Section 4.6 briefly discusses three places \nenvironments useful data structures solving problems.","code":""},{"path":"environments.html","id":"prerequisites-1","chapter":"4 환경","heading":"Prerequisites","text":"chapter use rlang functions working environments, allows us focus essence environments, rather incidental details.env_ functions rlang designed work pipe: take environment first argument, many also return environment. won’t use pipe chapter interest keeping code simple possible, consider code.","code":"\nlibrary(rlang)"},{"path":"environments.html","id":"env-basics","chapter":"4 환경","heading":"4.2 Environment basics","text":"Generally, environment similar named list, four important exceptions:Every name must unique.Every name must unique.names environment ordered.names environment ordered.environment parent.environment parent.Environments copied modified.Environments copied modified.Let’s explore ideas code pictures.","code":""},{"path":"environments.html","id":"basics","chapter":"4 환경","heading":"4.2.1 Basics","text":"\n\n\nrlang::env() 를 사용하여 환경을 생성한다. list()와 같은 방법으로 작동시키는데, name-value 쌍의 집합들을 취한다.new.env() 를 사용하여 새로운 환경을 생성한다. hash 와 size 파라미터는 무시하는데, 필요하지 않다. 값을 생성하면서 동시에 정의할 수 없다; 아래에 나오듯이 $<- 을 사용하라.job environment associate, bind, set names set values. can think environment bag names, implied order (.e. doesn’t make sense ask first element environment). reason, ’ll draw environment :discussed Section 2.5.2, environments reference semantics: unlike R objects, modify , modify place, don’t create copy. One important implication environments can contain .Printing environment just displays memory address, terribly useful:Instead, ’ll use env_print() gives us little information:can use env_names() get character vector giving current bindingsIn R 3.2.0 greater, use names() list bindings environment. code needs work R 3.1.0 earlier, use ls(), note ’ll need set .names = TRUE show bindings.","code":"\ne1 <- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\ne1$d <- e1\ne1\n#> <environment: 0x5557dd3a00f0>\nenv_print(e1)\n#> <environment: 0x5557dd3a00f0>\n#> parent: <environment: global>\n#> bindings:\n#>  * a: <lgl>\n#>  * b: <chr>\n#>  * c: <dbl>\n#>  * d: <env>\nenv_names(e1)\n#> [1] \"a\" \"b\" \"c\" \"d\""},{"path":"environments.html","id":"주요-환경","chapter":"4 환경","heading":"4.2.2 주요 환경","text":"\n’ll talk detail special environments 4.4, now need mention two. current environment, current_env() environment code currently executing. ’re experimenting interactively, ’s usually global environment, global_env(). global environment sometimes called “workspace,” ’s interactive (.e. outside function) computation takes place.compare environments, need use identical() ==. == vectorised operator, environments vectors.Access global environment globalenv() current environment environment(). global environment printed R_GlobalEnv .GlobalEnv.","code":"\nidentical(global_env(), current_env())\n#> [1] TRUE\n\nglobal_env() == current_env()\n#> Error in global_env() == current_env(): comparison (1) is possible only for atomic and list types"},{"path":"environments.html","id":"parents","chapter":"4 환경","heading":"4.2.3 Parents","text":"\n모든 환경에는 parent 가 되는 다른 환경이 있다. 다이어그램에서 부모는 작은 하늘색 원과 다른 환경을 가르키는 화살표로 나타나 있다. 부모는 lexical scoping 을 구현하기 위해 사용되는 것이다: name found environment, R look parent (). can set parent environment supplying unnamed argument env(). don’t supply , defaults current environment. 아래 코드에서 e2a 는 e2b 의 부모이다.공간을 많이 차지하기 때문에 모든 조상을 다 그리지 않을 것이다. 하늘색 원을 볼 때마다 부모 환경이 어딘가에 있다는 것을 기억하라.can find parent environment env_parent():one environment doesn’t parent: empty environment. draw empty environment hollow parent environment, space allows ’ll label R_EmptyEnv, name R uses.ancestors every environment eventually terminate empty environment. can see ancestors env_parents():default, env_parents() stops gets global environment. useful ancestors global environment include every attached package, can see override default behaviour . ’ll come back environments Section 4.4.1.Use parent.env() find parent environment. base function returns ancestors.","code":"\ne2a <- env(d = 4, e = 5)\ne2b <- env(e2a, a = 1, b = 2, c = 3)\nenv_parent(e2b)\n#> <environment: 0x5557dba29770>\nenv_parent(e2a)\n#> <environment: R_GlobalEnv>\ne2c <- env(empty_env(), d = 4, e = 5)\ne2d <- env(e2c, a = 1, b = 2, c = 3)\nenv_parents(e2b)\n#> [[1]]   <env: 0x5557dba29770>\n#> [[2]] $ <env: global>\nenv_parents(e2d)\n#> [[1]]   <env: 0x5557dc7dd3f8>\n#> [[2]] $ <env: empty>\nenv_parents(e2b, last = empty_env())\n#>  [[1]]   <env: 0x5557dba29770>\n#>  [[2]] $ <env: global>\n#>  [[3]] $ <env: package:rlang>\n#>  [[4]] $ <env: package:stats>\n#>  [[5]] $ <env: package:graphics>\n#>  [[6]] $ <env: package:grDevices>\n#>  [[7]] $ <env: package:utils>\n#>  [[8]] $ <env: package:datasets>\n#>  [[9]] $ <env: package:methods>\n#> [[10]] $ <env: Autoloads>\n#> [[11]] $ <env: package:base>\n#> [[12]] $ <env: empty>"},{"path":"environments.html","id":"super-assignment--","chapter":"4 환경","heading":"4.2.4 Super assignment, <<-","text":"\nancestors environment important relationship <<-. Regular assignment, <-, always creates variable current environment. Super assignment, <<-, never creates variable current environment, instead modifies existing variable found parent environment.<<- doesn’t find existing variable, create one global environment. usually undesirable, global variables introduce non-obvious dependencies functions. <<- often used conjunction function factory, described Section 6.2.4.","code":"\nx <- 0\nf <- function() {\n  x <<- 1\n}\nf()\nx\n#> [1] 1"},{"path":"environments.html","id":"getting-and-setting","chapter":"4 환경","heading":"4.2.5 Getting and setting","text":"\ncan get set elements environment $ [[ way list:can’t use [[ numeric indices, can’t use [:$ [[ return NULL binding doesn’t exist. Use env_get() want error:바인딩이 존재하지 않을 때 디폴트 값을 사용하고 싶다면 default 인수를 사용하라.two ways add bindings environment:env_poke()26 takes name (string) value:\n\nenv_poke(e3, \"\", 100)\ne3$\n#> [1] 100env_poke()26 takes name (string) value:env_bind() allows bind multiple values:\n\nenv_bind(e3, = 10, b = 20)\nenv_names(e3)\n#> [1] \"x\" \"y\" \"z\" \"\" \"b\"env_bind() allows bind multiple values:can determine environment binding env_has():Unlike lists, setting element NULL remove , sometimes want name refers NULL. Instead, use env_unbind():Unbinding name doesn’t delete object. ’s job garbage collector, automatically removes objects names binding . process described detail Section 2.6.\nSee get(), assign(), exists(), rm(). designed interactively use current environment, working environments little clunky. Also beware inherits argument: defaults TRUE meaning base equivalents inspect supplied environment ancestors.","code":"\ne3 <- env(x = 1, y = 2)\ne3$x\n#> [1] 1\ne3$z <- 3\ne3[[\"z\"]]\n#> [1] 3\ne3[[1]]\n#> Error in e3[[1]]: wrong arguments for subsetting an environment\n\ne3[c(\"x\", \"y\")]\n#> Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\ne3$xyz\n#> NULL\n\nenv_get(e3, \"xyz\")\n#> Error in env_get(e3, \"xyz\"): argument \"default\" is missing, with no default\nenv_get(e3, \"xyz\", default = NA)\n#> [1] NA\nenv_poke(e3, \"a\", 100)\ne3$a\n#> [1] 100\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n#> [1] \"x\" \"y\" \"z\" \"a\" \"b\"\nenv_has(e3, \"a\")\n#>    a \n#> TRUE\ne3$a <- NULL\nenv_has(e3, \"a\")\n#>    a \n#> TRUE\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n#>     a \n#> FALSE"},{"path":"environments.html","id":"advanced-bindings","chapter":"4 환경","heading":"4.2.6 Advanced bindings","text":"\n\n\n\ntwo exotic variants env_bind():env_bind_lazy() creates delayed bindings, evaluated \nfirst time accessed. Behind scenes, delayed bindings create\npromises, behave way function arguments.\n\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       1\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>   0.001   0.000   0.000\nprimary use delayed bindings autoload(), \nallows R packages provide datasets behave like loaded \nmemory, even though ’re loaded disk needed.env_bind_lazy() creates delayed bindings, evaluated \nfirst time accessed. Behind scenes, delayed bindings create\npromises, behave way function arguments.primary use delayed bindings autoload(), \nallows R packages provide datasets behave like loaded \nmemory, even though ’re loaded disk needed.env_bind_active() creates active bindings re-computed every\ntime ’re accessed:\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#> [1] 0.0808\nz1\n#> [1] 0.834\nActive bindings used implement R6’s active fields, ’ll learn\nSection ??.env_bind_active() creates active bindings re-computed every\ntime ’re accessed:Active bindings used implement R6’s active fields, ’ll learn\nSection ??.See ?delayedAssign() ?makeActiveBinding().","code":"\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       1\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>   0.001   0.000   0.000\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#> [1] 0.0808\nz1\n#> [1] 0.834"},{"path":"environments.html","id":"exercises-10","chapter":"4 환경","heading":"4.2.7 Exercises","text":"List three ways environment differs list.List three ways environment differs list.Create environment illustrated picture.\nCreate environment illustrated picture.Create pair environments illustrated picture.\nCreate pair environments illustrated picture.Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e \nenvironment.Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e \nenvironment.Create version env_poke() bind new names, never\nre-bind old names. programming languages , known\nsingle assignment languages.Create version env_poke() bind new names, never\nre-bind old names. programming languages , known\nsingle assignment languages.function ? differ <<- \nmight prefer ?\n\nrebind <- function(name, value, env = caller_env()) {\n  (identical(env, empty_env())) {\n    stop(\"find `\", name, \"`\", call. = FALSE)\n  } else (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"\", 10)\n#> Error: find ``\n<- 5\nrebind(\"\", 10)\n\n#> [1] 10What function ? differ <<- \nmight prefer ?","code":"\nrebind <- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"a\", 10)\n#> Error: Can't find `a`\na <- 5\nrebind(\"a\", 10)\na\n#> [1] 10"},{"path":"environments.html","id":"env-recursion","chapter":"4 환경","heading":"4.3 Recursing over environments","text":"want operate every ancestor environment, ’s often convenient write recursive function. section shows , applying new knowledge environments write function given name, finds environment () name defined, using R’s regular scoping rules.definition () straightforward. two arguments: name look (string), environment start search. (’ll learn caller_env() good default Section 4.5.)three cases:base case: ’ve reached empty environment haven’t found \nbinding. can’t go , throw error.base case: ’ve reached empty environment haven’t found \nbinding. can’t go , throw error.successful case: name exists environment, return \nenvironment.successful case: name exists environment, return \nenvironment.recursive case: name found environment, try \nparent.recursive case: name found environment, try \nparent.three cases illustrated three examples:might help see picture. Imagine two environments, following code diagram:(\"\", e4b) find e4b.(\"\", e4b) find e4b.(\"b\", e4b) doesn’t find b e4b, looks parent, e4a,\nfinds .(\"b\", e4b) doesn’t find b e4b, looks parent, e4a,\nfinds .(\"c\", e4b) looks e4b, e4a, hits empty environment\nthrows error.(\"c\", e4b) looks e4b, e4a, hits empty environment\nthrows error.’s natural work environments recursively, () provides useful template. Removing specifics () shows structure clearly:","code":"\nwhere <- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\nwhere(\"yyy\")\n#> Error: Can't find yyy\n\nx <- 5\nwhere(\"x\")\n#> <environment: R_GlobalEnv>\n\nwhere(\"mean\")\n#> <environment: base>\ne4a <- env(empty_env(), a = 1, b = 2)\ne4b <- env(e4a, x = 10, a = 11)\nf <- function(..., env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # base case\n  } else if (success) {\n    # success case\n  } else {\n    # recursive case\n    f(..., env = env_parent(env))\n  }\n}"},{"path":"environments.html","id":"iteration-versus-recursion","chapter":"4 환경","heading":"Iteration versus recursion","text":"’s possible use loop instead recursion. think ’s harder understand recursive version, include might find easier see ’s happening haven’t written many recursive functions.","code":"\nf2 <- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env <- env_parent(env)\n  }\n\n  # base case\n}"},{"path":"environments.html","id":"exercises-11","chapter":"4 환경","heading":"4.3.1 Exercises","text":"Modify () return environments contain binding \nname. Carefully think type object function \nneed return.Modify () return environments contain binding \nname. Carefully think type object function \nneed return.Write function called fget() finds function objects. \ntwo arguments, name env, obey regular\nscoping rules functions: ’s object matching name\n’s function, look parent. added challenge, also\nadd inherits argument controls whether function recurses \nparents looks one environment.Write function called fget() finds function objects. \ntwo arguments, name env, obey regular\nscoping rules functions: ’s object matching name\n’s function, look parent. added challenge, also\nadd inherits argument controls whether function recurses \nparents looks one environment.","code":""},{"path":"environments.html","id":"special-environments","chapter":"4 환경","heading":"4.4 Special environments","text":"environments created (e.g. env()) instead created R. section, ’ll learn important environments, starting package environments. ’ll learn function environment bound function created, (usually) ephemeral execution environment created every time function called. Finally, ’ll see package function environments interact support namespaces, ensure package always behaves way, regardless packages user loaded.","code":""},{"path":"environments.html","id":"search-path","chapter":"4 환경","heading":"4.4.1 Package environments and the search path","text":"\n\npackage attached library() require() becomes one parents global environment. immediate parent global environment last package attached27, parent package second last package attached, …follow parents back, see order every package attached. known search path objects environments can found top-level interactive workspace. can see names environments base::search(), environments rlang::search_envs():last two environments search path always :Autoloads environment uses delayed bindings save memory \nloading package objects (like big datasets) needed.Autoloads environment uses delayed bindings save memory \nloading package objects (like big datasets) needed.base environment, package:base sometimes just base, \nenvironment base package. special able\nbootstrap loading packages. can access directly\nbase_env().base environment, package:base sometimes just base, \nenvironment base package. special able\nbootstrap loading packages. can access directly\nbase_env().Note attach another package library(), parent environment global environment changes:","code":"\nsearch()\n#>  [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n#>  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n#>  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n#> [10] \"package:base\"\n\nsearch_envs()\n#>  [[1]] $ <env: global>\n#>  [[2]] $ <env: package:rlang>\n#>  [[3]] $ <env: package:stats>\n#>  [[4]] $ <env: package:graphics>\n#>  [[5]] $ <env: package:grDevices>\n#>  [[6]] $ <env: package:utils>\n#>  [[7]] $ <env: package:datasets>\n#>  [[8]] $ <env: package:methods>\n#>  [[9]] $ <env: Autoloads>\n#> [[10]] $ <env: package:base>"},{"path":"environments.html","id":"function-environments","chapter":"4 환경","heading":"4.4.2 The function environment","text":"\nfunction binds current environment created. called function environment, used lexical scoping. Across computer languages, functions capture (enclose) environments called closures, term often used interchangeably function R’s documentation.can get function environment fn_env():Use environment(f) access environment function f.diagrams, ’ll draw function rectangle rounded end binds environment.case, f() binds environment binds name f function. ’s always case: following example g bound new environment e, g() binds global environment. distinction binding bound subtle important; difference find g versus g finds variables.","code":"\ny <- 1\nf <- function(x) x + y\nfn_env(f)\n#> <environment: R_GlobalEnv>\ne <- env()\ne$g <- function() 1"},{"path":"environments.html","id":"namespaces","chapter":"4 환경","heading":"4.4.3 Namespaces","text":"diagram , saw parent environment package varies based packages loaded. seems worrying: doesn’t mean package find different functions packages loaded different order? goal namespaces make sure happen, every package works way regardless packages attached user.example, take sd():sd() defined terms var(), might worry result sd() affected function called var() either global environment, one attached packages. R avoids problem taking advantage function versus binding environment described . Every function package associated pair environments: package environment, learned earlier, namespace environment.package environment external interface package. ’s \n, R user, find function attached package ::. \nparent determined search path, .e. order packages \nattached.package environment external interface package. ’s \n, R user, find function attached package ::. \nparent determined search path, .e. order packages \nattached.namespace environment internal interface package. \npackage environment controls find function; namespace\ncontrols function finds variables.namespace environment internal interface package. \npackage environment controls find function; namespace\ncontrols function finds variables.Every binding package environment also found namespace environment; ensures every function can use every function package. bindings occur namespace environment. known internal non-exported objects, make possible hide internal implementation details user.Every namespace environment set ancestors:namespace imports environment contains bindings \nfunctions used package. imports environment controlled \npackage developer NAMESPACE file.namespace imports environment contains bindings \nfunctions used package. imports environment controlled \npackage developer NAMESPACE file.Explicitly importing every base function tiresome, parent\nimports environment base namespace. base namespace\ncontains bindings base environment, different\nparent.Explicitly importing every base function tiresome, parent\nimports environment base namespace. base namespace\ncontains bindings base environment, different\nparent.parent base namespace global environment. means \nbinding isn’t defined imports environment package look\nusual way. usually bad idea (makes code\ndepend loaded packages), R CMD check automatically warns \ncode. needed primarily historical reasons, particularly due\nS3 method dispatch works.parent base namespace global environment. means \nbinding isn’t defined imports environment package look\nusual way. usually bad idea (makes code\ndepend loaded packages), R CMD check automatically warns \ncode. needed primarily historical reasons, particularly due\nS3 method dispatch works.Putting diagrams together get:sd() looks value var always finds sequence environments determined package developer, package user. ensures package code always works way regardless packages attached user.’s direct link package namespace environments; link defined function environments.","code":"\nsd\n#> function (x, na.rm = FALSE) \n#> sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#>     na.rm = na.rm))\n#> <bytecode: 0x5557d9a9a2e8>\n#> <environment: namespace:stats>"},{"path":"environments.html","id":"execution-environments","chapter":"4 환경","heading":"4.4.4 Execution environments","text":"\nlast important topic need cover execution environment. following function return first time ’s run? second?Think moment read .function returns value every time fresh start principle, described Section 3.4.3. time function called, new environment created host execution. called execution environment, parent function environment. Let’s illustrate process simpler function. Figure 4.1 illustrates graphical conventions: draw execution environments indirect parent; parent environment found via function environment.\nFigure 4.1: execution environment simple function call. Note parent execution environment function environment.\nexecution environment usually ephemeral; function completed, environment garbage collected. several ways make stay around longer. first explicitly return :Another way capture return object binding environment, like function. following example illustrates idea function factory, plus(). use factory create function called plus_one().’s lot going diagram enclosing environment plus_one() execution environment plus().happens call plus_one()? execution environment captured execution environment plus() parent:’ll learn function factories Section 6.2.","code":"\ng <- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\ng(10)\n#> Defining a\n#> [1] 1\ng(10)\n#> Defining a\n#> [1] 1\nh <- function(x) {\n  # 1.\n  a <- 2 # 2.\n  x + a\n}\ny <- h(1) # 3.\nh2 <- function(x) {\n  a <- x * 2\n  current_env()\n}\n\ne <- h2(x = 10)\nenv_print(e)\n#> <environment: 0x5557ddeaa338>\n#> parent: <environment: global>\n#> bindings:\n#>  * a: <dbl>\n#>  * x: <dbl>\nfn_env(h2)\n#> <environment: R_GlobalEnv>\nplus <- function(x) {\n  function(y) x + y\n}\n\nplus_one <- plus(1)\nplus_one\n#> function(y) x + y\n#> <environment: 0x5557dcaf7218>\nplus_one(2)\n#> [1] 3"},{"path":"environments.html","id":"exercises-12","chapter":"4 환경","heading":"4.4.5 Exercises","text":"search_envs() different env_parents(global_env())?search_envs() different env_parents(global_env())?Draw diagram shows enclosing environments function:\n\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)Draw diagram shows enclosing environments function:Write enhanced version str() provides information\nfunctions. Show function found environment\ndefined .Write enhanced version str() provides information\nfunctions. Show function found environment\ndefined .","code":"\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)"},{"path":"environments.html","id":"call-stack","chapter":"4 환경","heading":"4.5 Call stacks","text":"\n\none last environment need explain, caller environment, accessed rlang::caller_env(). provides environment function called, hence varies based function called, function created. saw useful default whenever write function takes environment argument.parent.frame() equivalent caller_env(); just note returns environment, frame.fully understand caller environment need discuss two related concepts: call stack, made frames. Executing function creates two types context. ’ve learned one already: execution environment child function environment, determined function created. ’s another type context created function called: called call stack.","code":""},{"path":"environments.html","id":"simple-stack","chapter":"4 환경","heading":"4.5.1 Simple call stacks","text":"Let’s illustrate simple sequence calls: f() calls g() calls h().way commonly see call stack R looking traceback() error occurred:Instead stop() + traceback() understand call stack, ’re going use lobstr::cst() print call stack tree:shows us cst() called h(), called g(), called f(). Note order opposite traceback(). call stacks get complicated, think ’s easier understand sequence calls start beginning, rather end (.e. f() calls g(); rather g() called f()).","code":"\nf <- function(x) {\n  g(x = 2)\n}\ng <- function(x) {\n  h(x = 3)\n}\nh <- function(x) {\n  stop()\n}\nf(x = 1)\n#> Error:\ntraceback()\n#> 4: stop()\n#> 3: h(x = 3) \n#> 2: g(x = 2)\n#> 1: f(x = 1)\nh <- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n#> █\n#> └─f(x = 1)\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()"},{"path":"environments.html","id":"lazy-call-stack","chapter":"4 환경","heading":"4.5.2 Lazy evaluation","text":"call stack simple: get hint ’s tree-like structure involved, everything happens single branch. typical call stack arguments eagerly evaluated.Let’s create complicated example involves lazy evaluation. ’ll create sequence functions, (), b(), c(), pass along argument x.x lazily evaluated tree gets two branches. first branch () calls b(), b() calls c(). second branch starts c() evaluates argument x. argument evaluated new branch environment evaluated global environment, environment c().","code":"\na <- function(x) b(x)\nb <- function(x) c(x)\nc <- function(x) x\n\na(f())\n#> █\n#> ├─a(f())\n#> │ └─b(x)\n#> │   └─c(x)\n#> └─f()\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()"},{"path":"environments.html","id":"frames","chapter":"4 환경","heading":"4.5.3 Frames","text":"\nelement call stack frame28, also known evaluation context. frame extremely important internal data structure, R code can access small part data structure tampering break R. frame three key components:expression (labelled expr) giving function call. \ntraceback() prints .expression (labelled expr) giving function call. \ntraceback() prints .environment (labelled env), typically execution\nenvironment function. two main exceptions: environment \nglobal frame global environment, calling eval() also\ngenerates frames, environment can anything.environment (labelled env), typically execution\nenvironment function. two main exceptions: environment \nglobal frame global environment, calling eval() also\ngenerates frames, environment can anything.parent, previous call call stack (shown grey arrow).parent, previous call call stack (shown grey arrow).Figure 4.2 illustrates stack call f(x = 1) shown Section 4.5.1.\nFigure 4.2: graphical depiction simple call stack\n(focus calling environments, omitted bindings global environment f, g, h respective function objects.)frame also holds exit handlers created .exit(), restarts handlers condition system, context return() function completes. important internal details accessible R code.","code":""},{"path":"environments.html","id":"dynamic-scope","chapter":"4 환경","heading":"4.5.4 Dynamic scope","text":"Looking variables calling stack rather enclosing environment called dynamic scoping. languages implement dynamic scoping (Emacs Lisp notable exception.) dynamic scoping makes much harder reason function operates: need know defined, also need know context called. Dynamic scoping primarily useful developing functions aid interactive data analysis, one topics discussed Chapter ??.","code":""},{"path":"environments.html","id":"exercises-13","chapter":"4 환경","heading":"4.5.5 Exercises","text":"Write function lists variables defined environment\ncalled. return results ls().","code":""},{"path":"environments.html","id":"explicit-envs","chapter":"4 환경","heading":"4.6 As data structures","text":"\nwell powering scoping, environments also useful data structures right reference semantics. three common problems can help solve:Avoiding copies large data. Since environments reference\nsemantics, ’ll never accidentally create copy. bare environments\npainful work , instead recommend using R6 objects, \nbuilt top environments. Learn Chapter ??.Avoiding copies large data. Since environments reference\nsemantics, ’ll never accidentally create copy. bare environments\npainful work , instead recommend using R6 objects, \nbuilt top environments. Learn Chapter ??.Managing state within package. Explicit environments useful \npackages allow maintain state across function calls.\nNormally, objects package locked, can’t modify \ndirectly. Instead, can something like :\n\nmy_env <- new.env(parent = emptyenv())\nmy_env$<- 1\n\nget_a <- function() {\n  my_env$\n}\nset_a <- function(value) {\n  old <- my_env$\n  my_env$<- value\n  invisible(old)\n}\nReturning old value setter functions good pattern \nmakes easier reset previous value conjunction \n.exit() (Section 3.7.4).Managing state within package. Explicit environments useful \npackages allow maintain state across function calls.\nNormally, objects package locked, can’t modify \ndirectly. Instead, can something like :Returning old value setter functions good pattern \nmakes easier reset previous value conjunction \n.exit() (Section 3.7.4).hashmap. hashmap data structure takes constant, O(1),\ntime find object based name. Environments provide \nbehaviour default, can used simulate hashmap. See \nhash package29 complete development idea.hashmap. hashmap data structure takes constant, O(1),\ntime find object based name. Environments provide \nbehaviour default, can used simulate hashmap. See \nhash package29 complete development idea.","code":"\nmy_env <- new.env(parent = emptyenv())\nmy_env$a <- 1\n\nget_a <- function() {\n  my_env$a\n}\nset_a <- function(value) {\n  old <- my_env$a\n  my_env$a <- value\n  invisible(old)\n}"},{"path":"environments.html","id":"env-answers","chapter":"4 환경","heading":"4.7 Quiz answers","text":"four ways: every object environment must name;\norder doesn’t matter; environments parents; environments \nreference semantics.four ways: every object environment must name;\norder doesn’t matter; environments parents; environments \nreference semantics.parent global environment last package \nloaded. environment doesn’t parent empty\nenvironment.parent global environment last package \nloaded. environment doesn’t parent empty\nenvironment.enclosing environment function environment \ncreated. determines function looks variables.enclosing environment function environment \ncreated. determines function looks variables.Use caller_env() parent.frame().Use caller_env() parent.frame().<- always creates binding current environment; <<-\nrebinds existing name parent current environment.<- always creates binding current environment; <<-\nrebinds existing name parent current environment.","code":""},{"path":"fp.html","id":"fp","chapter":"Introduction","heading":"Introduction","text":"R, heart, functional language. means certain technical properties, importantly lends style problem solving centred functions. ’ll give brief overview technical definition functional language, book primarily focus functional style programming, think extremely good fit types problem commonly encounter data analysis.Recently, functional techniques experienced surge interest can produce efficient elegant solutions many modern problems. functional style tends create functions can easily analysed isolation (.e. using local information), hence often much easier automatically optimise parallelise. traditional weaknesses functional languages, poorer performance sometimes unpredictable memory usage, much reduced recent years. Functional programming complementary object-oriented programming, dominant programming paradigm last several decades.","code":""},{"path":"fp.html","id":"functional-programming-languages","chapter":"Introduction","heading":"Functional programming languages","text":"Every programming language functions, makes programming language functional? many definitions precisely makes language functional, two common threads.Firstly, functional languages first-class functions, functions behave like data structure. R, means can many things function can vector: can assign variables, store lists, pass arguments functions, create inside functions, even return result function.Secondly, many functional languages require functions pure. function pure satisfies two properties:output depends inputs, .e. call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.output depends inputs, .e. call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.Pure functions much easier reason , obviously significant downsides: imagine data analysis couldn’t generate random numbers read files disk.Strictly speaking, R isn’t functional programming language doesn’t require write pure functions. However, can certainly adopt functional style parts code: don’t write pure functions, often . experience, partitioning code functions either extremely pure extremely impure tends lead code easier understand extends new situations.","code":""},{"path":"fp.html","id":"functional-style","chapter":"Introduction","heading":"Functional style","text":"’s hard describe exactly functional style , generally think means decomposing big problem smaller pieces, solving piece function combination functions. using functional style, strive decompose components problem isolated functions operate independently. function taken simple straightforward understand; complexity handled composing functions various ways.following three chapters discuss three key functional techniques help decompose problems smaller pieces:Chapter 5 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n’ll use time data analysis.Chapter 5 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n’ll use time data analysis.Chapter ?? introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter ?? introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter 7 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Chapter 7 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Collectively, types function called higher-order functions fill two--two table:","code":""},{"path":"functionals.html","id":"functionals","chapter":"5 Functionals","heading":"5 Functionals","text":"","code":""},{"path":"functionals.html","id":"introduction-4","chapter":"5 Functionals","heading":"5.1 Introduction","text":"become significantly reliable, code must become transparent.\nparticular, nested conditions loops must viewed great\nsuspicion. Complicated control flows confuse programmers. Messy code often\nhides bugs.— Bjarne StroustrupA functional function takes function input returns vector output. ’s simple functional: calls function provided input 1000 random uniform numbers.chances ’ve already used functional. might used -loop replacements like base R’s lapply(), apply(), tapply(); purrr’s map(); maybe ’ve used mathematical functional like integrate() optim().\ncommon use functionals alternative loops. loops bad rap R many people believe slow30, real downside loops ’re flexible: loop conveys ’re iterating, done results. Just ’s better use repeat, ’s better use (Section ??), ’s better use functional . functional tailored specific task, recognise functional immediately know ’s used.’re experienced loop user, switching functionals typically pattern matching exercise. look loop find functional matches basic form. one doesn’t exist, don’t try torture existing functional fit form need. Instead, just leave loop! (’ve repeated loop two times, maybe think writing functional).","code":"\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n#> [1] 0.506\nrandomise(mean)\n#> [1] 0.501\nrandomise(sum)\n#> [1] 489"},{"path":"functionals.html","id":"outline-3","chapter":"5 Functionals","heading":"Outline","text":"Section 5.2 introduces first functional: purrr::map().Section 5.2 introduces first functional: purrr::map().Section 5.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 5.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 5.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 5.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 5.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 5.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 5.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 5.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 5.7 reviews functionals base R \nmembers map, reduce, predicate families.Section 5.7 reviews functionals base R \nmembers map, reduce, predicate families.","code":""},{"path":"functionals.html","id":"prerequisites-2","chapter":"5 Functionals","heading":"Prerequisites","text":"chapter focus functionals provided purrr package.31 functions consistent interface makes easier understand key ideas base equivalents, grown organically many years. ’ll compare contrast base R functions go, wrap chapter discussion base functionals don’t purrr equivalents.","code":"\nlibrary(purrr)"},{"path":"functionals.html","id":"map","chapter":"5 Functionals","heading":"5.2 My first functional: map()","text":"fundamental functional purrr::map()32. takes vector function, calls function element vector, returns results list. words, map(1:3, f) equivalent list(f(1), f(2), f(3))., graphically:might wonder function called map(). depicting physical features land sea 🗺? fact, meaning comes mathematics map refers “operation associates element given set one elements second set.” makes sense map() defines mapping one vector another. (“Map” also nice property short, useful fundamental building block.)implementation map() quite simple. allocate list length input, fill list loop. heart implementation handful lines code:real purrr::map() function differences: written C eke every last iota performance, preserves names, supports shortcuts ’ll learn Section 5.2.2.base equivalent map() lapply(). difference lapply() support helpers ’ll learn , ’re using map() purrr, can skip additional dependency use lapply() directly.","code":"\ntriple <- function(x) x * 3\nmap(1:3, triple)\n#> [[1]]\n#> [1] 3\n#> \n#> [[2]]\n#> [1] 6\n#> \n#> [[3]]\n#> [1] 9\nsimple_map <- function(x, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"map-atomic","chapter":"5 Functionals","heading":"5.2.1 Producing atomic vectors","text":"map() returns list, makes general map family can put anything list. inconvenient return list simpler data structure , four specific variants: map_lgl(), map_int(), map_dbl(), map_chr(). returns atomic vector specified type:purrr uses convention suffixes, like _dbl(), refer output. map_*() functions can take type vector input. examples rely two facts: mtcars data frame, data frames lists containing vectors length. obvious draw data frame orientation vector:map functions always return output vector length input, implies call .f must return single value. , ’ll get error:similar error ’ll get .f returns wrong type result:either case, ’s often useful switch back map(), map() can accept type output. allows see problematic output, figure .Base R two apply functions can return atomic vectors: sapply() vapply(). recommend avoid sapply() tries simplify result, can return list, vector, matrix. makes difficult program , avoided non-interactive settings. vapply() safer allows provide template, FUN.VALUE, describes output shape. don’t want use purrr, recommend always use vapply() functions, sapply(). primary downside vapply() verbosity: example, equivalent map_dbl(x, mean, na.rm = TRUE) vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1)).","code":"\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n#>      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#> \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#>       am     gear     carb \n#> \"double\" \"double\" \"double\"\n\n# map_lgl() always returns a logical vector\nmap_lgl(mtcars, is.double)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#> TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() always returns a integer vector\nn_unique <- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n#>     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#>  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 \n#>    carb \n#>   2.812\npair <- function(x) c(x, x)\nmap_dbl(1:2, pair)\n#> Error: Result 1 must be a single double, not an integer vector of length 2\nmap_dbl(1:2, as.character)\n#> Error: Can't coerce element 1 from a character to a double\nmap(1:2, pair)\n#> [[1]]\n#> [1] 1 1\n#> \n#> [[2]]\n#> [1] 2 2\nmap(1:2, as.character)\n#> [[1]]\n#> [1] \"1\"\n#> \n#> [[2]]\n#> [1] \"2\""},{"path":"functionals.html","id":"purrr-shortcuts","chapter":"5 Functionals","heading":"5.2.2 Anonymous functions and shortcuts","text":"\nInstead using map() existing function, can create inline anonymous function (mentioned Section 3.2.3):Anonymous functions useful, syntax verbose. purrr supports special shortcut:works purrr functions translate formulas, created ~ (pronounced “twiddle”), functions. can see ’s happening behind scenes calling as_mapper():function arguments look little quirky allow refer . one argument functions, .x .y two argument functions, ..1, ..2, ..3, etc, functions arbitrary number arguments. . remains backward compatibility don’t recommend using ’s easily confused . used magrittr’s pipe.shortcut particularly useful generating random data:Reserve syntax short simple functions. good rule thumb function spans lines uses {}, ’s time give name.map functions also shortcuts extracting elements vector, powered purrr::pluck(). can use character vector select elements name, integer vector select position, list select name position. useful working deeply nested lists, often arise working JSON.base R functions, like lapply(), can provide name function string. isn’t tremendously useful lapply(x, \"f\") almost always equivalent lapply(x, f) typing.","code":"\nmap_dbl(mtcars, function(x) length(unique(x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nmap_dbl(mtcars, ~ length(unique(.x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nas_mapper(~ length(unique(.x)))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(unique(.x))\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\nx <- map(1:3, ~ runif(2))\nstr(x)\n#> List of 3\n#>  $ : num [1:2] 0.281 0.53\n#>  $ : num [1:2] 0.433 0.917\n#>  $ : num [1:2] 0.0275 0.8249\nx <- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n#> [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n#> [1] -1 -2 -3\n\n# Or by both\nmap_dbl(x, list(\"y\", 1))\n#> [1] 2 5 9\n\n# You'll get an error if a component doesn't exist:\nmap_chr(x, \"z\")\n#> Error: Result 3 must be a single string, not NULL of length 0\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n#> [1] \"a\" \"b\" NA"},{"path":"functionals.html","id":"passing-arguments","chapter":"5 Functionals","heading":"5.2.3 Passing arguments with ...","text":"’s often convenient pass along additional arguments function ’re calling. example, might want pass na.rm = TRUE along mean(). One way anonymous function:map functions pass ... along, ’s simpler form available:easiest understand picture: arguments come f call map() inserted data individual calls f():’s important note arguments decomposed; said another way, map() vectorised first argument. argument f vector, passed along :(’ll learn map variants vectorised multiple arguments Sections 5.4.2 5.4.5.)Note ’s subtle difference placing extra arguments inside anonymous function compared passing map(). Putting anonymous function means evaluated every time f() executed, just call map(). easiest see make additional argument random:","code":"\nx <- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n#> [1] 3.0 5.5\nmap_dbl(x, mean, na.rm = TRUE)\n#> [1] 3.0 5.5\nplus <- function(x, y) x + y\n\nx <- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n#> [1] 0.0625 0.0625 0.0625 0.0625\nmap_dbl(x, ~ plus(.x, runif(1)))\n#> [1] 0.903 0.132 0.629 0.945"},{"path":"functionals.html","id":"argument-names","chapter":"5 Functionals","heading":"5.2.4 Argument names","text":"diagrams, ’ve omitted argument names focus overall structure. recommend writing full names code, makes easier read. map(x, mean, 0.1) perfectly valid code, call mean(x[[1]], 0.1) relies reader remembering second argument mean() trim. avoid unnecessary burden brain reader33, kind write map(x, mean, trim = 0.1).reason arguments map() little odd: instead x f, .x .f. ’s easiest see problem leads names using simple_map() defined . simple_map() arguments x f ’ll problems whenever function calling arguments x f:error little bewildering remember call simple_map() equivalent simple_map(x = mtcars, f = mean, bootstrap_summary) named matching beats positional matching.purrr functions reduce likelihood clash using .f .x instead common f x. course technique isn’t perfect (function calling might still use .f .x), avoids 99% issues. remaining 1% time, use anonymous function.Base functions pass along ... use variety naming conventions prevent undesired argument matching:apply family mostly uses capital letters (e.g. X FUN).apply family mostly uses capital letters (e.g. X FUN).transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection 2.2.1. makes undesired matches extremely\nunlikely.transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection 2.2.1. makes undesired matches extremely\nunlikely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.","code":"\nboostrap_summary <- function(x, f) {\n  f(sample(x, replace = TRUE))\n}\n\nsimple_map(mtcars, boostrap_summary, f = mean)\n#> Error in mean.default(x[[i]], ...): 'trim' must be numeric of length one"},{"path":"functionals.html","id":"change-argument","chapter":"5 Functionals","heading":"5.2.5 Varying another argument","text":"far first argument map() always become first argument function. happens first argument constant, want vary different argument? get result picture?turns ’s way directly, two tricks can use instead. illustrate , imagine vector contains unusual values, want explore effect different amounts trimming computing mean. case, first argument mean() constant, want vary second argument, trim.simplest technique use anonymous function rearrange \nargument order:\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nstill little confusing ’m using x .x.\ncan make little clearer abandoning ~ helper:\n\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502The simplest technique use anonymous function rearrange \nargument order:still little confusing ’m using x .x.\ncan make little clearer abandoning ~ helper:Sometimes, want () clever, can take advantage R’s\nflexible argument matching rules (described Section\n3.8.2). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :\n\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502\ndon’t recommend technique relies reader’s familiarity argument order .f, R’s\nargument matching rules.Sometimes, want () clever, can take advantage R’s\nflexible argument matching rules (described Section\n3.8.2). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :don’t recommend technique relies reader’s familiarity argument order .f, R’s\nargument matching rules.’ll see one alternative Section 5.4.5.","code":"\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502"},{"path":"functionals.html","id":"exercises-14","chapter":"5 Functionals","heading":"5.2.6 Exercises","text":"Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?Use appropriate map() function :\nCompute standard deviation every column numeric data frame.\nCompute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)\nCompute number levels every factor data frame.\nUse appropriate map() function :Compute standard deviation every column numeric data frame.Compute standard deviation every column numeric data frame.Compute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)Compute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)Compute number levels every factor data frame.Compute number levels every factor data frame.following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.\n\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?\n\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error .f(.x[[]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?Use map() fit linear models mtcars dataset using formulas\nstored list:\n\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ (1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ (1 / disp) + wt\n)Use map() fit linear models mtcars dataset using formulas\nstored list:Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)\n\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)","code":"\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error in .f(.x[[i]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))"},{"path":"functionals.html","id":"purrr-style","chapter":"5 Functionals","heading":"5.3 Purrr style","text":"go explore map variants, let’s take quick look tend use multiple purrr functions solve moderately realistic problem: fitting model subgroup extracting coefficient model. toy example, ’m going break mtcars data set groups defined number cylinders, using base split function:creates list three data frames: cars 4, 6, 8 cylinders respectively.Now imagine want fit linear model, extract second coefficient (.e. slope). following code shows might purrr:(haven’t seen %>%, pipe, , ’s described Section 3.3.)think code easy read line encapsulates single step, can easily distinguish functional , purrr helpers allow us concisely describe step.attack problem base R? certainly replace purrr function equivalent base function:isn’t really base R since ’re using pipe. tackle purely base think ’d use intermediate variable, step:, course, use loop:’s interesting note move purrr base apply functions loops tend iteration. purrr iterate 3 times (map(), map(), map_dbl()), apply functions iterate twice (lapply(), vapply()), loop iterate . prefer , simpler, steps think makes code easier understand later modify.","code":"\nby_cyl <- split(mtcars, mtcars$cyl)\nby_cyl %>% \n  map(~ lm(mpg ~ wt, data = .x)) %>% \n  map(coef) %>% \n  map_dbl(2)\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nby_cyl %>% \n  lapply(function(data) lm(mpg ~ wt, data = data)) %>% \n  lapply(coef) %>% \n  vapply(function(x) x[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nmodels <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))\nvapply(models, function(x) coef(x)[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nslopes <- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model <- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] <- coef(model)[[2]]\n}\nslopes\n#> [1] -5.65 -2.78 -2.19"},{"path":"functionals.html","id":"map-variants","chapter":"5 Functionals","heading":"5.4 Map variants","text":"23 primary variants map(). far, ’ve learned five (map(), map_lgl(), map_int(), map_dbl() map_chr()). means ’ve got 18 (!!) learn. sounds like lot, fortunately design purrr means need learn five new ideas:Output type input modify()Iterate two inputs map2().Iterate index using imap()Return nothing walk().Iterate number inputs pmap().map family functions orthogonal input outputs, meaning can organise family matrix, inputs rows outputs columns. ’ve mastered idea row, can combine column; ’ve mastered idea column, can combine row. relationship summarised following table:","code":""},{"path":"functionals.html","id":"modify","chapter":"5 Functionals","heading":"5.4.1 Same type of output as input: modify()","text":"Imagine wanted double every column data frame. might first try using map(), map() always returns list:want keep output data frame, can use modify(), always returns type output input:Despite name, modify() doesn’t modify place, returns modified copy, wanted permanently modify df, ’d need assign :usual, basic implementation modify() simple, fact ’s even simpler map() don’t need create new output vector; can just progressively replace input. (real code little complex handle edge cases gracefully.)Section 5.6.2 ’ll learn useful variant modify(), called modify_if(). allows (e.g.) double numeric columns data frame modify_if(df, .numeric, ~ .x * 2).","code":"\ndf <- data.frame(\n  x = 1:3,\n  y = 6:4\n)\n\nmap(df, ~ .x * 2)\n#> $x\n#> [1] 2 4 6\n#> \n#> $y\n#> [1] 12 10  8\nmodify(df, ~ .x * 2)\n#>   x  y\n#> 1 2 12\n#> 2 4 10\n#> 3 6  8\ndf <- modify(df, ~ .x * 2)\nsimple_modify <- function(x, f, ...) {\n  for (i in seq_along(x)) {\n    x[[i]] <- f(x[[i]], ...)\n  }\n  x\n}"},{"path":"functionals.html","id":"map2","chapter":"5 Functionals","heading":"5.4.2 Two inputs: map2() and friends","text":"map() vectorised single argument, .x. means varies .x calling .f, arguments passed along unchanged, thus making poorly suited problems. example, find weighted mean list observations list weights? Imagine following data:can use map_dbl() compute unweighted means:passing ws additional argument doesn’t work arguments .f transformed:need new tool: map2(), vectorised two arguments. means .x .y varied call .f:arguments map2() slightly different arguments map() two vectors come function, rather one. Additional arguments still go afterwards:basic implementation map2() simple, quite similar map(). Instead iterating one vector, iterate two parallel:One big differences map2() simple function map2() recycles inputs make sure ’re length:words, map2(x, y, f) automatically behave like map(x, f, y) needed. helpful writing functions; scripts ’d generally just use simpler form directly.closest base equivalent map2() Map(), discussed Section 5.4.5.","code":"\nxs <- map(1:8, ~ runif(10))\nxs[[1]][[1]] <- NA\nws <- map(1:8, ~ rpois(10, 5) + 1)\nmap_dbl(xs, mean)\n#> [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443\nmap_dbl(xs, weighted.mean, w = ws)\n#> Error in weighted.mean.default(.x[[i]], ...): 'x' and 'w' must have the same length\nmap2_dbl(xs, ws, weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nmap2_dbl(xs, ws, weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nsimple_map2 <- function(x, y, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], y[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"no-outputs-walk-and-friends","chapter":"5 Functionals","heading":"5.4.3 No outputs: walk() and friends","text":"functions called value return, makes sense capture store value map() function. functions called primarily side-effects (e.g. cat(), write.csv(), ggsave()) doesn’t make sense capture results. Take simple example displays welcome message using cat(). cat() returns NULL, map() works (sense generates desired welcomes), also returns list(NULL, NULL).avoid problem assigning results map() variable never use, muddy intent code. Instead, purrr provides walk family functions ignore return values .f instead return .x invisibly34.visual depiction walk attempts capture important difference map(): outputs ephemeral, input returned invisibly.One useful walk() variants walk2() common side-effect saving something disk, saving something disk always pair values: object path want save .example, imagine list data frames (’ve created using split()), ’d like save one separate CSV file. ’s easy walk2():walk2() equivalent write.csv(cyls[[1]], paths[[1]]), write.csv(cyls[[2]], paths[[2]]), write.csv(cyls[[3]], paths[[3]]).base equivalent walk(); either wrap result lapply() invisible() save variable never used.","code":"\nwelcome <- function(x) {\n  cat(\"Welcome \", x, \"!\\n\", sep = \"\")\n}\nnames <- c(\"Hadley\", \"Jenny\")\n\n# As well as generate the welcomes, it also shows \n# the return value of cat()\nmap(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> NULL\nwalk(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\ntemp <- tempfile()\ndir.create(temp)\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\ndir(temp)\n#> [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\""},{"path":"functionals.html","id":"iterating-over-values-and-indices","chapter":"5 Functionals","heading":"5.4.4 Iterating over values and indices","text":"three basic ways loop vector loop:Loop elements: (x xs)Loop numeric indices: (seq_along(xs))Loop names: (nm names(xs))first form analogous map() family. second third forms equivalent imap() family allows iterate values indices vector parallel.imap() like map2() sense .f gets called two arguments, derived vector. imap(x, f) equivalent map2(x, names(x), f) x names, map2(x, seq_along(x), f) .imap() often useful constructing labels:vector unnamed, second argument index:imap() useful helper want work values vector along positions.","code":"\nimap_chr(iris, ~ paste0(\"The first value of \", .y, \" is \", .x[[1]]))\n#>                             Sepal.Length \n#> \"The first value of Sepal.Length is 5.1\" \n#>                              Sepal.Width \n#>  \"The first value of Sepal.Width is 3.5\" \n#>                             Petal.Length \n#> \"The first value of Petal.Length is 1.4\" \n#>                              Petal.Width \n#>  \"The first value of Petal.Width is 0.2\" \n#>                                  Species \n#>   \"The first value of Species is setosa\"\nx <- map(1:6, ~ sample(1000, 10))\nimap_chr(x, ~ paste0(\"The highest value of \", .y, \" is \", max(.x)))\n#> [1] \"The highest value of 1 is 975\" \"The highest value of 2 is 915\"\n#> [3] \"The highest value of 3 is 982\" \"The highest value of 4 is 955\"\n#> [5] \"The highest value of 5 is 971\" \"The highest value of 6 is 696\""},{"path":"functionals.html","id":"pmap","chapter":"5 Functionals","heading":"5.4.5 Any number of inputs: pmap() and friends","text":"Since map() map2(), might expect map3(), map4(), map5(), … stop? Instead generalising map2() arbitrary number arguments, purrr takes slightly different tack pmap(): supply single list, contains number arguments. cases, list equal-length vectors, .e. something similar data frame. diagrams, ’ll emphasise relationship drawing input similar data frame.’s simple equivalence map2() pmap(): map2(x, y, f) pmap(list(x, y), f). pmap() equivalent map2_dbl(xs, ws, weighted.mean) used :, varying arguments come .f (although now must wrapped list), constant arguments come afterwards.big difference pmap() map functions pmap() gives much finer control argument matching can name components list. Returning example Section 5.2.5, wanted vary trim argument x, instead use pmap():think ’s good practice name components list make clear function called.’s often convenient call pmap() data frame. handy way create data frame tibble::tribble(), allows describe data frame row--row (rather column--column, usual): thinking parameters function data frame powerful pattern. following example shows might draw random uniform numbers varying parameters:\n, column names critical: ’ve carefully chosen match arguments runif(), pmap(params, runif) equivalent runif(n = 1L, min = 0, max = 1), runif(n = 2, min = 10, max = 100), runif(n = 3L, min = 100, max = 1000). (data frame hand, names don’t match, use dplyr::rename() similar.)two base equivalents pmap() family: Map() mapply(). significant drawbacks:Map() vectorises arguments supply arguments \nvary.Map() vectorises arguments supply arguments \nvary.mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().","code":"\npmap_dbl(list(xs, ws), weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\npmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\n\npmap_dbl(list(trim = trims), mean, x = x)\n#> [1] -6.6740  0.0210  0.0235  0.0151\nparams <- tibble::tribble(\n  ~ n, ~ min, ~ max,\n   1L,     0,     1,\n   2L,    10,   100,\n   3L,   100,  1000\n)\n\npmap(params, runif)\n#> [[1]]\n#> [1] 0.332\n#> \n#> [[2]]\n#> [1] 53.5 47.6\n#> \n#> [[3]]\n#> [1] 231 715 515"},{"path":"functionals.html","id":"exercises-15","chapter":"5 Functionals","heading":"5.4.6 Exercises","text":"Explain results modify(mtcars, 1).Explain results modify(mtcars, 1).Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?Explain following code transforms data frame using functions\nstored list.\n\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nCompare contrast map2() approach map() approach:\n\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))Explain following code transforms data frame using functions\nstored list.Compare contrast map2() approach map() approach:write.csv() return, .e. happens use \nmap2() instead walk2()?write.csv() return, .e. happens use \nmap2() instead walk2()?","code":"\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))"},{"path":"functionals.html","id":"reduce","chapter":"5 Functionals","heading":"5.5 Reduce family","text":"map family, next important family functions reduce family. family much smaller, two main variants, used less commonly, ’s powerful idea, gives us opportunity discuss useful algebra, powers map-reduce framework frequently used processing large datasets.","code":""},{"path":"functionals.html","id":"basics-1","chapter":"5 Functionals","heading":"5.5.1 Basics","text":"reduce() takes vector length n produces vector length 1 calling function pair values time: reduce(1:4, f) equivalent f(f(f(1, 2), 3), 4).reduce() useful way generalise function works two inputs (binary function) work number inputs. Imagine list numeric vectors, want find values occur every element. First generate sample data:solve challenge need use intersect() repeatedly:reduce() automates solution us, can write:apply idea wanted list elements appear least one entry. switch intersect() union():Like map family, can also pass additional arguments. intersect() union() don’t take extra arguments can’t demonstrate , principle straightforward drew picture.usual, essence reduce() can reduced simple wrapper around loop:base equivalent Reduce(). Note argument order different: function comes first, followed vector, way supply additional arguments.","code":"\nl <- map(1:4, ~ sample(1:10, 15, replace = T))\nstr(l)\n#> List of 4\n#>  $ : int [1:15] 7 1 8 8 3 8 2 4 7 10 ...\n#>  $ : int [1:15] 3 1 10 2 5 2 9 8 5 4 ...\n#>  $ : int [1:15] 6 10 9 5 6 7 8 6 10 8 ...\n#>  $ : int [1:15] 9 8 6 4 4 5 2 9 9 6 ...\nout <- l[[1]]\nout <- intersect(out, l[[2]])\nout <- intersect(out, l[[3]])\nout <- intersect(out, l[[4]])\nout\n#> [1] 8 4\nreduce(l, intersect)\n#> [1] 8 4\nreduce(l, union)\n#>  [1]  7  1  8  3  2  4 10  5  9  6\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}"},{"path":"functionals.html","id":"accumulate","chapter":"5 Functionals","heading":"5.5.2 Accumulate","text":"first reduce() variant, accumulate(), useful understanding reduce works, instead returning just final result, returns intermediate results well:Another useful way understand reduce think sum(): sum(x) equivalent x[[1]] + x[[2]] + x[[3]] + ..., .e. reduce(x, `+`). accumulate(x, `+`) cumulative sum:","code":"\naccumulate(l, intersect)\n#> [[1]]\n#>  [1]  7  1  8  8  3  8  2  4  7 10 10  3  7 10 10\n#> \n#> [[2]]\n#> [1]  1  8  3  2  4 10\n#> \n#> [[3]]\n#> [1]  8  4 10\n#> \n#> [[4]]\n#> [1] 8 4\nx <- c(4, 3, 10)\nreduce(x, `+`)\n#> [1] 17\n\naccumulate(x, `+`)\n#> [1]  4  7 17"},{"path":"functionals.html","id":"output-types","chapter":"5 Functionals","heading":"5.5.3 Output types","text":"example using +, reduce() return x short, .e. length 1 0? Without additional arguments, reduce() just returns input x length 1:means reduce() way check input valid:’s length 0? get error suggests need use .init argument:.init ? figure , need see happens .init supplied:call reduce(1, `+`, init) result 1 + init. Now know result just 1, suggests .init 0:also ensures reduce() checks length 1 inputs valid function ’re calling:want get algebraic , 0 called identity real numbers operation addition: add 0 number, get number back. R applies principle determine summary function zero length input return:’re using reduce() function, always supply .init. Think carefully function return pass vector length 0 1, make sure test implementation.","code":"\nreduce(1, `+`)\n#> [1] 1\nreduce(\"a\", `+`)\n#> [1] \"a\"\nreduce(integer(), `+`)\n#> Error: `.x` is empty, and no `.init` supplied\nreduce(integer(), `+`, .init = 0)\n#> [1] 0\nreduce(\"a\", `+`, .init = 0)\n#> Error in .x + .y: non-numeric argument to binary operator\nsum(integer())  # x + 0 = x\n#> [1] 0\nprod(integer()) # x * 1 = x\n#> [1] 1\nmin(integer())  # min(x, Inf) = x\n#> [1] Inf\nmax(integer())  # max(x, -Inf) = x\n#> [1] -Inf"},{"path":"functionals.html","id":"multiple-inputs","chapter":"5 Functionals","heading":"5.5.4 Multiple inputs","text":"occasionally need pass two arguments function ’re reducing. example, might list data frames want join together, variables use join vary element element. specialised scenario, don’t want spend much time , want know reduce2() exists.length second argument varies based whether .init supplied: four elements x, f called three times. supply init, f called four times.","code":""},{"path":"functionals.html","id":"map-reduce","chapter":"5 Functionals","heading":"5.5.5 Map-reduce","text":"might heard map-reduce, idea powers technology like Hadoop. Now can see simple powerful underlying idea : map-reduce map combined reduce. difference large data data spread multiple computers. computer performs map data , sends result back coordinator reduces individual results back single result.simple example, imagine computing mean large vector, large split multiple computers. ask computer calculate sum length, return coordinator computes overall mean dividing total sum total length.","code":""},{"path":"functionals.html","id":"predicate-functionals","chapter":"5 Functionals","heading":"5.6 Predicate functionals","text":"\npredicate function returns single TRUE FALSE, like .character(), .null(), (), say predicate matches vector returns TRUE.","code":""},{"path":"functionals.html","id":"basics-2","chapter":"5 Functionals","heading":"5.6.1 Basics","text":"predicate functional applies predicate element vector. purrr provides seven useful functions come three groups:(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.\nsimilar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.similar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.following example shows might use functionals data frame:","code":"\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\ndetect(df, is.factor)\n#> NULL\ndetect_index(df, is.factor)\n#> [1] 0\n\nstr(keep(df, is.factor))\n#> 'data.frame':    3 obs. of  0 variables\nstr(discard(df, is.factor))\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ x: int  1 2 3\n#>  $ y: chr  \"a\" \"b\" \"c\""},{"path":"functionals.html","id":"predicate-map","chapter":"5 Functionals","heading":"5.6.2 Map variants","text":"map() modify() come variants also take predicate functions, transforming elements .x .p TRUE.","code":"\ndf <- data.frame(\n  num1 = c(0, 10, 20),\n  num2 = c(5, 6, 7),\n  chr1 = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\n\nstr(map_if(df, is.numeric, mean))\n#> List of 3\n#>  $ num1: num 10\n#>  $ num2: num 6\n#>  $ chr1: chr [1:3] \"a\" \"b\" \"c\"\nstr(modify_if(df, is.numeric, mean))\n#> 'data.frame':    3 obs. of  3 variables:\n#>  $ num1: num  10 10 10\n#>  $ num2: num  6 6 6\n#>  $ chr1: chr  \"a\" \"b\" \"c\"\nstr(map(keep(df, is.numeric), mean))\n#> List of 2\n#>  $ num1: num 10\n#>  $ num2: num 6"},{"path":"functionals.html","id":"exercises-16","chapter":"5 Functionals","heading":"5.6.3 Exercises","text":"isn’t .na() predicate function? base R function closest\npredicate version .na()?isn’t .na() predicate function? base R function closest\npredicate version .na()?simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .\n\nsimple_reduce <- function(x, f) {\n  <- x[[1]]\n  (seq(2, length(x))) {\n    <- f(, x[[]])\n  }\n  \n}simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?\n\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?","code":"\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}"},{"path":"functionals.html","id":"base-functionals","chapter":"5 Functionals","heading":"5.7 Base functionals","text":"finish chapter, provide survey important base functionals members map, reduce, predicate families, hence equivalent purrr. say ’re important, mathematical statistical flavour, generally less useful data analysis.","code":""},{"path":"functionals.html","id":"matrices-and-arrays","chapter":"5 Functionals","heading":"5.7.1 Matrices and arrays","text":"map() friends specialised work one-dimensional vectors. base::apply() specialised work two-dimensional higher vectors, .e. matrices arrays. can think apply() operation summarises matrix array collapsing row column single value. four arguments:X, matrix array summarise.X, matrix array summarise.MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)FUN, summary function.FUN, summary function.... arguments passed FUN.... arguments passed FUN.typical example apply() looks like thisYou can specify multiple dimensions MARGIN, useful high-dimensional arrays:two caveats using apply():Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().apply() also idempotent sense summary\nfunction identity operator, output always \ninput.\n\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUEapply() also idempotent sense summary\nfunction identity operator, output always \ninput.Never use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.\n\ndf <- data.frame(x = 1:3, y = c(\"\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n#>  x  y \n#> NA NANever use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.","code":"\na2d <- matrix(1:20, nrow = 5)\napply(a2d, 1, mean)\n#> [1]  8.5  9.5 10.5 11.5 12.5\napply(a2d, 2, mean)\n#> [1]  3  8 13 18\na3d <- array(1:24, c(2, 3, 4))\napply(a3d, 1, mean)\n#> [1] 12 13\napply(a3d, c(1, 2), mean)\n#>      [,1] [,2] [,3]\n#> [1,]   10   12   14\n#> [2,]   11   13   15\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUE\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n#>  x  y \n#> NA NA"},{"path":"functionals.html","id":"mathematical-concerns","chapter":"5 Functionals","heading":"5.7.2 Mathematical concerns","text":"Functionals common mathematics. limit, maximum, roots (set points f(x) = 0), definite integral functionals: given function, return single number (vector numbers). first glance, functions don’t seem fit theme eliminating loops, dig deeper ’ll find implemented using algorithm involves iteration.Base R provides useful set:integrate() finds area curve defined f()uniroot() finds f() hits zerooptimise() finds location lowest (highest) value f()following example shows functionals might used simple function, sin():","code":"\nintegrate(sin, 0, pi)\n#> 2 with absolute error < 2.2e-14\nstr(uniroot(sin, pi * c(1 / 2, 3 / 2)))\n#> List of 5\n#>  $ root      : num 3.14\n#>  $ f.root    : num 1.22e-16\n#>  $ iter      : int 2\n#>  $ init.it   : int NA\n#>  $ estim.prec: num 6.1e-05\nstr(optimise(sin, c(0, 2 * pi)))\n#> List of 2\n#>  $ minimum  : num 4.71\n#>  $ objective: num -1\nstr(optimise(sin, c(0, pi), maximum = TRUE))\n#> List of 2\n#>  $ maximum  : num 1.57\n#>  $ objective: num 1"},{"path":"functionals.html","id":"exercises-17","chapter":"5 Functionals","heading":"5.7.3 Exercises","text":"apply() arrange output? Read documentation perform\nexperiments.apply() arrange output? Read documentation perform\nexperiments.eapply() rapply() ? purrr equivalents?eapply() rapply() ? purrr equivalents?Challenge: read \nfixed point algorithm.\nComplete exercises using R.Challenge: read \nfixed point algorithm.\nComplete exercises using R.","code":""},{"path":"함수-공장.html","id":"함수-공장","chapter":"6 함수 공장","heading":"6 함수 공장","text":"","code":""},{"path":"함수-공장.html","id":"들어가기","chapter":"6 함수 공장","heading":"6.1 들어가기","text":"함수공장 (function factory) 는 함수를 만드는 함수이다. ’s simple example: use function factory (power1()) make two child functions (square() cube()):Don’t worry doesn’t make sense yet, end chapter!\n\n’ll call square() cube() manufactured functions, just term ease communication humans: R’s perspective different functions created way.already learned individual components make function factories possible:Section 3.2.3, learned R’s first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section 3.2.3, learned R’s first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section 4.4.2, learned function\ncaptures (encloses) environment created.Section 4.4.2, learned function\ncaptures (encloses) environment created.Section 4.4.4, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.Section 4.4.4, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.chapter, ’ll learn non-obvious combination three features leads function factory. ’ll also see examples usage visualisation statistics.three main functional programming tools (functionals, function factories, function operators), function factories least used. Generally, don’t tend reduce overall code complexity instead partition complexity easily digested chunks. Function factories also important building block useful function operators, ’ll learn Chapter 7.","code":"\npower1 <- function(exp) {\n  function(x) {\n    x ^ exp\n  }\n}\n\nsquare <- power1(2)\ncube <- power1(3)\nsquare(3)\n#> [1] 9\ncube(3)\n#> [1] 27"},{"path":"함수-공장.html","id":"outline-4","chapter":"6 함수 공장","heading":"Outline","text":"Section 6.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ’ll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 6.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ’ll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 6.3 illustrates use function factories \nexamples ggplot2. ’ll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 6.3 illustrates use function factories \nexamples ggplot2. ’ll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 6.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 6.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 6.5 shows can combine function\nfactories functionals rapidly generate family functions data.Section 6.5 shows can combine function\nfactories functionals rapidly generate family functions data.","code":""},{"path":"함수-공장.html","id":"prerequisites-3","chapter":"6 함수 공장","heading":"Prerequisites","text":"Make sure ’re familiar contents Sections 3.2.3 (first-class functions), 4.4.2 (function environment), 4.4.4 (execution environments) mentioned .Function factories need base R. ’ll use little rlang peek inside easily, ’ll use ggplot2 scales explore use function factories visualisation.","code":"\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(scales)"},{"path":"함수-공장.html","id":"factory-fundamentals","chapter":"6 함수 공장","heading":"6.2 Factory fundamentals","text":"key idea makes function factories work can expressed concisely:enclosing environment manufactured function execution\nenvironment function factory.takes words express big ideas, takes lot work really understand means. section help put pieces together interactive exploration diagrams.","code":""},{"path":"함수-공장.html","id":"environments-1","chapter":"6 함수 공장","heading":"6.2.1 Environments","text":"Let’s start taking look square() cube():’s obvious x comes , R find value associated exp? Simply printing manufactured functions revealing bodies identical; contents enclosing environment important factors. can get little insight using rlang::env_print(). shows us two different environments (originally execution environment power1()). environments parent, enclosing environment power1(), global environment.env_print() shows us environments binding exp, want see value35. can first getting environment function, extracting values:makes manufactured functions behave differently one another: names enclosing environment bound different values.","code":"\nsquare\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <environment: 0x55d1f510b598>\n\ncube\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x55d1f5235450>\n#> <environment: 0x55d1f51541c0>\nenv_print(square)\n#> <environment: 0x55d1f510b598>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\n\nenv_print(cube)\n#> <environment: 0x55d1f51541c0>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\nfn_env(square)$exp\n#> [1] 2\n\nfn_env(cube)$exp\n#> [1] 3"},{"path":"함수-공장.html","id":"diagram-conventions","chapter":"6 함수 공장","heading":"6.2.2 Diagram conventions","text":"can also show relationships diagram:’s lot going diagram details aren’t important. can simplify considerably using two conventions:free floating symbol lives global environment.free floating symbol lives global environment.environment without explicit parent inherits global\nenvironment.environment without explicit parent inherits global\nenvironment.view, focuses environments, doesn’t show direct link cube() square(). ’s link body function, identical , shown diagram.finish , let’s look execution environment square(10). square() executes x ^ exp finds x execution environment exp enclosing environment.","code":"\nsquare(10)\n#> [1] 100"},{"path":"함수-공장.html","id":"forcing-evaluation","chapter":"6 함수 공장","heading":"6.2.3 Forcing evaluation","text":"’s subtle bug power1() caused lazy evaluation. see problem need introduce indirection:square(2) return? hope returns 4:Unfortunately doesn’t x evaluated lazily square() run, power1() run. general, problem arise whenever binding changes calling factory function calling manufactured function. likely happen rarely, , lead real head-scratcher bug.can fix problem forcing evaluation force():Whenever create function factory, make sure every argument evaluated, using force() necessary argument used manufactured function.","code":"\nx <- 2\nsquare <- power1(x)\nx <- 3\nsquare(2)\n#> [1] 8\npower2 <- function(exp) {\n  force(exp)\n  function(x) {\n    x ^ exp\n  }\n}\n\nx <- 2\nsquare <- power2(x)\nx <- 3\nsquare(2)\n#> [1] 4"},{"path":"함수-공장.html","id":"stateful-funs","chapter":"6 함수 공장","heading":"6.2.4 Stateful functions","text":"함수 공장을 사용하면 함수 호출들에 대해 state 를 유지할수 있는데, 3.4.3 섹션에 기술된 fresh start 원칙때문에 일반적으로 쉬운 일은 아니다.two things make possible:enclosing environment manufactured function unique constant.enclosing environment manufactured function unique constant.R special assignment operator, <<-, modifies bindings \nenclosing environment.R special assignment operator, <<-, modifies bindings \nenclosing environment.일반 할당 연산자, <-, 는 항상 현재 환경에서 바인딩을 만든다. super assignment operator, <<- 은 부모 환경에 존재하는 이름을 새로 바인드 한다.following example shows can combine ideas create function records many times called:manufactured function run <<- + 1 modify enclosing environment. manufactured functions independent enclosing environments, independent counts:Stateful functions best used moderation. soon function starts managing state multiple variables, ’s better switch R6, topic Chapter ??.","code":"\nnew_counter <- function() {\n  i <- 0\n  \n  function() {\n    i <<- i + 1\n    i\n  }\n}\n\ncounter_one <- new_counter()\ncounter_two <- new_counter()\ncounter_one()\n#> [1] 1\ncounter_one()\n#> [1] 2\ncounter_two()\n#> [1] 1"},{"path":"함수-공장.html","id":"factory-pitfalls","chapter":"6 함수 공장","heading":"6.2.5 Garbage collection","text":"functions, can rely garbage collector clean large temporary objects created inside function. However, manufactured functions hold execution environment, ’ll need explicitly unbind large temporary objects rm(). Compare sizes g1() g2() example :","code":"\nf1 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  function() m\n}\n\ng1 <- f1(1e6)\nlobstr::obj_size(g1)\n#> 8,013,104 B\n\nf2 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  rm(x)\n  function() m\n}\n\ng2 <- f2(1e6)\nlobstr::obj_size(g2)\n#> 12,944 B"},{"path":"함수-공장.html","id":"exercises-18","chapter":"6 함수 공장","heading":"6.2.6 Exercises","text":"definition force() simple:\n\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x55d1f1342d40>\n#> <environment: namespace:base>\nbetter force(x) instead just x?definition force() simple:better force(x) instead just x?Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Create function pick() takes index, , argument \nreturns function argument x subsets x .\n\npick(1)(x)\n# equivalent \nx[[1]]\n\nlapply(mtcars, pick(5))\n# equivalent \nlapply(mtcars, function(x) x[[5]])Create function pick() takes index, , argument \nreturns function argument x subsets x .Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:\n\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(.equal(m1(x), 0))\nstopifnot(.equal(m2(x), var(x) * 99 / 100))Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:happens don’t use closure? Make predictions, verify \ncode .\n\n<- 0\nnew_counter2 <- function() {\n  <<- + 1\n  \n}happens don’t use closure? Make predictions, verify \ncode .happens use <- instead <<-? Make predictions, verify\ncode .\n\nnew_counter3 <- function() {\n  <- 0\n  function() {\n    <- + 1\n    \n  }\n}happens use <- instead <<-? Make predictions, verify\ncode .","code":"\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x55d1f1342d40>\n#> <environment: namespace:base>\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\ni <- 0\nnew_counter2 <- function() {\n  i <<- i + 1\n  i\n}\nnew_counter3 <- function() {\n  i <- 0\n  function() {\n    i <- i + 1\n    i\n  }\n}"},{"path":"함수-공장.html","id":"graph-fact","chapter":"6 함수 공장","heading":"6.3 Graphical factories","text":"’ll begin exploration useful function factories examples ggplot2.","code":""},{"path":"함수-공장.html","id":"labelling","chapter":"6 함수 공장","heading":"6.3.1 Labelling","text":"One goals scales package make easy customise labels ggplot2. provides many functions control fine details axes legends. formatter functions36 useful class functions make easier control appearance axis breaks. design functions might initially seem little odd: return function, call order format number.words, primary interface function factory. first glance, seems add extra complexity little gain. enables nice interaction ggplot2’s scales, accept functions label argument:","code":"\ny <- c(12345, 123456, 1234567)\ncomma_format()(y)\n#> [1] \"12,345\"    \"123,456\"   \"1,234,567\"\n\nnumber_format(scale = 1e-3, suffix = \" K\")(y)\n#> [1] \"12 K\"    \"123 K\"   \"1 235 K\"\ndf <- data.frame(x = 1, y = y)\ncore <- ggplot(df, aes(x, y)) + \n  geom_point() + \n  scale_x_continuous(breaks = 1, labels = NULL) +\n  labs(x = NULL, y = NULL)\n  \ncore\ncore + scale_y_continuous(\n  labels = comma_format()\n)\ncore + scale_y_continuous(\n  labels = number_format(scale = 1e-3, suffix = \" K\")\n)\ncore + scale_y_continuous(\n  labels = scientific_format()\n)"},{"path":"함수-공장.html","id":"histogram-bins","chapter":"6 함수 공장","heading":"6.3.2 Histogram bins","text":"little known feature geom_histogram() binwidth argument can function. particularly useful function executed group, means can different binwidths different facets, otherwise possible.illustrate idea, see variable binwidth might useful, ’m going construct example fixed binwidth isn’t great.facet number observations, variability different. nice request binwidths vary get approximately number observations bin. One way function factory inputs desired number bins (n), outputs function takes numeric vector returns binwidth:use pattern wrap around base R functions automatically find -called optimal37 binwidth, nclass.Sturges(), nclass.scott(), nclass.FD():","code":"\n# construct some sample data with very different numbers in each cell\nsd <- c(1, 5, 15)\nn <- 100\n\ndf <- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbinwidth_bins <- function(n) {\n  force(n)\n  \n  function(x) {\n    (max(x) - min(x)) / n\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = binwidth_bins(20)) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbase_bins <- function(type) {\n  fun <- switch(type,\n    Sturges = nclass.Sturges,\n    scott = nclass.scott,\n    FD = nclass.FD,\n    stop(\"Unknown type\", call. = FALSE)\n  )\n  \n  function(x) {\n    (max(x) - min(x)) / fun(x)\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = base_bins(\"FD\")) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)"},{"path":"함수-공장.html","id":"ggsave","chapter":"6 함수 공장","heading":"6.3.3 ggsave()","text":"Finally, want show function factory used internally ggplot2. ggplot2:::plot_dev() used ggsave() go file extension (e.g. png, jpeg etc) graphics device function (e.g. png(), jpeg()). challenge arises base graphics devices minor inconsistencies need paper :filename first argument file.filename first argument file.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.mildly simplified version plot_dev() shown :","code":"\nplot_dev <- function(ext, dpi = 96) {\n  force(dpi)\n  \n  switch(ext,\n    eps =  ,\n    ps  =  function(path, ...) {\n      grDevices::postscript(\n        file = filename, ..., onefile = FALSE, \n        horizontal = FALSE, paper = \"special\"\n      )\n    },\n    pdf = function(filename, ...) grDevices::pdf(file = filename, ...),\n    svg = function(filename, ...) svglite::svglite(file = filename, ...),\n    emf = ,\n    wmf = function(...) grDevices::win.metafile(...),\n    png = function(...) grDevices::png(..., res = dpi, units = \"in\"),\n    jpg = ,\n    jpeg = function(...) grDevices::jpeg(..., res = dpi, units = \"in\"),\n    bmp = function(...) grDevices::bmp(..., res = dpi, units = \"in\"),\n    tiff = function(...) grDevices::tiff(..., res = dpi, units = \"in\"),\n    stop(\"Unknown graphics extension: \", ext, call. = FALSE)\n  )\n}\n\nplot_dev(\"pdf\")\n#> function(filename, ...) grDevices::pdf(file = filename, ...)\n#> <bytecode: 0x55d1f5f04150>\n#> <environment: 0x55d1f62b0728>\nplot_dev(\"png\")\n#> function(...) grDevices::png(..., res = dpi, units = \"in\")\n#> <bytecode: 0x55d1f5cc6c30>\n#> <environment: 0x55d1f59505b0>"},{"path":"함수-공장.html","id":"exercises-19","chapter":"6 함수 공장","heading":"6.3.4 Exercises","text":"Compare contrast ggplot2::label_bquote() \nscales::number_format()","code":""},{"path":"함수-공장.html","id":"stat-fact","chapter":"6 함수 공장","heading":"6.4 Statistical factories","text":"motivating examples function factories come statistics:Box-Cox transformation.Bootstrap resampling.Maximum likelihood estimation.examples can tackled without function factories, think function factories good fit problems provide elegant solutions. examples expect statistical background, feel free skip don’t make much sense .","code":""},{"path":"함수-공장.html","id":"box-cox-transformation","chapter":"6 함수 공장","heading":"6.4.1 Box-Cox transformation","text":"Box-Cox transformation (type power transformation) flexible transformation often used transform data towards normality. single parameter, \\(\\lambda\\), controls strength transformation. express transformation simple two argument function:re-formulating function factory makes easy explore behaviour stat_function():general, allows use Box-Cox transformation function accepts unary transformation function: don’t worry function providing ... pass along additional arguments. also think partitioning lambda x two different function arguments natural since lambda plays quite different role x.","code":"\nboxcox1 <- function(x, lambda) {\n  stopifnot(length(lambda) == 1)\n  \n  if (lambda == 0) {\n    log(x)\n  } else {\n    (x ^ lambda - 1) / lambda\n  }\n}\nboxcox2 <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}\n\nstat_boxcox <- function(lambda) {\n  stat_function(aes(colour = lambda), fun = boxcox2(lambda), size = 1)\n}\n\nggplot(data.frame(x = c(0, 5)), aes(x)) + \n  lapply(c(0.5, 1, 1.5), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))\n\n# visually, log() does seem to make sense as the transformation\n# for lambda = 0; as values get smaller and smaller, the function\n# gets close and closer to a log transformation\nggplot(data.frame(x = c(0.01, 1)), aes(x)) + \n  lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))"},{"path":"함수-공장.html","id":"bootstrap-generators","chapter":"6 함수 공장","heading":"6.4.2 Bootstrap generators","text":"Function factories useful approach bootstrapping. Instead thinking single bootstrap (always need one!), can think bootstrap generator, function yields fresh bootstrap every time called:advantage function factory clear parametric bootstrap first fit model. can setup step , factory called, rather every time generate bootstrap:use rm(mod) linear model objects quite large (include complete copies model matrix input data) want keep manufactured function small possible.","code":"\nboot_permute <- function(df, var) {\n  n <- nrow(df)\n  force(var)\n  \n  function() {\n    col <- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nboot_mtcars1 <- boot_permute(mtcars, \"mpg\")\nhead(boot_mtcars1())\n#> [1] 16.4 22.8 22.8 22.8 16.4 19.2\nhead(boot_mtcars1())\n#> [1] 17.8 18.7 30.4 30.4 16.4 21.0\nboot_model <- function(df, formula) {\n  mod <- lm(formula, data = df)\n  fitted <- unname(fitted(mod))\n  resid <- unname(resid(mod))\n  rm(mod)\n\n  function() {\n    fitted + sample(resid)\n  }\n} \n\nboot_mtcars2 <- boot_model(mtcars, mpg ~ wt)\nhead(boot_mtcars2())\n#> [1] 25.0 24.0 21.7 19.2 24.9 16.0\nhead(boot_mtcars2())\n#> [1] 27.4 21.0 20.3 19.4 16.3 21.3"},{"path":"함수-공장.html","id":"MLE","chapter":"6 함수 공장","heading":"6.4.3 Maximum likelihood estimation","text":"\n\ngoal maximum likelihood estimation (MLE) find parameter values distribution make observed data likely. MLE, start probability function. example, take Poisson distribution. know \\(\\lambda\\), can compute probability getting vector \\(\\mathbf{x}\\) values (\\(x_1\\), \\(x_2\\), …, \\(x_n\\)) multiplying Poisson probability function follows:\\[ P(\\lambda, \\mathbf{x}) = \\prod_{=1}^{n} \\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!} \\]statistics, almost always work log function. log monotonic transformation preserves important properties (.e. extrema occur place), specific advantages:log turns product sum, easier work .log turns product sum, easier work .Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Let’s apply log transformation probability function simplify much possible:\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\log(\\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!}) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\left( x_i \\log(\\lambda) - \\lambda - \\log(x_i!) \\right) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n     \\sum_{=1}^{n} x_i \\log(\\lambda)\n   - \\sum_{=1}^{n} \\lambda \n   - \\sum_{=1}^{n} \\log(x_i!) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n   \\log(\\lambda) \\sum_{=1}^{n} x_i - n \\lambda - \\sum_{=1}^{n} \\log(x_i!) \\]can now turn function R function. R function quite elegant R vectorised , ’s statistical programming language, R comes built-functions like log-factorial (lfactorial()).Consider vector observations:can use lprob_poisson() compute (logged) probability x1 different values lambda.far ’ve thinking lambda fixed known function told us probability getting different values x. real-life, observe x lambda unknown. likelihood probability function seen lens: want find lambda makes observed x likely. , given x, value lambda gives us highest value lprob_poisson()?statistics, highlight change perspective writing \\(f_{\\mathbf{x}}(\\lambda)\\) instead \\(f(\\lambda, \\mathbf{x})\\). R, can use function factory. provide x generate function single parameter, lambda:(don’t need force() length() implicitly forces evaluation x.)One nice thing approach can precomputation: term involves x can computed factory. useful ’re going need call function many times find best lambda.Now can use function find value lambda maximizes (log) likelihood:Rather trial error, can automate process finding best value optimise(). evaluate ll1() many times, using mathematical tricks narrow largest value quickly possible. results tell us highest value -30.27 occurs lambda = 32.1:Now, solved problem without using function factory optimise() passes ... function optimised. means use log-probability function directly:advantage using function factory fairly small, two niceties:can precompute values factory, saving computation time\niteration.can precompute values factory, saving computation time\niteration.two-level design better reflects mathematical structure \nunderlying problem.two-level design better reflects mathematical structure \nunderlying problem.advantages get bigger complex MLE problems, multiple parameters multiple data vectors.","code":"\nlprob_poisson <- function(lambda, x) {\n  n <- length(x)\n  (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x))\n}\nx1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\nlprob_poisson(10, x1)\n#> [1] -184\nlprob_poisson(20, x1)\n#> [1] -61.1\nlprob_poisson(30, x1)\n#> [1] -31\nll_poisson1 <- function(x) {\n  n <- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\nll_poisson2 <- function(x) {\n  n <- length(x)\n  sum_x <- sum(x)\n  c <- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\nll1 <- ll_poisson2(x1)\n\nll1(10)\n#> [1] -184\nll1(20)\n#> [1] -61.1\nll1(30)\n#> [1] -31\noptimise(ll1, c(0, 100), maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3\noptimise(lprob_poisson, c(0, 100), x = x1, maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3"},{"path":"함수-공장.html","id":"exercises-20","chapter":"6 함수 공장","heading":"6.4.4 Exercises","text":"boot_model(), don’t need force evaluation df\nmodel?boot_model(), don’t need force evaluation df\nmodel?might formulate Box-Cox transformation like ?\n\nboxcox3 <- function(x) {\n  function(lambda) {\n    (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}might formulate Box-Cox transformation like ?don’t need worry boot_permute() stores copy \ndata inside function generates?don’t need worry boot_permute() stores copy \ndata inside function generates?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?","code":"\nboxcox3 <- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}"},{"path":"함수-공장.html","id":"functional-factories","chapter":"6 함수 공장","heading":"6.5 Function factories + functionals","text":"finish chapter, ’ll show might combine functionals function factories turn data many functions. following code creates many specially named power functions iterating list arguments:idea extends straightforward way function factory takes two (replace map() map2()) (replace pmap()) arguments.One downside current construction prefix every function call funs$. three ways eliminate additional syntax:temporary effect, can use ():\n\n(funs, root(100))\n#> [1] 10\nrecommend makes clear code \nexecuted special context context .temporary effect, can use ():recommend makes clear code \nexecuted special context context .longer effect, can attach() functions search path,\ndetach() ’re done:\n\nattach(funs)\n#> following objects masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\n’ve probably told avoid using attach(), ’s generally\ngood advice. However, situation little different usual\n’re attaching list functions, data frame. ’s less\nlikely ’ll modify function column data frame, \nworst problems attach() don’t apply.longer effect, can attach() functions search path,\ndetach() ’re done:’ve probably told avoid using attach(), ’s generally\ngood advice. However, situation little different usual\n’re attaching list functions, data frame. ’s less\nlikely ’ll modify function column data frame, \nworst problems attach() don’t apply.Finally, copy functions global environment \nenv_bind() (’ll learn !!! Section ??).\nmostly permanent:\n\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\ncan later unbind names, ’s guarantee \nhaven’t rebound meantime, might deleting \nobject someone else created.\n\nrlang::env_unbind(globalenv(), names(funs))Finally, copy functions global environment \nenv_bind() (’ll learn !!! Section ??).\nmostly permanent:can later unbind names, ’s guarantee \nhaven’t rebound meantime, might deleting \nobject someone else created.’ll learn alternative approach problem Section ??. Instead using function factory, construct function quasiquotation. requires additional knowledge, generates functions readable bodies, avoids accidentally capturing large objects enclosing scope. use idea Section ?? work tools generating HTML R.","code":"\nnames <- list(\n  square = 2, \n  cube = 3, \n  root = 1/2, \n  cuberoot = 1/3, \n  reciprocal = -1\n)\nfuns <- purrr::map(names, power1)\n\nfuns$root(64)\n#> [1] 8\nfuns$root\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x55d1f5235450>\n#> <environment: 0x55d1f7d01378>\nwith(funs, root(100))\n#> [1] 10\nattach(funs)\n#> The following objects are masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\nrlang::env_unbind(globalenv(), names(funs))"},{"path":"함수-공장.html","id":"exercises-21","chapter":"6 함수 공장","heading":"6.5.1 Exercises","text":"following commands equivalent (x, f(z))?\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\ndepends.\nfollowing commands equivalent (x, f(z))?x$f(x$z).f(x$z).x$f(z).f(z).depends.Compare contrast effects env_bind() vs. attach() \nfollowing code.\n\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> following objects masked package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))Compare contrast effects env_bind() vs. attach() \nfollowing code.","code":"\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> The following objects are masked from package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))"},{"path":"function-operators.html","id":"function-operators","chapter":"7 함수 연산자","heading":"7 함수 연산자","text":"","code":""},{"path":"function-operators.html","id":"들어가기-1","chapter":"7 함수 연산자","heading":"7.1 들어가기","text":"이 장에서는 함수 연산자들에 대해 배울 것이다. 함수 연산자 는 하나 이상의 함수를 입력을 취하여 함수를 출력으로 반환하는 함수이다. 다음의 코드는 단순한 함수 연산자 chatty()를 보여준다. wraps function, making new function prints first argument. might create function like gives window see functionals, like map_int(), work.Function operators closely related function factories; indeed ’re just function factory takes function input. Like factories, ’s nothing can’t without , often allow factor complexity order make code readable reusable.Function operators typically paired functionals. ’re using -loop, ’s rarely reason use function operator, make code complex little gain.’re familiar Python, decorators just another name function operators.","code":"\nchatty <- function(f) {\n  force(f)\n  \n  function(x, ...) {\n    res <- f(x, ...)\n    cat(\"Processing \", x, \"\\n\", sep = \"\")\n    res\n  }\n}\nf <- function(x) x ^ 2\ns <- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n#> Processing 3\n#> Processing 2\n#> Processing 1\n#> [1] 9 4 1"},{"path":"function-operators.html","id":"outline-5","chapter":"7 함수 연산자","heading":"Outline","text":"Section 7.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 7.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 7.3 works problem amenable solution\nfunction operators: downloading many web pages.Section 7.3 works problem amenable solution\nfunction operators: downloading many web pages.","code":""},{"path":"function-operators.html","id":"prerequisites-4","chapter":"7 함수 연산자","heading":"Prerequisites","text":"Function operators type function factory, make sure ’re familiar least Section 3.2 go .’ll use purrr couple functionals learned Chapter 5, function operators ’ll learn . ’ll also use memoise package38 memoise() operator.","code":"\nlibrary(purrr)\nlibrary(memoise)"},{"path":"function-operators.html","id":"existing-fos","chapter":"7 함수 연산자","heading":"7.2 Existing function operators","text":"two useful function operators help solve common recurring problems, give sense function operators can : purrr::safely() memoise::memoise().","code":""},{"path":"function-operators.html","id":"safely","chapter":"7 함수 연산자","heading":"7.2.1 Capturing errors with purrr::safely()","text":"One advantage -loops one iterations fails, can still access results failure:thing functional, get output, making hard figure problem lies:purrr::safely() provides tool help problem. safely() function operator transforms function turn errors data. (can learn basic idea makes work Section ??.) Let’s start taking look outside map_dbl():Like function operators, safely() takes function returns wrapped function can call usual:can see function transformed safely() always returns list two elements, result error. function runs successfully, error NULL result contains result; function fails, result NULL error contains error.Now lets use safely() functional:output slightly inconvenient form, since four lists, list containing result error. can make output easier use turning “inside-” purrr::transpose(), get list results list errors:Now can easily find results worked, inputs failed:can use technique many different situations. example, imagine ’re fitting generalised linear model (GLM) list data frames. GLMs can sometimes fail optimisation problems, still want able try fit models, later look back failed:think great example power combining functionals function operators: safely() lets succinctly express need solve common data analysis problem.purrr comes three function operators similar vein:possibly(): returns default value ’s error.\nprovides way tell error occured , ’s best\nreserved cases ’s obvious sentinel value (like NA).possibly(): returns default value ’s error.\nprovides way tell error occured , ’s best\nreserved cases ’s obvious sentinel value (like NA).quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.auto_browser(): automatically executes browser() inside \nfunction ’s error.auto_browser(): automatically executes browser() inside \nfunction ’s error.See documentation details.","code":"\nx <- list(\n  c(0.512, 0.165, 0.717),\n  c(0.064, 0.781, 0.427),\n  c(0.890, 0.785, 0.495),\n  \"oops\"\n)\n\nout <- rep(NA_real_, length(x))\nfor (i in seq_along(x)) {\n  out[[i]] <- sum(x[[i]])\n}\n#> Error in sum(x[[i]]): invalid 'type' (character) of argument\nout\n#> [1] 1.39 1.27 2.17   NA\nmap_dbl(x, sum)\n#> Error in .Primitive(\"sum\")(..., na.rm = na.rm): invalid 'type' (character) of argument\nsafe_sum <- safely(sum)\nsafe_sum\n#> function (...) \n#> capture_error(.f(...), otherwise, quiet)\n#> <bytecode: 0x55dd0415f418>\n#> <environment: 0x55dd0415ef80>\nstr(safe_sum(x[[1]]))\n#> List of 2\n#>  $ result: num 1.39\n#>  $ error : NULL\nstr(safe_sum(x[[4]]))\n#> List of 2\n#>  $ result: NULL\n#>  $ error :List of 2\n#>   ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- map(x, safely(sum))\nstr(out)\n#> List of 4\n#>  $ :List of 2\n#>   ..$ result: num 1.39\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 1.27\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 2.17\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: NULL\n#>   ..$ error :List of 2\n#>   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- transpose(map(x, safely(sum)))\nstr(out)\n#> List of 2\n#>  $ result:List of 4\n#>   ..$ : num 1.39\n#>   ..$ : num 1.27\n#>   ..$ : num 2.17\n#>   ..$ : NULL\n#>  $ error :List of 4\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ :List of 2\n#>   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nok <- map_lgl(out$error, is.null)\nok\n#> [1]  TRUE  TRUE  TRUE FALSE\n\nx[!ok]\n#> [[1]]\n#> [1] \"oops\"\n\nout$result[ok]\n#> [[1]]\n#> [1] 1.39\n#> \n#> [[2]]\n#> [1] 1.27\n#> \n#> [[3]]\n#> [1] 2.17\nfit_model <- function(df) {\n  glm(y ~ x1 + x2 * x3, data = df)\n}\n\nmodels <- transpose(map(datasets, safely(fit_model)))\nok <- map_lgl(models$error, is.null)\n\n# which data failed to converge?\ndatasets[!ok]\n\n# which models were successful?\nmodels[ok]"},{"path":"function-operators.html","id":"memoise","chapter":"7 함수 연산자","heading":"7.2.2 Caching computations with memoise::memoise()","text":"\nAnother handy function operator memoise::memoise(). memoises function, meaning function remember previous inputs return cached results. Memoisation example classic computer science tradeoff memory versus speed. memoised function can run much faster, stores previous inputs outputs, uses memory.Let’s explore idea toy function simulates expensive operation:memoise function, ’s slow call new arguments. call arguments ’s seen ’s instantaneous: retrieves previous value computation.relatively realistic use memoisation computing Fibonacci series. Fibonacci series defined recursively: first two values defined convention, \\(f(0) = 0\\), \\(f(1) = 1\\), \\(f(n) = f(n - 1) + f(n - 2)\\) (positive integer). naive version slow , example, fib(10) computes fib(9) fib(8), fib(9) computes fib(8) fib(7), .Memoising fib() makes implementation much faster value computed :future calls can rely previous computations:example dynamic programming, complex problem can broken many overlapping subproblems, remembering results subproblem considerably improves performance.Think carefully memoising function. function pure, .e. output depend input, get misleading confusing results. created subtle bug devtools memoised results available.packages(), rather slow download large file CRAN. available packages don’t change frequently, R process ’s running days, changes can become important, problem arose long-running R processes, bug painful find.","code":"\nslow_function <- function(x) {\n  Sys.sleep(1)\n  x * 10 * runif(1)\n}\nsystem.time(print(slow_function(1)))\n#> [1] 0.808\n#>    user  system elapsed \n#>       0       0       1\n\nsystem.time(print(slow_function(1)))\n#> [1] 8.34\n#>    user  system elapsed \n#>   0.003   0.000   1.004\nfast_function <- memoise::memoise(slow_function)\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>   0.001   0.000   1.002\n\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>   0.017   0.000   0.017\nfib <- function(n) {\n  if (n < 2) return(1)\n  fib(n - 2) + fib(n - 1)\n}\nsystem.time(fib(23))\n#>    user  system elapsed \n#>   0.047   0.000   0.047\nsystem.time(fib(24))\n#>    user  system elapsed \n#>    0.08    0.00    0.08\nfib2 <- memoise::memoise(function(n) {\n  if (n < 2) return(1)\n  fib2(n - 2) + fib2(n - 1)\n})\nsystem.time(fib2(23))\n#>    user  system elapsed \n#>   0.007   0.000   0.007\nsystem.time(fib2(24))\n#>    user  system elapsed \n#>   0.001   0.000   0.001"},{"path":"function-operators.html","id":"exercises-22","chapter":"7 함수 연산자","heading":"7.2.3 Exercises","text":"Base R provides function operator form Vectorize().\n? might use ?Base R provides function operator form Vectorize().\n? might use ?Read source code possibly(). work?Read source code possibly(). work?Read source code safely(). work?Read source code safely(). work?","code":""},{"path":"function-operators.html","id":"fo-case-study","chapter":"7 함수 연산자","heading":"7.3 Case study: Creating your own function operators","text":"meomoise() safely() useful also quite complex. case study ’ll learn create simpler function operators. Imagine named vector URLs ’d like download one disk. ’s pretty simple walk2() file.download():approach fine handful URLs, vector gets longer, might want add couple features:Add small delay request avoid hammering server.Add small delay request avoid hammering server.Display . every URLs know function still\nworking.Display . every URLs know function still\nworking.’s relatively easy add extra features ’re using loop:think loop suboptimal interleaves different concerns: pausing, showing progress, downloading. makes code harder read, makes harder reuse components new situations. Instead, let’s see can use function operators extract pausing showing progress make reusable.First, let’s write function operator adds small delay. ’m going call delay_by() reasons clear shortly, two arguments: function wrap, amount delay add. actual implementation quite simple. main trick forcing evaluation arguments described Section 6.2.5, function operators special type function factory:can use original walk2():Creating function display occasional dot little harder, can longer rely index loop. pass index along another argument, breaks encapsulation: concern progress function now becomes problem higher level wrapper needs handle. Instead, ’ll use another function factory trick (Section 6.2.4), progress wrapper can manage internal counter:Now can express original loop :starting get little hard read composing many function calls, arguments getting spread . One way resolve use pipe:pipe works well ’ve carefully chosen function names yield (almost) readable sentence: take download.file (add) dot every 10 iterations, delay 0.1s. clearly can express intent code function names, easily others (including future !) can read understand code.","code":"\nurls <- c(\n  \"adv-r\" = \"https://adv-r.hadley.nz\", \n  \"r4ds\" = \"http://r4ds.had.co.nz/\"\n  # and many many more\n)\npath <- paste(tempdir(), names(urls), \".html\")\n\nwalk2(urls, path, download.file, quiet = TRUE)\nfor(i in seq_along(urls)) {\n  Sys.sleep(0.1)\n  if (i %% 10 == 0) cat(\".\")\n  download.file(urls[[i]], paths[[i]])\n}\ndelay_by <- function(f, amount) {\n  force(f)\n  force(amount)\n  \n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\nsystem.time(runif(100))\n#>    user  system elapsed \n#>       0       0       0\nsystem.time(delay_by(runif, 0.1)(100))\n#>    user  system elapsed \n#>     0.0     0.0     0.1\nwalk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)\ndot_every <- function(f, n) {\n  force(f)\n  force(n)\n  \n  i <- 0\n  function(...) {\n    i <<- i + 1\n    if (i %% n == 0) cat(\".\")\n    f(...)\n  }\n}\nwalk(1:100, runif)\nwalk(1:100, dot_every(runif, 10))\n#> ..........\nwalk2(\n  urls, path, \n  dot_every(delay_by(download.file, 0.1), 10), \n  quiet = TRUE\n)\nwalk2(\n  urls, path, \n  download.file %>% dot_every(10) %>% delay_by(0.1), \n  quiet = TRUE\n)"},{"path":"function-operators.html","id":"exercises-23","chapter":"7 함수 연산자","heading":"7.3.1 Exercises","text":"Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).memoise file.download()? ?memoise file.download()? ?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Write function operator logs timestamp message file\nevery time function run.Write function operator logs timestamp message file\nevery time function run.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t \nextra delay.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t \nextra delay.","code":""}]
